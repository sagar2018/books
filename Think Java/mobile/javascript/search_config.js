var textForPages = ["Think Java                                  How to Think Like a Computer Scientist                                                                                   Allen B. Downey                                                                                                     5.1.2","Copyright © 2012 Allen Downey.                                Permission is granted to copy, distribute, transmit and adapt this work under                             a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported                             License: http://creativecommons.org/licenses/by-nc-sa/3.0/                              If you are interested in distributing a commercial version of this work, please                             contact Allen B. Downey.                                                                                                      A                                                                A                             The original form of this book is LT X source code. Compiling this LT X                                                                   E                                                                                                       E                             source has the eﬀect of generating a device-independent representation of the                             book, which can be converted to other formats and printed.                                  A                             The LT X source for this book is available from: http://thinkapjava.com                                    E                             This book was typeset using LT X. The illustrations were drawn in xﬁg. All                                                           A                                                             E                             of these are free, open-source programs.","Preface                                “As we enjoy great Advantages from the Inventions of others, we                          should be glad of an Opportunity to serve others by any Invention                          of ours, and this we should do freely and generously.”                          —Benjamin Franklin, quoted in Benjamin Franklin by Edmund                          S. Morgan.                        Why I wrote this book                     This is the ﬁfth edition of a book I started writing in 1999, when I was                    teaching at Colby College. I had taught an introductory computer science                    class using the Java programming language, but I had not found a textbook                    I was happy with. For one thing, they were all too big! There was no way my                    students would read 800 pages of dense, technical material, even if I wanted                    them to. And I didn’t want them to. Most of the material was too speciﬁc—                    details about Java and its libraries that would be obsolete by the end of the                    semester, and that obscured the material I really wanted to get to.                    The other problem I found was that the introduction to object-oriented pro-                    gramming was too abrupt. Many students who were otherwise doing well                    just hit a wall when we got to objects, whether we did it at the beginning,                    middle or end.                     So I started writing. I wrote a chapter a day for 13 days, and on the 14th                    day I edited. Then I sent it to be photocopied and bound. When I handed it                    out on the ﬁrst day of class, I told the students that they would be expected                    to read one chapter a week. In other words, they would read it seven times                    slower than I wrote it.","iv                                                    Chapter 0. Preface                               The philosophy behind it                              Here are some of the ideas that make the book the way it is:                                  Vocabulary is important. Students need to be able to talk about pro-                                   grams and understand what I am saying. I try to introduce the min-                                   imum number of terms, to deﬁne them carefully when they are ﬁrst                                   used, and to organize them in glossaries at the end of each chapter.                                   In my class, I include vocabulary questions on quizzes and exams, and                                   require students to use appropriate terms in short-answer responses.                                  To write a program, students have to understand the algorithm, know                                   the programming language, and they have to be able to debug. I think                                   too many books neglect debugging. This book includes an appendix on                                   debugging and an appendix on program development (which can help                                   avoid debugging). I recommend that students read this material early                                   and come back to it often.                                  Some concepts take time to sink in. Some of the more diﬃcult ideas in                                   the book, like recursion, appear several times. By coming back to these                                   ideas, I am trying to give students a chance to review and reinforce or,                                   if they missed it the ﬁrst time, a chance to catch up.                                  I try to use the minimum amount of Java to get the maximum amount                                   of programming power. The purpose of this book is to teach program-                                   ming and some introductory ideas from computer science, not Java. I                                   left out some language features, like the switch statement, that are                                   unnecessary, and avoided most of the libraries, especially the ones like                                   the AWT that have been changing quickly or are likely to be replaced.                              The minimalism of my approach has some advantages. Each chapter is about                             ten pages, not including the exercises. In my classes I ask students to read                             each chapter before we discuss it, and I have found that they are willing to                             do that and their comprehension is good. Their preparation makes class time                             available for discussion of the more abstract material, in-class exercises, and                             additional topics that aren’t in the book.                              But minimalism has some disadvantages. There is not much here that is                             intrinsically fun. Most of my examples demonstrate the most basic use of                             a language feature, and many of the exercises involve string manipulation","v                      and mathematical ideas. I think some of them are fun, but many of the                    things that excite students about computer science, like graphics, sound and                    network applications, are given short shrift.                     The problem is that many of the more exciting features involve lots of details                    and not much concept. Pedagogically, that means a lot of eﬀort for not much                    payoﬀ. So there is a tradeoﬀ between the material that students enjoy and                    the material that is most intellectually rich. I leave it to individual teachers                    to ﬁnd the balance that is best for their classes. To help, the book includes                    appendices that cover graphics, keyboard input and ﬁle input.                       Object-oriented programming                     Some books introduce objects immediately; others warm up with a more                    procedural style and develop object-oriented style more gradually. This book                    uses the “objects late” approach.                     Many of Java’s object-oriented features are motivated by problems with pre-                    vious languages, and their implementations are inﬂuenced by this history.                    Some of these features are hard to explain if students aren’t familiar with                    the problems they solve.                     It wasn’t my intention to postpone object-oriented programming. On the                    contrary, I got to it as quickly as I could, limited by my intention to introduce                    concepts one at a time, as clearly as possible, in a way that allows students                    to practice each idea in isolation before adding the next. But I have to admit                    that it takes some time to get there.                       The Computer Science AP Exam                     Naturally, when the College Board announced that the AP Exam would                    switch to Java, I made plans to update the Java version of the book. Looking                    at the proposed AP Syllabus, I saw that their subset of Java was all but                    identical to the subset I had chosen.                     During January 2003, I worked on the Fourth Edition of the book, making                    these changes:                         I added sections to improve coverage of the AP syllabus.","vi                                                    Chapter 0. Preface                                   I improved the appendices on debugging and program development.                                  I collected the exercises, quizzes, and exam questions I had used in                                   my classes and put them at the end of the appropriate chapters. I                                   also made up some problems that are intended to help with AP Exam                                   preparation.                               Finally, in August 2011 I wrote the ﬁfth edition, adding coverage of the                             GridWorld Case Study that is part of the AP Exam.                                Free books!                              Since the beginning, this book has under a license that allows users to copy,                             distribute and modify the book. Readers can download the book in a variety                             of formats and read it on screen or print it. Teachers are free to print as                             many copies as they need. And anyone is free to customize the book for                             their needs.                              People have translated the book into other computer languages (including                             Python and Eiﬀel), and other natural languages (including Spanish, French                             and German). Many of these derivatives are also available under free licenses.                              Motivated by Open Source Software, I adopted the philosophy of releasing                             the book early and updating it often. I do my best to minimize the number                             of errors, but I also depend on readers to help out.                              The response has been great. I get messages almost every day from people                             who have read the book and liked it enough to take the trouble to send in                             a “bug report.” Often I can correct an error and post an updated version                             within a few minutes. I think of the book as a work in progress, improving a                             little whenever I have time to make a revision, or when readers send feedback.                                 Oh, the title                              I get a lot of grief about the title of the book. Not everyone understands                             that it is—mostly—a joke. Reading this book will probably not make you                             think like a computer scientist. That takes time, experience, and probably a                             few more classes.","vii                      But there is a kernel of truth in the title: this book is not about Java, and                    it is only partly about programming. If it is successful, this book is about a                    way of thinking. Computer scientists have an approach to problem-solving,                    and a way of crafting solutions, that is unique, versatile and powerful. I hope                    that this book gives you a sense of what that approach is, and that at some                    point you will ﬁnd yourself thinking like a computer scientist.                      Allen Downey                    Needham, Massachusetts                    July 13, 2011                        Contributors List                      When I started writing free books, it didn’t occur to me to keep a con-                    tributors list. When Jeﬀ Elkner suggested it, it seemed so obvious that I am                    embarassed by the omission. This list starts with the 4th Edition, so it omits                    many people who contributed suggestions and corrections to earlier versions.                     If you have additional comments, please send them to:                    feedback@greenteapress.com                          Ellen Hildreth used this book to teach Data Structures at Wellesley                          College, and she gave me a whole stack of corrections, along with some                          great suggestions.                         Tania Passﬁeld pointed out that the glossary of Chapter 4 has some                          leftover terms that no longer appear in the text.                                                                                            2                        Elizabeth Wiethoﬀ noticed that my series expansion of exp(−x ) was                          wrong. She is also working on a Ruby version of the book!                         Matt Crawford sent in a whole patch ﬁle full of corrections!                         Chi-Yu Li pointed out a typo and an error in one of the code examples.                         Doan Thanh Nam corrected an example in Chapter 3.                         Stijn Debrouwere found a math typo.","viii                                                  Chapter 0. Preface                                   Muhammad Saied translated the book into Arabic, and found several                                   errors.                                 Marius Margowski found an inconsistency in a code example.                                   Guy Driesen found several typos.                                  Leslie Klein discovered yet another error in the series expansion of                                          2                                   exp(−x ), identiﬁed typos in the card array ﬁgures, and gave helpful                                   suggestions to clarify several exercises.                               Finally, I wish to acknowledge Chris Mayﬁeld for his signiﬁcant contribution                             to version 5.1 of this book. His careful review lead to over one hundred                             corrections and improvements throughout. Several new features include em-                             bedded hypertext links and cross references, consistent layout of all exercises,                             and Java syntax highlighting in code examples.","Contents                            Preface                                                                    iii                      1 The way of the program                                                    1                         1.1    What is a programming language? . . . . . . . . . . . . . . .     1                       1.2    What is a program? . . . . . . . . . . . . . . . . . . . . . . .  3                        1.3    What is debugging? . . . . . . . . . . . . . . . . . . . . . . .  4                        1.4    Formal and natural languages . . . . . . . . . . . . . . . . .    6                        1.5    The ﬁrst program . . . . . . . . . . . . . . . . . . . . . . . .  8                        1.6    Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9                        1.7    Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11                      2 Variables and types                                                      13                        2.1    More printing . . . . . . . . . . . . . . . . . . . . . . . . . . 13                        2.2    Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15                        2.3    Assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . 15                        2.4    Printing variables . . . . . . . . . . . . . . . . . . . . . . . . 16                        2.5    Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18                       2.6    Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18","x                                                                  Contents                                  2.7    Order of operations . . . . . . . . . . . . . . . . . . . . . . . 19                                 2.8    Operators for Strings . . . . . . . . . . . . . . . . . . . . . 20                                 2.9    Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . 20                                2.10   Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21                                 2.11   Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22                                3 Void methods                                                             25                                 3.1    Floating-point . . . . . . . . . . . . . . . . . . . . . . . . . . 25                                 3.2    Converting from double to int . . . . . . . . . . . . . . . . 26                                3.3    Math methods . . . . . . . . . . . . . . . . . . . . . . . . . . 27                                 3.4    Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . 28                                 3.5    Adding new methods . . . . . . . . . . . . . . . . . . . . . . 29                                 3.6    Classes and methods . . . . . . . . . . . . . . . . . . . . . . 31                                 3.7    Programs with multiple methods . . . . . . . . . . . . . . . . 32                                 3.8    Parameters and arguments . . . . . . . . . . . . . . . . . . . 33                                 3.9    Stack diagrams . . . . . . . . . . . . . . . . . . . . . . . . . 34                                 3.10   Methods with multiple parameters . . . . . . . . . . . . . . . 35                                 3.11   Methods that return values . . . . . . . . . . . . . . . . . . . 36                                3.12   Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36                                 3.13   Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37                                4 Conditionals and recursion                                               39                                 4.1    The modulus operator . . . . . . . . . . . . . . . . . . . . . 39                                 4.2    Conditional execution . . . . . . . . . . . . . . . . . . . . . . 39                                4.3    Alternative execution . . . . . . . . . . . . . . . . . . . . . . 40","Contents                                                                   xi                         4.4    Chained conditionals . . . . . . . . . . . . . . . . . . . . . . 41                       4.5    Nested conditionals . . . . . . . . . . . . . . . . . . . . . . . 42                        4.6    The return statement . . . . . . . . . . . . . . . . . . . . . . 43                        4.7    Type conversion . . . . . . . . . . . . . . . . . . . . . . . . . 43                       4.8    Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44                        4.9    Stack diagrams for recursive methods . . . . . . . . . . . . . 46                        4.10   Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46                       4.11   Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47                      5 GridWorld: Part 1                                                        51                        5.1    Getting started . . . . . . . . . . . . . . . . . . . . . . . . . 51                        5.2    BugRunner . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52                       5.3    Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53                       6 Value methods                                                            55                       6.1    Return values . . . . . . . . . . . . . . . . . . . . . . . . . . 55                        6.2    Program development . . . . . . . . . . . . . . . . . . . . . . 57                        6.3    Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . 59                       6.4    Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . 60                        6.5    Boolean expressions . . . . . . . . . . . . . . . . . . . . . . . 61                       6.6    Logical operators . . . . . . . . . . . . . . . . . . . . . . . . 62                        6.7    Boolean methods . . . . . . . . . . . . . . . . . . . . . . . . 63                        6.8    More recursion . . . . . . . . . . . . . . . . . . . . . . . . . . 64                       6.9    Leap of faith . . . . . . . . . . . . . . . . . . . . . . . . . . . 66                        6.10   One more example . . . . . . . . . . . . . . . . . . . . . . . 67                        6.11   Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68                       6.12   Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69","xii                                                                Contents                               7 Iteration and loops                                                      75                                7.1    Multiple assignment . . . . . . . . . . . . . . . . . . . . . . . 75                                 7.2    The while statement . . . . . . . . . . . . . . . . . . . . . . 76                                 7.3    Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78                                 7.4    Two-dimensional tables . . . . . . . . . . . . . . . . . . . . . 80                                 7.5    Encapsulation and generalization . . . . . . . . . . . . . . . 81                                 7.6    Methods and encapsulation . . . . . . . . . . . . . . . . . . . 82                                 7.7    Local variables . . . . . . . . . . . . . . . . . . . . . . . . . . 83                                7.8    More generalization . . . . . . . . . . . . . . . . . . . . . . . 84                                 7.9    Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86                                 7.10   Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87                               8 Strings and things                                                       91                                 8.1    Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91                                 8.2    Length . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92                                 8.3    Traversal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93                                 8.4    Run-time errors . . . . . . . . . . . . . . . . . . . . . . . . . 93                                 8.5    Reading documentation . . . . . . . . . . . . . . . . . . . . . 95                                 8.6    The indexOf method . . . . . . . . . . . . . . . . . . . . . . 95                                8.7    Looping and counting . . . . . . . . . . . . . . . . . . . . . . 96                                 8.8    Increment and decrement operators . . . . . . . . . . . . . . 97                                 8.9    Strings are immutable . . . . . . . . . . . . . . . . . . . . . 98                                 8.10   Strings are incomparable . . . . . . . . . . . . . . . . . . . 98                                 8.11   Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99                                8.12   Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100","Contents                                                                  xiii                      9 Mutable objects                                                        107                        9.1    Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107                        9.2    Point objects . . . . . . . . . . . . . . . . . . . . . . . . . . 108                       9.3    Instance variables . . . . . . . . . . . . . . . . . . . . . . . . 109                        9.4    Objects as parameters . . . . . . . . . . . . . . . . . . . . . 110                        9.5    Rectangles . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110                        9.6    Objects as return types . . . . . . . . . . . . . . . . . . . . . 111                        9.7    Objects are mutable . . . . . . . . . . . . . . . . . . . . . . . 111                        9.8    Aliasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112                        9.9    null . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114                        9.10   Garbage collection    . . . . . . . . . . . . . . . . . . . . . . . 114                        9.11   Objects and primitives . . . . . . . . . . . . . . . . . . . . . 115                       9.12   Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116                        9.13   Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117                       10 GridWorld: Part 2                                                     123                        10.1   Termites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125                        10.2   Langton’s Termite . . . . . . . . . . . . . . . . . . . . . . . . 128                       10.3   Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129                       11 Create your own objects                                               131                        11.1   Class deﬁnitions and object types . . . . . . . . . . . . . . . 131                        11.2   Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132                        11.3   Constructors . . . . . . . . . . . . . . . . . . . . . . . . . . . 133                       11.4   More constructors . . . . . . . . . . . . . . . . . . . . . . . . 134","xiv                                                                Contents                                  11.5   Creating a new object    . . . . . . . . . . . . . . . . . . . . . 135                                11.6   Printing objects . . . . . . . . . . . . . . . . . . . . . . . . . 136                                 11.7   Operations on objects . . . . . . . . . . . . . . . . . . . . . . 137                                 11.8   Pure functions . . . . . . . . . . . . . . . . . . . . . . . . . . 137                                 11.9   Modiﬁers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140                                 11.10 Fill-in methods . . . . . . . . . . . . . . . . . . . . . . . . . 141                                 11.11 Incremental development and planning . . . . . . . . . . . . 142                                 11.12 Generalization . . . . . . . . . . . . . . . . . . . . . . . . . . 143                                11.13 Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144                                 11.14 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144                                 11.15 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145                               12 Arrays                                                                149                                 12.1   Accessing elements . . . . . . . . . . . . . . . . . . . . . . . 150                                 12.2   Copying arrays . . . . . . . . . . . . . . . . . . . . . . . . . 151                                 12.3   Arrays and objects . . . . . . . . . . . . . . . . . . . . . . . 151                                 12.4   for loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152                                 12.5   Array length . . . . . . . . . . . . . . . . . . . . . . . . . . . 153                                 12.6   Random numbers . . . . . . . . . . . . . . . . . . . . . . . . 153                                12.7   Array of random numbers . . . . . . . . . . . . . . . . . . . 154                                 12.8   Counting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155                                 12.9   The histogram . . . . . . . . . . . . . . . . . . . . . . . . . . 157                                 12.10 A single-pass solution . . . . . . . . . . . . . . . . . . . . . . 157                                 12.11 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158                                12.12 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158","Contents                                                                   xv                      13 Arrays of Objects                                                     165                        13.1   The Road Ahead . . . . . . . . . . . . . . . . . . . . . . . . 165                        13.2   Card objects . . . . . . . . . . . . . . . . . . . . . . . . . . . 165                        13.3   The printCard method . . . . . . . . . . . . . . . . . . . . . 167                        13.4   The sameCard method . . . . . . . . . . . . . . . . . . . . . 169                        13.5   The compareCard method . . . . . . . . . . . . . . . . . . . 170                        13.6   Arrays of cards . . . . . . . . . . . . . . . . . . . . . . . . . 171                        13.7   The printDeck method . . . . . . . . . . . . . . . . . . . . . 173                        13.8   Searching    . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173                         13.9   Decks and subdecks . . . . . . . . . . . . . . . . . . . . . . . 177                        13.10 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178                        13.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178                      14 Objects of Arrays                                                     181                         14.1   The Deck class . . . . . . . . . . . . . . . . . . . . . . . . . . 181                        14.2   Shuﬄing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183                        14.3   Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184                        14.4   Subdecks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184                        14.5   Shuﬄing and dealing . . . . . . . . . . . . . . . . . . . . . . 185                        14.6   Mergesort . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186                        14.7   Class variables . . . . . . . . . . . . . . . . . . . . . . . . . . 189                        14.8   Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189                        14.9   Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190","xvi                                                                Contents                               15 Object-oriented programming                                           193                                 15.1   Programming languages and styles . . . . . . . . . . . . . . . 193                                 15.2   Object methods and class methods . . . . . . . . . . . . . . 194                                  15.3   The toString method . . . . . . . . . . . . . . . . . . . . . 195                                 15.4   The equals method . . . . . . . . . . . . . . . . . . . . . . . 196                                 15.5   Oddities and errors . . . . . . . . . . . . . . . . . . . . . . . 197                                 15.6   Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197                                 15.7   The class hierarchy . . . . . . . . . . . . . . . . . . . . . . . 198                                  15.8   Object-oriented design . . . . . . . . . . . . . . . . . . . . . 199                                 15.9   Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199                                 15.10 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200                                16 GridWorld: Part 3                                                     203                                 16.1   ArrayList . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203                                  16.2   Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205                                 16.3   public and private . . . . . . . . . . . . . . . . . . . . . . 206                                 16.4   Game of Life . . . . . . . . . . . . . . . . . . . . . . . . . . . 206                                  16.5   LifeRunner . . . . . . . . . . . . . . . . . . . . . . . . . . . 207                                 16.6   LifeRock . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208                                 16.7   Simultaneous updates . . . . . . . . . . . . . . . . . . . . . . 208                                 16.8   Initial conditions . . . . . . . . . . . . . . . . . . . . . . . . 210                                 16.9   Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211","Contents                                                                 xvii                      A Graphics                                                               213                        A.1    Java 2D Graphics . . . . . . . . . . . . . . . . . . . . . . . . 213                        A.2    Graphics methods . . . . . . . . . . . . . . . . . . . . . . . 214                       A.3    Coordinates . . . . . . . . . . . . . . . . . . . . . . . . . . . 215                        A.4    Color . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216                        A.5    Mickey Mouse . . . . . . . . . . . . . . . . . . . . . . . . . . 216                        A.6    Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217                        A.7    Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218                      B Input and Output in Java                                               221                        B.1    System objects . . . . . . . . . . . . . . . . . . . . . . . . . 221                        B.2    Keyboard input . . . . . . . . . . . . . . . . . . . . . . . . . 221                        B.3    File input . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222                        B.4    Catching exceptions . . . . . . . . . . . . . . . . . . . . . . . 223                      C Program development                                                    225                        C.1    Strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225                        C.2    Failure modes . . . . . . . . . . . . . . . . . . . . . . . . . . 226                       D Debugging                                                              229                        D.1    Syntax errors . . . . . . . . . . . . . . . . . . . . . . . . . . 229                       D.2    Run-time errors . . . . . . . . . . . . . . . . . . . . . . . . . 233                        D.3    Logic errors . . . . . . . . . . . . . . . . . . . . . . . . . . . 237","xviii                                                              Contents","Chapter 1                          The way of the program                          The goal of this book is to teach you to think like a computer scientist. I                    like the way computer scientists think because they combine some of the best                    features of Mathematics, Engineering, and Natural Science. Like mathemati-                    cians, computer scientists use formal languages to denote ideas (speciﬁcally                    computations). Like engineers, they design things, assembling components                    into systems and evaluating tradeoﬀs among alternatives. Like scientists,                    they observe the behavior of complex systems, form hypotheses, and test                    predictions.                     The single most important skill for a computer scientist is problem-solving.                    By that I mean the ability to formulate problems, think creatively about                    solutions, and express a solution clearly and accurately. As it turns out,                    the process of learning to program is an excellent opportunity to practice                    problem-solving skills. That’s why this chapter is called “The way of the                    program.”                    On one level, you will be learning to program, which is a useful skill by itself.                    On another level you will use programming as a means to an end. As we go                    along, that end will become clearer.                       1.1      What is a programming language?                      The programming language you will be learning is Java, which is relatively                    new (Sun released the ﬁrst version in May, 1995). Java is an example of a","2                                 Chapter 1. The way of the program                               high-level language; other high-level languages you might have heard of                             are Python, C or C++, and Perl.                              As you might infer from the name “high-level language,” there are also low-                             level languages, sometimes called machine language or assembly language.                             Loosely-speaking, computers can only run programs written in low-level lan-                             guages. Thus, programs written in a high-level language have to be trans-                             lated before they can run. This translation takes time, which is a small                             disadvantage of high-level languages.                               The advantages are enormous. First, it is much easier to program in a high-                             level language: the program takes less time to write, it’s shorter and easier                             to read, and it’s more likely to be correct. Second, high-level languages are                             portable, meaning that they can run on diﬀerent kinds of computers with                             few or no modiﬁcations. Low-level programs can only run on one kind of                             computer, and have to be rewritten to run on another.                              Due to these advantages, almost all programs are written in high-level lan-                             guages. Low-level languages are only used for a few special applications.                               There are two ways to translate a program; interpreting and compiling.                             An interpreter is a program that reads a high-level program and does what                             it says. In eﬀect, it translates the program line-by-line, alternately reading                             lines and carrying out commands.                               A compiler is a program that reads a high-level program and translates it                             all at once, before running any of the commands. Often you compile the                             program as a separate step, and then run the compiled code later. In this                             case, the high-level program is called the source code, and the translated                             program is called the object code or the executable.                               Java is both compiled and interpreted. Instead of translating programs into                             machine language, the Java compiler generates byte code. Byte code is                             easy (and fast) to interpret, like machine language, but it is also portable,                             like a high-level language. Thus, it is possible to compile a program on one                             machine, transfer the byte code to another machine, and then interpret the                             byte code on the other machine. This ability is an advantage of Java over                             many other high-level languages.","1.2. What is a program?                                                     3                         source                        byte                      code                          code                                    compiler                      interpreter                       x.java                        x.class                     The compiler                              A Java interpreter       ... and the result                                        ... and generates                    reads the                                 reads the byte           appears on                                        Java byte code.                    source code...                            code...                  the screen.                     Although this process may seem complicated, in most program development                    environments these steps are automated for you. Usually you will only have                    to write a program and press a button or type a single command to compile                    and run it. On the other hand, it is useful to know what steps are happening                    in the background, so if something goes wrong you can ﬁgure out what it is.                       1.2      What is a program?                      A program is a sequence of instructions that speciﬁes how to perform a com-                             1                    putation . The computation might be something mathematical, like solving                    a system of equations or ﬁnding the roots of a polynomial, but it can also be                    a symbolic computation, like searching and replacing text in a document or                    (strangely enough) compiling a program.                    The instructions, which we will call statements, look diﬀerent in diﬀerent                    programming languages, but there are a few basic operations most languages                    perform:                      input: Get data from the keyboard, or a ﬁle, or some other device.                     output: Display data on the screen or send data to a ﬁle or other device.                     math: Perform basic mathematical operations like addition and multiplica-                          tion.                     testing: Check for certain conditions and run the appropriate sequence of                          statements.                       1                       This deﬁnition does not apply to all programming languages; for alternatives, see                    http://en.wikipedia.org/wiki/Declarative_programming.","4                                 Chapter 1. The way of the program                               repetition: Perform some action repeatedly, usually with some variation.                              That’s pretty much all there is to it. Every program you’ve ever used, no                             matter how complicated, is made up of statements that perform these oper-                             ations. Thus, one way to describe programming is the process of breaking a                             large, complex task up into smaller and smaller subtasks until the subtasks                             are simple enough to be performed with one of these basic operations.                                 1.3      What is debugging?                               For whimsical reasons, programming errors are called bugs and the process                             of tracking them down and correcting them is called debugging.                              There are a three kinds of errors that can occur in a program, and it is useful                             to distinguish them to track them down more quickly.                                 1.3.1     Syntax errors                              The compiler can only translate a program if the program is syntactically                             correct; otherwise, the compilation fails and you will not be able to run your                             program. Syntax refers to the structure of your program and the rules about                             that structure.                              For example, in English, a sentence must begin with a capital letter and end                             with a period. this sentence contains a syntax error. So does this one                              For most readers, a few syntax errors are not a signiﬁcant problem, which is                             why we can read the poetry of e e cummings without spewing error messages.                              Compilers are not so forgiving. If there is a single syntax error anywhere in                             your program, the compiler will print an error message and quit, and you                             will not be able to run your program.                              To make matters worse, there are more syntax rules in Java than there are in                             English, and the error messages you get from the compiler are often not very                             helpful. During the ﬁrst weeks of your programming career, you will probably                             spend a lot of time tracking down syntax errors. As you gain experience, you                             will make fewer errors and ﬁnd them faster.","1.3. What is debugging?                                                     5                      1.3.2     Run-time errors                     The second type of error is a run-time error, so-called because the error does                    not appear until you run the program. In Java, run-time errors occur when                    the interpreter is running the byte code and something goes wrong.                     Java tends to be a safe language, which means that the compiler catches a                    lot of errors. So run-time errors are rare, especially for simple programs.                     In Java, run-time errors are called exceptions, and in most environments                    they appear as windows or dialog boxes that contain information about what                    happened and what the program was doing when it happened. This infor-                    mation is useful for debugging.                       1.3.3     Logic errors and semantics                      The third type of error is the logic or semantic error. If there is a logic error                    in your program, it will compile and run without generating error messages,                    but it will not do the right thing. It will do something else. Speciﬁcally, it                    will do what you told it to do.                     The problem is that the program you wrote is not the program you wanted                    to write. The semantics, or meaning of the program, are wrong. Identifying                    logic errors can be tricky because you have to work backwards, looking at                    the output of the program and trying to ﬁgure out what it is doing.                       1.3.4     Experimental debugging                     One of the most important skills you will acquire in this class is debugging.                    Although debugging can be frustrating, it is one of the most interesting,                    challenging, and valuable parts of programming.                    Debugging is like detective work. You are confronted with clues and you                    have to infer the processes and events that lead to the results you see.                     Debugging is also like an experimental science. Once you have an idea what                    is going wrong, you modify your program and try again. If your hypothesis                    was correct, then you can predict the result of the modiﬁcation, and you                    take a step closer to a working program. If your hypothesis was wrong, you","6                                 Chapter 1. The way of the program                               have to come up with a new one. As Sherlock Holmes pointed out, “When                             you have eliminated the impossible, whatever remains, however improbable,                             must be the truth.” (From A. Conan Doyle’s The Sign of Four.)                              For some people, programming and debugging are the same thing. That is,                             programming is the process of gradually debugging a program until it does                             what you want. The idea is that you should always start with a working                             program that does something, and make small modiﬁcations, debugging them                             as you go, so that you always have a working program.                             For example, Linux is an operating system that contains thousands of lines                             of code, but it started out as a simple program Linus Torvalds used to ex-                             plore the Intel 80386 chip. According to Larry Greenﬁeld, “One of Linus’s                             earlier projects was a program that would switch between printing AAAA                             and BBBB. This later evolved to Linux” (from The Linux Users’ Guide Beta                             Version 1).                              In later chapters I make more suggestions about debugging and other pro-                             gramming practices.                                 1.4      Formal and natural languages                               Natural languages are the languages that people speak, like English, Span-                             ish, and French. They were not designed by people (although people try to                             impose order on them); they evolved naturally.                             Formal languages are languages designed by people for speciﬁc applica-                             tions. For example, the notation that mathematicians use is a formal lan-                             guage that is particularly good at denoting relationships among numbers and                             symbols. Chemists use a formal language to represent the chemical structure                             of molecules. And most importantly:                                    Programming languages are formal languages that have                                   been designed to express computations.                               Formal languages have strict rules about syntax. For example, 3 + 3 = 6 is                             a syntactically correct mathematical statement, but 3$ = is not. Also, H 2 O                             is a syntactically correct chemical name, but 2 Zz is not.","1.4. Formal and natural languages                                           7                      Syntax rules come in two ﬂavors, pertaining to tokens and structure. Tokens                    are the basic elements of the language, like words and numbers and chemical                    elements. One of the problems with 3$ = is that $ is not a legal token in                    mathematics (at least as far as I know). Similarly, 2 Zz is not legal because                    there is no element with the abbreviation Zz.                     The second type of syntax rule pertains to the structure of a statement; that                    is, the way the tokens are arranged. The statement 3$ = is structurally                    illegal, because you can’t have an equals sign at the end of an equation.                    Similarly, molecular formulas have to have subscripts after the element name,                    not before.                     When you read a sentence in English or a statement in a formal language,                    you have to ﬁgure out what the structure of the sentence is (although in a                    natural language you do this unconsciously). This process is called parsing.                     Although formal and natural languages have features in common—tokens,                    structure, syntax and semantics—there are diﬀerences.                     ambiguity: Natural languages are full of ambiguity, which people deal with                          by using contextual clues and other information. Formal languages                          are designed to be unambiguous, which means that any statement has                          exactly one meaning, regardless of context.                     redundancy: To make up for ambiguity and reduce misunderstandings, nat-                          ural languages are often redundant. Formal languages are more concise.                     literalness: Natural languages are full of idiom and metaphor. Formal lan-                          guages mean exactly what they say.                     People who grow up speaking a natural language (everyone) often have a                    hard time adjusting to formal languages. In some ways the diﬀerence between                    formal and natural language is like the diﬀerence between poetry and prose,                    but more so:                     Poetry: Words are used for their sounds as well as for their meaning, and                          the whole poem together creates an eﬀect or emotional response. Am-                          biguity is common and deliberate.                     Prose: The literal meaning of words is more important and the structure                          contributes more meaning.","8                                 Chapter 1. The way of the program                               Programs: The meaning of a computer program is unambiguous and literal,                                   and can be understood entirely by analysis of the tokens and structure.                               Here are some suggestions for reading programs (and other formal languages).                             First, remember that formal languages are much more dense than natural                             languages, so it takes longer to read them. Also, the structure is important,                             so it is usually not a good idea to read from top to bottom, left to right.                             Instead, learn to parse the program in your head, identifying the tokens and                             interpreting the structure. Finally, remember that the details matter. Little                             things like spelling errors and bad punctuation, which you can get away with                             in natural languages, can make a big diﬀerence in a formal language.                                 1.5      The ﬁrst program                                Traditionally the ﬁrst program people write in a new language is called “hello                             world” because all it does is display the words “Hello, World.” In Java, this                             program looks like:                              class Hello {                                // main: generate some simple output                                 public static void main(String[] args) {                                  System.out.println(\"Hello, world.\");                               }                             }                             This program includes features that are hard to explain to beginners, but it                             provides a preview of topics we will see in detail later.                              Java programs are made up of class deﬁnitions, which have the form:                             class CLASSNAME {                                 public static void main (String[] args) {                                  STATEMENTS                               }                             }","1.6. Glossary                                                               9                      Here CLASSNAME indicates a name chosen by the programmer. The class                    name in the example is Hello.                    main is a method, which is a named collection of statements. The name                    main is special; it marks the place in the program where execution begins.                    When the program runs, it starts at the ﬁrst statement in main and ends                    when it ﬁnishes the last statement.                    main can have any number of statements, but the example has one. It is a                    print statement, meaning that it displays a message on the screen. Confus-                    ingly, “print” can mean “display something on the screen,” or “send some-                    thing to the printer.” In this book I won’t say much about sending things                    to the printer; we’ll do all our printing on the screen. The print statement                    ends with a semi-colon (;).                     System.out.println is a method provided by one of Java’s libraries. A                    library is a collection of class and method deﬁnitions.                    Java uses squiggly-braces ({ and }) to group things together. The outermost                    squiggly-braces (lines 1 and 8) contain the class deﬁnition, and the inner                    braces contain the deﬁnition of main.                     Line 3 begins with //. That means it’s a comment, which is a bit of English                    text that you can put a program, usually to explain what it does. When the                    compiler sees //, it ignores everything from there until the end of the line.                        1.6      Glossary                     problem-solving: The process of formulating a problem, ﬁnding a solution,                          and expressing the solution.                     high-level language: A programming language like Java that is designed                          to be easy for humans to read and write.                    low-level language: A programming language that is designed to be easy                          for a computer to run. Also called “machine language” or “assembly                          language.”                     formal language: Any of the languages people have designed for speciﬁc                          purposes, like representing mathematical ideas or computer programs.                          All programming languages are formal languages.","10                                Chapter 1. The way of the program                               natural language: Any of the languages people speak that have evolved                                   naturally.                             portability: A property of a program that can run on more than one kind                                   of computer.                              interpret: To run a program in a high-level language by translating it one                                   line at a time.                              compile: To translate a program in a high-level language into a low-level                                   language, all at once, in preparation for later execution.                              source code: A program in a high-level language, before being compiled.                              object code: The output of the compiler, after translating the program.                              executable: Another name for object code that is ready to run.                              byte code: A special kind of object code used for Java programs. Byte code                                   is similar to a low-level language, but it is portable, like a high-level                                   language.                              statement: A part of a program that speciﬁes a computation.                              print statement: A statement that causes output to be displayed on the                                   screen.                              comment: A part of a program that contains information about the pro-                                   gram, but that has no eﬀect when the program runs.                              method: A named collection of statements.                              library: A collection of class and method deﬁnitions.                              bug: An error in a program.                              syntax: The structure of a program.                              semantics: The meaning of a program.                              parse: To examine a program and analyze the syntactic structure.                              syntax error: An error in a program that makes it impossible to parse (and                                   therefore impossible to compile).","1.7. Exercises                                                             11                      exception: An error in a program that makes it fail at run-time. Also called                          a run-time error.                    logic error: An error in a program that makes it do something other than                          what the programmer intended.                     debugging: The process of ﬁnding and removing any of the three kinds of                          errors.                        1.7      Exercises                      Exercise 1.1. Computer scientists have the annoying habit of using common                    English words to mean something other than their common English meaning.                    For example, in English, statements and comments are the same thing, but                    in programs they are diﬀerent.                     The glossary at the end of each chapter is intended to highlight words and                    phrases that have special meanings in computer science. When you see fa-                    miliar words, don’t assume that you know what they mean!                        1. In computer jargon, what’s the diﬀerence between a statement and a                          comment?                        2. What does it mean to say that a program is portable?                        3. What is an executable?                      Exercise 1.2. Before you do anything else, ﬁnd out how to compile and run                    a Java program in your environment. Some environments provide sample                    programs similar to the example in Section 1.5.                         1. Type in the “Hello, world” program, then compile and run it.                        2. Add a print statement that prints a second message after the “Hello,                          world!”. Something witty like, “How are you?” Compile and run the                          program again.                        3. Add a comment to the program (anywhere), recompile, and run it                          again. The new comment should not aﬀect the result.","12                                Chapter 1. The way of the program                               This exercise may seem trivial, but it is the starting place for many of the                             programs we will work with. To debug with conﬁdence, you have to have                             conﬁdence in your programming environment. In some environments, it is                             easy to lose track of which program is executing, and you might ﬁnd yourself                             trying to debug one program while you are accidentally running another.                             Adding (and changing) print statements is a simple way to be sure that the                             program you are looking at is the program you are running.                              Exercise 1.3. It is a good idea to commit as many errors as you can think                             of, so that you see what error messages the compiler produces. Sometimes                             the compiler tells you exactly what is wrong, and all you have to do is ﬁx it.                             But sometimes the error messages are misleading. You will develop a sense                             for when you can trust the compiler and when you have to ﬁgure things out                             yourself.                                  1. Remove one of the open squiggly-braces.                                 2. Remove one of the close squiggly-braces.                                 3. Instead of main, write mian.                                 4. Remove the word static.                                 5. Remove the word public.                                 6. Remove the word System.                                 7. Replace println with Println.                                 8. Replace println with print. This one is tricky because it is a logic                                   error, not a syntax error. The statement System.out.print is legal,                                   but it may or may not do what you expect.                                 9. Delete one of the parentheses. Add an extra one.","Chapter 2                         Variables and types                            2.1      More printing                     You can put as many statements as you want in main; for example, to print                    more than one line:                     class Hello {                       // Generates some simple output.                        public static void main(String[] args) {                         System.out.println(\"Hello, world.\");              // print one line                         System.out.println(\"How are you?\");               // print another                      }                    }                     As this example demonstrates, you can put comments at the end of a line,                    as well as on a line by themselves.                    The phrases that appear in quotation marks are called strings, because                    they are made up of a sequence (string) of characters. Strings can contain                    any combination of letters, numbers, punctuation marks, and other special                    characters.                     println is short for “print line,” because after each line it adds a special                    character, called a newline, that moves the cursor to the next line of the","14                                      Chapter 2. Variables and types                               display. The next time println is invoked, the new text appears on the next                             line.                              To display the output from multiple print statements all on one line, use                             print:                             class Hello {                                 // Generates some simple output.                                 public static void main(String[] args) {                                  System.out.print(\"Goodbye, \");                                  System.out.println(\"cruel world!\");                               }                             }                              The output appears on a single line as Goodbye, cruel world!. There is                             a space between the word “Goodbye” and the second quotation mark. This                             space appears in the output, so it aﬀects the behavior of the program.                               Spaces that appear outside of quotation marks generally do not aﬀect the                             behavior of the program. For example, I could have written:                             class Hello {                             public static void main(String[] args) {                             System.out.print(\"Goodbye, \");                             System.out.println(\"cruel world!\");                             }                             }                              This program would compile and run just as well as the original. The breaks                             at the ends of lines (newlines) do not aﬀect the program’s behavior either,                             so I could have written:                             class Hello { public static void main(String[] args) {                             System.out.print(\"Goodbye, \"); System.out.println                             (\"cruel world!\");}}                              That would work, too, but the program is getting harder and harder to read.                             Newlines and spaces are useful for organizing your program visually, making                             it easier to read the program and locate errors.","2.2. Variables                                                             15                     2.2      Variables                      One of the most powerful features of a programming language is the ability                    to manipulate variables. A variable is a named location that stores a value.                    Values are things that can be printed, stored and (as we’ll see later) operated                    on. The strings we have been printing (\"Hello, World.\", \"Goodbye, \",                    etc.) are values.                      To store a value, you have to create a variable. Since the values we want to                    store are strings, we declare that the new variable is a string:                          String bob;                    This statement is a declaration, because it declares that the variable named                    bob has the type String. Each variable has a type that determines what                    kind of values it can store. For example, the int type can store integers, and                    the String type can store strings.                     Some types begin with a capital letter and some with lower-case. We will                    learn the signiﬁcance of this distinction later, but for now you should take                    care to get it right. There is no such type as Int or string, and the compiler                    will object if you try to make one up.                     To create an integer variable, the syntax is int bob;, where bob is the arbi-                    trary name you made up for the variable. In general, you will want to make                    up variable names that indicate what you plan to do with the variable. For                    example, if you saw these variable declarations:                          String firstName;                         String lastName;                         int hour, minute;                    you could guess what values would be stored in them. This example also                    demonstrates the syntax for declaring multiple variables with the same type:                    hour and second are both integers (int type).                        2.3      Assignment                      Now that we have created variables, we want to store values. We do that                    with an assignment statement.","16                                      Chapter 2. Variables and types                                    bob = \"Hello.\";           // give bob the value \"Hello.\"                                  hour = 11;                // assign the value 11 to hour                                  minute = 59;              // set minute to 59                             This example shows three assignments, and the comments show three diﬀer-                             ent ways people sometimes talk about assignment statements. The vocabu-                             lary can be confusing here, but the idea is straightforward:                                   When you declare a variable, you create a named storage location.                                  When you make an assignment to a variable, you give it a value.                               A common way to represent variables on paper is to draw a box with the                             name of the variable on the outside and the value of the variable on the                             inside. This ﬁgure shows the eﬀect of the three assignment statements:                                  bob  \"Hello.\"                                 hour  11                               minute  59                              As a general rule, a variable has to have the same type as the value you                             assign it. You cannot store a String in minute or an integer in bob.                              On the other hand, that rule can be confusing, because there are many ways                             that you can convert values from one type to another, and Java sometimes                             converts things automatically. For now you should remember the general                             rule, and we’ll talk about exceptions later.                               Another source of confusion is that some strings look like integers, but they                             are not. For example, bob can contain the string \"123\", which is made up of                             the characters 1, 2 and 3, but that is not the same thing as the number 123.                                   bob = \"123\";         // legal                                  bob = 123;           // not legal                                 2.4      Printing variables                              You can print the value of a variable using println or print:","2.4. Printing variables                                                    17                      class Hello {                      public static void main(String[] args) {                         String firstLine;                         firstLine = \"Hello, again!\";                         System.out.println(firstLine);                      }                    }                    This program creates a variable named firstLine, assigns it the value                    \"Hello, again!\" and then prints that value. When we talk about “print-                    ing a variable,” we mean printing the value of the variable.        To print                    the name of a variable, you have to put it in quotes.           For example:                    System.out.println(\"firstLine\");                     For example, you can write                          String firstLine;                         firstLine = \"Hello, again!\";                         System.out.print(\"The value of firstLine is \");                         System.out.println(firstLine);                     The output of this program is                    The value of firstLine is Hello, again!                     I am happy to report that the syntax for printing a variable is the same                    regardless of the variable’s type.                          int hour, minute;                         hour = 11;                         minute = 59;                         System.out.print(\"The current time is \");                         System.out.print(hour);                         System.out.print(\":\");                         System.out.print(minute);                         System.out.println(\".\");                    The output of this program is The current time is 11:59.                     WARNING: To put multiple values on the same line, is common to use                    several print statements followed by a println. But you have to remember                    the println at the end. In many environments, the output from print                    is stored without being displayed until println is invoked, at which point","18                                      Chapter 2. Variables and types                               the entire line is displayed at once. If you omit println, the program may                             terminate without displaying the stored output!                                2.5      Keywords                               A few sections ago, I said that you can make up any name you want for your                             variables, but that’s not quite true. There are certain words that are reserved                             in Java because they are used by the compiler to parse the structure of your                             program, and if you use them as variable names, it will get confused. These                             words, called keywords, include public, class, void, int, and many more.                              The complete list is available at http://download.oracle.com/javase/                             tutorial/java/nutsandbolts/_keywords.html.           This site, provided by                             Oracle, includes Java documentation I refer to throughout the book.                              Rather than memorize the list, I suggest you take advantage of a feature                             provided in many Java development environments: code highlighting. As you                             type, parts of your program should appear in diﬀerent colors. For example,                             keywords might be blue, strings red, and other code black. If you type a                             variable name and it turns blue, watch out! You might get some strange                             behavior from the compiler.                                 2.6      Operators                               Operators are symbols used to represent computations like addition and                             multiplication. Most operators in Java do what you expect them to do be-                             cause they are common mathematical symbols. For example, the operator                             for addition is +. Subtraction is -, multiplication is *, and division is /.                              1+1          hour-1          hour*60 + minute          minute/60                             Expressions can contain both variable names and numbers. Variables are                             replaced with their values before the computation is performed.                             Addition, subtraction and multiplication all do what you expect, but you                             might be surprised by division. For example, this program:                                   int hour, minute;                                  hour = 11;","2.7. Order of operations                                                   19                           minute = 59;                         System.out.print(\"Number of minutes since midnight: \");                         System.out.println(hour*60 + minute);                         System.out.print(\"Fraction of the hour that has passed: \");                         System.out.println(minute/60);                     generates this output:                    Number of minutes since midnight: 719                    Fraction of the hour that has passed: 0                    The ﬁrst line is expected, but the second line is odd. The value of minute                    is 59, and 59 divided by 60 is 0.98333, not 0. The problem is that Java is                    performing integer division.                     When both operands are integers (operands are the things operators operate                    on), the result is also an integer, and by convention integer division always                    rounds down, even in cases like this where the next integer is so close.                     An alternative is to calculate a percentage rather than a fraction:                          System.out.print(\"Percentage of the hour that has passed: \");                         System.out.println(minute*100/60);                    The result is:                    Percentage of the hour that has passed: 98                     Again the result is rounded down, but at least now the answer is approxi-                    mately correct. To get a more accurate answer, we can use a diﬀerent type                    of variable, called ﬂoating-point, that can store fractional values. We’ll get                    to that in the next chapter.                        2.7      Order of operations                      When more than one operator appears in an expression, the order of eval-                    uation depends on the rules of precedence. A complete explanation of                    precedence can get complicated, but just to get you started:                          Multiplication and division happen before addition and subtraction.                          So 2*3-1 yields 5, not 4, and 2/3-1 yields -1, not 1 (remember that in                          integer division 2/3 is 0).","20                                      Chapter 2. Variables and types                                   If the operators have the same precedence they are evaluated from left                                   to right. So in the expression minute*100/60, the multiplication hap-                                   pens ﬁrst, yielding 5900/60, which in turn yields 98. If the operations                                   had gone from right to left, the result would be 59*1 which is 59, which                                   is wrong.                                  Any time you want to override the rules of precedence (or you are not                                   sure what they are) you can use parentheses. Expressions in parenthe-                                   ses are evaluated ﬁrst, so 2 *(3-1) is 4. You can also use parentheses                                   to make an expression easier to read, as in (minute * 100) / 60, even                                   though it doesn’t change the result.                                2.8      Operators for Strings                               In general you cannot perform mathematical operations on Strings, even if                             the strings look like numbers. The following are illegal (if we know that bob                             has type String)                             bob - 1            \"Hello\"/123          bob * \"Hello\"                             By the way, can you tell by looking at those expressions whether bob is an                             integer or a string? Nope. The only way to tell the type of a variable is to                             look at the place where it is declared.                             Interestingly, the + operator does work with Strings, but it might not                             do what you expect. For Strings, the + operator represents concatena-                             tion, which means joining up the two operands by linking them end-to-end.                             So \"Hello, \" + \"world.\" yields the string \"Hello, world.\" and bob +                             \"ism\" adds the suﬃx ism to the end of whatever bob is, which is handy for                             naming new forms of bigotry.                                 2.9      Composition                              So far we have looked at the elements of a programming language—variables,                             expressions, and statements—in isolation, without talking about how to com-                             bine them.                              One of the most useful features of programming languages is their ability to                             take small building blocks and compose them. For example, we know how","2.10. Glossary                                                             21                      to multiply numbers and we know how to print; it turns out we can combine                    them in a single statement:                         System.out.println(17 * 3);                    Any expression involving numbers, strings and variables, can be used inside                    a print statement. We’ve already seen one example:                         System.out.println(hour*60 + minute);                     But you can also put arbitrary expressions on the right-hand side of an                    assignment statement:                         int percentage;                         percentage = (minute * 100) / 60;                    This ability may not seem impressive now, but we will see examples where                    composition expresses complex computations neatly and concisely.                     WARNING: The left side of an assignment has to be a variable name, not                    an expression. That’s because the left side indicates the storage location                    where the result will go. Expressions do not represent storage locations, only                    values. So the following is illegal: minute+1 = hour;.                        2.10       Glossary                     variable: A named storage location for values. All variables have a type,                          which is declared when the variable is created.                     value: A number or string (or other thing to be named later) that can be                          stored in a variable. Every value belongs to a type.                     type: A set of values. The type of a variable determines which values can                          be stored there. The types we have seen are integers (int in Java) and                          strings (String in Java).                     keyword: A reserved word used by the compiler to parse programs. You                          cannot use keywords, like public, class and void as variable names.                     declaration: A statement that creates a new variable and determines its                          type.                     assignment: A statement that assigns a value to a variable.","22                                      Chapter 2. Variables and types                               expression: A combination of variables, operators and values that repre-                                   sents a single value. Expressions also have types, as determined by                                   their operators and operands.                               operator: A symbol that represents a computation like addition, multipli-                                   cation or string concatenation.                               operand: One of the values on which an operator operates.                              precedence: The order in which operations are evaluated.                               concatenate: To join two operands end-to-end.                              composition: The ability to combine simple expressions and statements                                   into compound statements and expressions to represent complex com-                                   putations concisely.                                 2.11       Exercises                               Exercise 2.1. If you are using this book in a class, you might enjoy this                             exercise: ﬁnd a partner and play ”Stump the Chump”:                              Start with a program that compiles and runs correctly. One player turns                             away while the other player adds an error to the program. Then the ﬁrst                             player tries to ﬁnd and ﬁx the error. You get two points if you ﬁnd the error                             without compiling the program, one point if you ﬁnd it using the compiler,                             and your opponent gets a point if you don’t ﬁnd it.                              Exercise 2.2.     1. Create a new program named Date.java. Copy or type                                   in something like the “Hello, World” program and make sure you can                                   compile and run it.                                 2. Following the example in Section 2.4, write a program that creates                                   variables named day, date, month and year. day will contain the day                                   of the week and date will contain the day of the month. What type is                                   each variable? Assign values to those variables that represent today’s                                   date.","2.11. Exercises                                                            23                         3. Print the value of each variable on a line by itself. This is an inter-                          mediate step that is useful for checking that everything is working so                          far.                         4. Modify the program so that it prints the date in standard American                          form: Saturday, July 16, 2011.                         5. Modify the program again so that the total output is:                           American format:                          Saturday, July 16, 2011                          European format:                          Saturday 16 July, 2011                      The point of this exercise is to use string concatenation to display values                    with diﬀerent types (int and String), and to practice developing programs                    gradually by adding a few statements at a time.                      Exercise 2.3.     1. Create a new program called Time.java. From now on,                          I won’t remind you to start with a small, working program, but you                          should.                         2. Following the example in Section 2.6, create variables named hour,                          minute and second, and assign them values that are roughly the cur-                          rent time. Use a 24-hour clock, so that at 2pm the value of hour is                          14.                        3. Make the program calculate and print the number of seconds since                          midnight.                        4. Make the program calculate and print the number of seconds remaining                          in the day.                         5. Make the program calculate and print the percentage of the day that                          has passed.                        6. Change the values of hour, minute and second to reﬂect the current                          time (I assume that some time has elapsed), and check to make sure                          that the program works correctly with diﬀerent values.","24                                      Chapter 2. Variables and types                               The point of this exercise is to use some of the arithmetic operations, and                             to start thinking about compound entities like the time of day that that                             are represented with multiple values. Also, you might run into problems                             computing percentages with ints, which is the motivation for ﬂoating point                             numbers in the next chapter.                              HINT: you may want to use additional variables to hold values temporarily                             during the computation. Variables like this, that are used in a computation                             but never printed, are sometimes called intermediate or temporary variables.","Chapter 3                         Void methods                           3.1      Floating-point                      In the last chapter we had some problems dealing with numbers that were not                    integers. We worked around the problem by measuring percentages instead                    of fractions, but a more general solution is to use ﬂoating-point numbers,                    which can represent fractions as well as integers. In Java, the ﬂoating-point                    type is called double, which is short for “double-precision.”                     You can create ﬂoating-point variables and assign values to them using the                    same syntax we used for the other types. For example:                         double pi;                         pi = 3.14159;                    It is also legal to declare a variable and assign a value to it at the same time:                          int x = 1;                         String empty = \"\";                         double pi = 3.14159;                    This syntax is common; a combined declaration and assignment is sometimes                    called an initialization.                     Although ﬂoating-point numbers are useful, they are a source of confusion                    because there seems to be an overlap between integers and ﬂoating-point                    numbers. For example, if you have the value 1, is that an integer, a ﬂoating-                    point number, or both?","26                                            Chapter 3. Void methods                               Java distinguishes the integer value 1 from the ﬂoating-point value 1.0, even                             though they seem to be the same number. They belong to diﬀerent types, and                             strictly speaking, you are not allowed to make assignments between types.                             For example, the following is illegal:                                   int x = 1.1;                             because the variable on the left is an int and the value on the right is a                             double. But it is easy to forget this rule, especially because there are places                             where Java will automatically convert from one type to another. For example:                                  double y = 1;                             should technically not be legal, but Java allows it by converting the int to a                             double automatically. This leniency is convenient, but it can cause problems;                             for example:                                   double y = 1 / 3;                             You might expect the variable y to get the value 0.333333, which is a legal                             ﬂoating-point value, but in fact it gets 0.0. The reason is that the expression                             on the right is the ratio of two integers, so Java does integer division, which                             yields the integer value 0. Converted to ﬂoating-point, the result is 0.0.                               One way to solve this problem (once you ﬁgure out what it is) is to make the                             right-hand side a ﬂoating-point expression:                                   double y = 1.0 / 3.0;                             This sets y to 0.333333, as expected.                              The operations we have seen so far—addition, subtraction, multiplication,                             and division—also work on ﬂoating-point values, although you might be in-                             terested to know that the underlying mechanism is completely diﬀerent. In                             fact, most processors have special hardware just for performing ﬂoating-point                             operations.                                 3.2      Converting from double to int                               As I mentioned, Java converts ints to doubles automatically if necessary,                             because no information is lost in the translation. On the other hand, going                             from a double to an int requires rounding oﬀ. Java doesn’t perform this","3.3. Math methods                                                          27                      operation automatically, in order to make sure that you, as the programmer,                    are aware of the loss of the fractional part of the number.                    The simplest way to convert a ﬂoating-point value to an integer is to use a                    typecast. Typecasting is so called because it allows you to take a value that                    belongs to one type and “cast” it into another type (in the sense of molding                    or reforming).                    The syntax for typecasting is to put the name of the type in parentheses and                    use it as an operator. For example,                         double pi = 3.14159;                         int x = (int) pi;                    The (int) operator has the eﬀect of converting what follows into an integer,                    so x gets the value 3.                     Typecasting takes precedence over arithmetic operations, so in the following                    example, the value of pi gets converted to an integer ﬁrst, and the result is                    60.0, not 62.                          double pi = 3.14159;                         double x = (int) pi * 20.0;                    Converting to an integer always rounds down, even if the fraction part is                    0.99999999. These behaviors (precedence and rounding) can make typecast-                    ing error-prone.                       3.3      Math methods                      In mathematics, you have probably seen functions like sin and log, and you                    have learned to evaluate expressions like sin(π/2) and log(1/x). First, you                    evaluate the expression in parentheses, which is called the argument of the                    function. Then you can evaluate the function itself, either by looking it up                    in a table or by performing various computations.                     This process can be applied repeatedly to evaluate more complicated expres-                    sions like log(1/ sin(π/2)). First we evaluate the argument of the innermost                    function, then evaluate the function, and so on.                     Java provides functions that perform the most common mathematical opera-                    tions. These functions are called methods. The math methods are invoked                    using a syntax that is similar to the print statements we have already seen:","28                                            Chapter 3. Void methods                                     double root = Math.sqrt(17.0);                                   double angle = 1.5;                                   double height = Math.sin(angle);                             The ﬁrst example sets root to the square root of 17. The second example                             ﬁnds the sine of the value of angle, which is 1.5. Java assumes that the                             values you use with sin and the other trigonometric functions (cos, tan) are                             in radians. To convert from degrees to radians, you can divide by 360 and                             multiply by 2π. Conveniently, Java provides Math.PI:                                   double degrees = 90;                                   double angle = degrees * 2 * Math.PI / 360.0;                             Notice that PI is in all capital letters. Java does not recognize Pi, pi, or                             pie.                              Another useful method in the Math class is round, which rounds a ﬂoating-                             point value oﬀ to the nearest integer and returns an int.                                   int x = Math.round(Math.PI * 20.0);                             In this case the multiplication happens ﬁrst, before the method is invoked.                             The result is 63 (rounded up from 62.8319).                                3.4      Composition                              Just as with mathematical functions, Java methods can be composed, mean-                             ing that you use one expression as part of another. For example, you can use                             any expression as an argument to a method:                                  double x = Math.cos(angle + Math.PI/2);                             This statement takes the value Math.PI, divides it by two and adds the result                             to the value of the variable angle. The sum is then passed as an argument to                             cos. (PI is the name of a variable, not a method, so there are no arguments,                             not even the empty argument ()).                              You can also take the result of one method and pass it as an argument to                             another:                                   double x = Math.exp(Math.log(10.0));                             In Java, the log method always uses base e, so this statement ﬁnds the log                             base e of 10 and then raises e to that power. The result gets assigned to x;                             I hope you know what it is.","3.5. Adding new methods                                                    29                     3.5      Adding new methods                       So far we have used methods from Java libraries, but it is also possible to                    add new methods. We have already seen one method deﬁnition: main. The                    method named main is special, but the syntax is the same for other methods:                       public static void NAME( LIST OF PARAMETERS ) {                         STATEMENTS                      }                     You can make up any name you want for your method, except that you                    can’t call it main or any Java keyword. By convention, Java methods start                    with a lower case letter and use “camel caps,” which is a cute name for                    jammingWordsTogetherLikeThis.                     The list of parameters speciﬁes what information, if any, you have to provide                    to use (or invoke) the new method.                      The parameter for main is String[] args, which means that whoever in-                    vokes main has to provide an array of Strings (we’ll get to arrays in Chap-                    ter 12). The ﬁrst couple of methods we are going to write have no parameters,                    so the syntax looks like this:                      public static void newLine() {                         System.out.println(\"\");                      }                     This method is named newLine, and the empty parentheses mean that it                    takes no parameters. It contains one statement, which prints an empty                    String, indicated by \"\". Printing a String with no letters in it may not                    seem all that useful, but println skips to the next line after it prints, so this                    statement skips to the next line.                     In main we invoke this new method the same way we invoke Java methods:                      public static void main(String[] args) {                         System.out.println(\"First line.\");                         newLine();                         System.out.println(\"Second line.\");                      }                    The output of this program is","30                                            Chapter 3. Void methods                              First line.                               Second line.                             Notice the extra space between the lines. What if we wanted more space                             between the lines? We could invoke the same method repeatedly:                               public static void main(String[] args) {                                  System.out.println(\"First line.\");                                  newLine();                                  newLine();                                  newLine();                                  System.out.println(\"Second line.\");                               }                              Or we could write a new method, named threeLine, that prints three new                             lines:                                public static void threeLine() {                                  newLine();    newLine();     newLine();                               }                                public static void main(String[] args) {                                  System.out.println(\"First line.\");                                  threeLine();                                  System.out.println(\"Second line.\");                               }                             You should notice a few things about this program:                                   You can invoke the same procedure more than once.                                  You can have one method invoke another method. In this case, main                                   invokes threeLine and threeLine invokes newLine.                                   In threeLine I wrote three statements all on the same line, which is                                   syntactically legal (remember that spaces and new lines usually don’t                                   change the meaning of a program). It is usually a good idea to put                                   each statement on its own line, but I sometimes break that rule.                               You might wonder why it is worth the trouble to create all these new methods.                             There are several reasons; this example demonstrates two:","3.6. Classes and methods                                                   31                         1. Creating a new method gives you an opportunity to give a name to                          a group of statements. Methods can simplify a program by hiding                          a complex computation behind a single statement, and by using En-                          glish words in place of arcane code. Which is clearer, newLine or                          System.out.println(\"\")?                        2. Creating a new method can make a program smaller by eliminating                          repetitive code. For example, to print nine consecutive new lines, you                          could invoke threeLine three times.                     In Section 7.6 we will come back to this question and list some additional                    beneﬁts of dividing programs into methods.                        3.6      Classes and methods                     Pulling together the code fragments from the previous section, the class def-                    inition looks like this:                    class NewLine {                        public static void newLine() {                         System.out.println(\"\");                      }                       public static void threeLine() {                         newLine();    newLine();     newLine();                      }                        public static void main(String[] args) {                         System.out.println(\"First line.\");                         threeLine();                         System.out.println(\"Second line.\");                      }                    }                    The ﬁrst line indicates that this is the class deﬁnition for a new class called                    NewLine. A class is a collection of related methods. In this case, the class                    named NewLine contains three methods, named newLine, threeLine, and                    main.","32                                            Chapter 3. Void methods                               The other class we’ve seen is the Math class. It contains methods named                             sqrt, sin, and others. When we invoke a mathematical method, we have to                             specify the name of the class (Math) and the name of the method. That’s                             why the syntax is slightly diﬀerent for Java methods and the methods we                             write:                                  Math.pow(2.0, 10.0);                                  newLine();                              The ﬁrst statement invokes the pow method in the Math class (which raises                             the ﬁrst argument to the power of the second argument). The second state-                             ment invokes the newLine method, which Java assumes is in the class we are                             writing (i.e., NewLine).                              If you try to invoke a method from the wrong class, the compiler will generate                             an error. For example, if you type:                                  pow(2.0, 10.0);                              The compiler will say something like, “Can’t ﬁnd a method named pow in                             class NewLine.” If you have seen this message, you might have wondered                             why it was looking for pow in your class deﬁnition. Now you know.                                 3.7      Programs with multiple methods                               When you look at a class deﬁnition that contains several methods, it is                             tempting to read it from top to bottom, but that is likely to be confusing,                             because that is not the order of execution of the program.                              Execution always begins at the ﬁrst statement of main, regardless of where                             it is in the program (in this example I deliberately put it at the bottom).                             Statements are executed one at a time, in order, until you reach a method                             invocation. Method invocations are like a detour in the ﬂow of execution.                             Instead of going to the next statement, you go to the ﬁrst line of the invoked                             method, execute all the statements there, and then come back and pick up                             again where you left oﬀ.                              That sounds simple enough, except that you have to remember that one                             method can invoke another. Thus, while we are in the middle of main, we                             might have to go oﬀ and execute the statements in threeLine. But while","3.8. Parameters and arguments                                              33                      we are executing threeLine, we get interrupted three times to go oﬀ and                    execute newLine.                    For its part, newLine invokes println, which causes yet another detour.                    Fortunately, Java is adept at keeping track of where it is, so when println                    completes, it picks up where it left oﬀ in newLine, and then gets back to                    threeLine, and then ﬁnally gets back to main so the program can terminate.                     Technically, the program does not terminate at the end of main. Instead,                    execution picks up where it left oﬀ in the program that invoked main, which                    is the Java interpreter. The interpreter takes care of things like deleting                    windows and general cleanup, and then the program terminates.                     What’s the moral of this sordid tale? When you read a program, don’t read                    from top to bottom. Instead, follow the ﬂow of execution.                        3.8      Parameters and arguments                      Some of the methods we have used require arguments, which are values                    that you provide when you invoke the method. For example, to ﬁnd the sine                    of a number, you have to provide the number. So sin takes a double as                    an argument. To print a string, you have to provide the string, so println                    takes a String as an argument.                      Some methods take more than one argument; for example, pow takes two                    doubles, the base and the exponent.                     When you use a method, you provide arguments. When you write a method,                    you specify a list of parameters. A parameter is a variable that stores an                    argument. The parameter list indicates what arguments are required.                     For example, printTwice speciﬁes a single parameter, s, that has type                    String. I called it s to suggest that it is a String, but I could have given it                    any legal variable name.                         public static void printTwice(String s) {                              System.out.println(s);                              System.out.println(s);                         }","34                                            Chapter 3. Void methods                               When we invoke printTwice, we have to provide a single argument with                             type String.                                  printTwice(\"Don't make me say this twice!\");                              When you invoke a method, the argument you provide are assigned to                             the parameters. In this example, the argument \"Don’t make me say this                             twice!\" is assigned to the parameter s. This processing is called parame-                             ter passing because the value gets passed from outside the method to the                             inside.                               An argument can be any kind of expression, so if you have a String variable,                             you can use it as an argument:                                  String argument = \"Never say never.\";                                  printTwice(argument);                              The value you provide as an argument must have the same type as the                             parameter. For example, if you try this:                                  printTwice(17);                              You get an error message like “cannot ﬁnd symbol,” which isn’t very helpful.                             The reason is that Java is looking for a method named printTwice that can                             take an integer argument. Since there isn’t one, it can’t ﬁnd such a “symbol.”                              System.out.println can accept any type as an argument. But that is an                             exception; most methods are not so accommodating.                                   3.9      Stack diagrams                                Parameters and other variables only exist inside their own methods. Within                             the conﬁnes of main, there is no such thing as s. If you try to use it, the                             compiler will complain. Similarly, inside printTwice there is no such thing                             as argument.                               One way to keep track of where each variable is deﬁned is with a stack                             diagram. The stack diagram for the previous example looks like this:","3.10. Methods with multiple parameters                                     35                              main   argument    \"Never say never.\"                         printTwice          s   \"Never say never.\"                        For each method there is a gray box called a frame that contains the                    method’s parameters and variables. The name of the method appears out-                    side the frame. As usual, the value of each variable is drawn inside a box                    with the name of the variable beside it.                        3.10       Methods with multiple parameters                       The syntax for declaring and invoking methods with multiple parameters is                    a common source of errors. First, remember that you have to declare the                    type of every parameter. For example                          public static void printTime(int hour, int minute) {                              System.out.print(hour);                              System.out.print(\":\");                              System.out.println(minute);                         }                     It might be tempting to write int hour, minute, but that format is only                    legal for variable declarations, not parameter lists.                     Another common source of confusion is that you do not have to declare the                    types of arguments. The following is wrong!                         int hour = 11;                         int minute = 59;                         printTime(int hour, int minute);           // WRONG!                     In this case, Java can tell the type of hour and minute by looking at their                    declarations. It is not necessary to include the type when you pass them as                    arguments. The correct syntax is printTime(hour, minute).","36                                            Chapter 3. Void methods                              3.11       Methods that return values                               Some of the methods we are using, like the Math methods, return values.                             Other methods, like println and newLine, perform an action but they don’t                             return a value. That raises some questions:                                   What happens if you invoke a method and you don’t do anything with                                   the result (i.e. you don’t assign it to a variable or use it as part of a                                   larger expression)?                                  What happens if you use a print method as part of an expression, like                                   System.out.println(\"boo!\") + 7?                                  Can we write methods that return values, or are we stuck with things                                   like newLine and printTwice?                              The answer to the third question is “yes, you can write methods that return                             values,” and we’ll see how in a couple of chapters. I leave it up to you to                             answer the other two questions by trying them out. In fact, any time you                             have a question about what is legal or illegal in Java, a good way to ﬁnd out                             is to ask the compiler.                                 3.12       Glossary                              initialization: A statement that declares a new variable and assigns a value                                   to it at the same time.                              ﬂoating-point: A type of variable (or value) that can contain fractions as                                   well as integers. The ﬂoating-point type we will use is double.                              class: A named collection of methods. So far, we have used the Math class                                   and the System class, and we have written classes named Hello and                                   NewLine.                              method: A named sequence of statements that performs a useful function.                                   Methods may or may not take parameters, and may or may not return                                   a value.                              parameter: A piece of information a method requires before it can run.                                   Parameters are variables: they contain values and have types.","3.13. Exercises                                                            37                      argument: A value that you provide when you invoke a method. This value                          must have the same type as the corresponding parameter.                    frame: A structure (represented by a gray box in stack diagrams) that con-                          tains a method’s parameters and variables.                     invoke: Cause a method to execute.                        3.13       Exercises                      Exercise 3.1. Draw a stack frame that shows the state of the program in                    Section 3.10 when main invokes printTime with the arguments 11 and 59.                     Exercise 3.2. The point of this exercise is to practice reading code and to                    make sure that you understand the ﬂow of execution through a program with                    multiple methods.                        1. What is the output of the following program? Be precise about where                          there are spaces and where there are newlines.                           HINT: Start by describing in words what ping and baffle do when                          they are invoked.                        2. Draw a stack diagram that shows the state of the program the ﬁrst                          time ping is invoked.                      public static void zoop() {                         baffle();                         System.out.print(\"You wugga \");                         baffle();                      }                        public static void main(String[] args) {                         System.out.print(\"No, I \");                         zoop();                         System.out.print(\"I \");                         baffle();                      }","38                                            Chapter 3. Void methods                                 public static void baffle() {                                  System.out.print(\"wug\");                                  ping();                               }                                 public static void ping() {                                  System.out.println(\".\");                               }                             Exercise 3.3. The point of this exercise is to make sure you understand how                             to write and invoke methods that take parameters.                                  1. Write the ﬁrst line of a method named zool that takes three parame-                                   ters: an int and two Strings.                                  2. Write a line of code that invokes zool, passing as arguments the value                                   11, the name of your ﬁrst pet, and the name of the street you grew up                                   on.                              Exercise 3.4. The purpose of this exercise is to take code from a previous                             exercise and encapsulate it in a method that takes parameters. You should                             start with a working solution to Exercise 2.2.                                  1. Write a method called printAmerican that takes the day, date, month                                   and year as parameters and that prints them in American format.                                 2. Test your method by invoking it from main and passing appropriate                                   arguments. The output should look something like this (except that                                   the date might be diﬀerent):                                     Saturday, July 16, 2011                                  3. Once you have debugged printAmerican, write another method called                                   printEuropean that prints the date in European format.","Chapter 4                         Conditionals and recursion                           4.1      The modulus operator                      The modulus operator works on integers (and integer expressions) and yields                    the remainder when the ﬁrst operand is divided by the second. In Java, the                    modulus operator is a percent sign, %. The syntax is the same as for other                    operators:                         int quotient = 7 / 3;                         int remainder = 7 % 3;                    The ﬁrst operator, integer division, yields 2. The second operator yields 1.                    Thus, 7 divided by 3 is 2 with 1 left over.                     The modulus operator turns out to be surprisingly useful. For example, you                    can check whether one number is divisible by another: if x % y is zero, then                    x is divisible by y.                     Also, you can use the modulus operator to extract the rightmost digit or                    digits from a number. For example, x % 10 yields the rightmost digit of x                    (in base 10). Similarly x % 100 yields the last two digits.                       4.2      Conditional execution                      To write useful programs, we almost always need to check conditions and                    change the behavior of the program accordingly. Conditional statements","40                             Chapter 4. Conditionals and recursion                               give us this ability. The simplest form is the if statement:                                  if (x > 0) {                                    System.out.println(\"x is positive\");                                  }                             The expression in parentheses is called the condition. If it is true, then the                             statements in brackets get executed. If the condition is not true, nothing                             happens.                              The condition can contain any of the comparison operators, sometimes called                             relational operators:                                   x == y                    // x equals y                                  x != y                    // x is not equal to y                                  x > y                     // x is greater than y                                  x < y                     // x is less than y                                  x >= y                    // x is greater than or equal to y                                  x <= y                    // x is less than or equal to y                             Although these operations are probably familiar to you, the syntax Java uses                             is a little diﬀerent from mathematical symbols like =, 6= and ≤. A common                             error is to use a single = instead of a double ==. Remember that = is the                             assignment operator, and == is a comparison operator. Also, there is no such                             thing as =< or =>.                              The two sides of a condition operator have to be the same type. You can                             only compare ints to ints and doubles to doubles.                              The operators == and != work with Strings, but they don’t do what you                             expect. And the other relational operators don’t do anything at all. We will                             see how to compare strings Section 8.10.                                 4.3      Alternative execution                               A second form of conditional execution is alternative execution, in which                             there are two possibilities, and the condition determines which one gets exe-                             cuted. The syntax looks like:                                   if (x%2 == 0) {                                    System.out.println(\"x is even\");","4.4. Chained conditionals                                                  41                           } else {                           System.out.println(\"x is odd\");                         }                    If the remainder when x is divided by 2 is zero, then we know that x is even,                    and this code prints a message to that eﬀect. If the condition is false, the                    second print statement is executed. Since the condition must be true or false,                    exactly one of the alternatives will be executed.                     As an aside, if you think you might want to check the parity (evenness or                    oddness) of numbers often, you might want to “wrap” this code up in a                    method, as follows:                      public static void printParity(int x) {                         if (x%2 == 0) {                           System.out.println(\"x is even\");                         } else {                           System.out.println(\"x is odd\");                         }                      }                     Now you have a method named printParity that will print an appropriate                    message for any integer you care to provide. In main you would invoke this                    method like this:                          printParity(17);                    Always remember that when you invoke a method, you do not have to declare                    the types of the arguments you provide. Java can ﬁgure out what type they                    are. You should resist the temptation to write things like:                         int number = 17;                         printParity(int number);                // WRONG!!!                       4.4      Chained conditionals                      Sometimes you want to check for a number of related conditions and choose                    one of several actions. One way to do this is by chaining a series of ifs and                    elses:                          if (x > 0) {                           System.out.println(\"x is positive\");","42                             Chapter 4. Conditionals and recursion                                    } else if (x < 0) {                                    System.out.println(\"x is negative\");                                  } else {                                    System.out.println(\"x is zero\");                                  }                              These chains can be as long as you want, although they can be diﬃcult to                             read if they get out of hand. One way to make them easier to read is to use                             standard indentation, as demonstrated in these examples. If you keep all the                             statements and squiggly-brackets lined up, you are less likely to make syntax                             errors and more likely to ﬁnd them if you do.                                  4.5      Nested conditionals                               In addition to chaining, you can also nest one conditional within another.                             We could have written the previous example as:                                  if (x == 0) {                                    System.out.println(\"x is zero\");                                  } else {                                    if (x > 0) {                                       System.out.println(\"x is positive\");                                    } else {                                       System.out.println(\"x is negative\");                                    }                                  }                             There is now an outer conditional that contains two branches. The ﬁrst                             branch contains a simple print statement, but the second branch contains                             another conditional statement, which has two branches of its own. Those two                             branches are both print statements, but they could have been conditional                             statements as well.                               Indentation helps make the structure apparent, but nevertheless, nested con-                             ditionals get diﬃcult to read very quickly. Avoid them when you can.                              On the other hand, this kind of nested structure is common, and we will                             see it again, so you better get used to it.","4.6. The return statement                                                  43                     4.6      The return statement                       The return statement allows you to terminate the execution of a method                    before you reach the end. One reason to use it is if you detect an error                    condition:                      public static void printLogarithm(double x) {                         if (x <= 0.0) {                           System.out.println(\"Positive numbers only, please.\");                           return;                         }                           double result = Math.log(x);                         System.out.println(\"The log of x is \" + result);                      }                     This deﬁnes a method named printLogarithm that takes a double named                    x as a parameter. It checks whether x is less than or equal to zero, in which                    case it prints an error message and then uses return to exit the method.                    The ﬂow of execution immediately returns to the caller and the remaining                    lines of the method are not executed.                     I used a ﬂoating-point value on the right side of the condition because there                    is a ﬂoating-point variable on the left.                          4.7      Type conversion                      You might wonder how you can get away with an expression like \"The log                    of x is \" + result, since one of the operands is a String and the other                    is a double. In this case Java is being smart on our behalf, automatically                    converting the double to a String before it does the string concatenation.                     Whenever you try to “add” two expressions, if one of them is a String, Java                    converts the other to a String and then perform string concatenation. What                    do you think happens if you perform an operation between an integer and a                    ﬂoating-point value?","44                             Chapter 4. Conditionals and recursion                              4.8      Recursion                               I mentioned in the last chapter that it is legal for one method to invoke                             another, and we have seen several examples. I neglected to mention that it                             is also legal for a method to invoke itself. It may not be obvious why that is                             a good thing, but it turns out to be one of the most magical and interesting                             things a program can do.                              For example, look at the following method:                                public static void countdown(int n) {                                  if (n == 0) {                                    System.out.println(\"Blastoff!\");                                  } else {                                    System.out.println(n);                                    countdown(n-1);                                  }                               }                             The name of the method is countdown and it takes a single integer as a                             parameter. If the parameter is zero, it prints the word “Blastoﬀ.” Otherwise,                             it prints the number and then invokes a method named countdown—itself—                             passing n-1 as an argument.                              What happens if we invoke this method, in main, like this:                                   countdown(3);                             The execution of countdown begins with n=3, and since n is not zero, it prints                             the value 3, and then invokes itself...                                     The execution of countdown begins with n=2, and since n is not                                   zero, it prints the value 2, and then invokes itself...                                        The execution of countdown begins with n=1, and since                                        n is not zero, it prints the value 1, and then invokes                                        itself...                                            The execution of countdown begins with n=0,                                            and since n is zero, it prints the word                                            “Blastoﬀ!” and then returns.                                        The countdown that got n=1 returns.","4.8. Recursion                                                             45                            The countdown that got n=2 returns.                       The countdown that got n=3 returns.                      And then you’re back in main. So the total output looks like:                     3                    2                    1                    Blastoff!                     As a second example, let’s look again at the methods newLine and                    threeLine.                       public static void newLine() {                         System.out.println(\"\");                      }                       public static void threeLine() {                         newLine();    newLine();     newLine();                      }                     Although these work, they would not be much help if we wanted to print 2                    newlines, or 106. A better alternative would be                      public static void nLines(int n) {                         if (n > 0) {                           System.out.println(\"\");                           nLines(n-1);                         }                      }                      This program similar to countdown; as long as n is greater than zero, it prints                    a newline and then invokes itself to print n-1 additional newlines. The total                    number of newlines that get printed is 1 +(n-1), which usually comes out                    to roughly n.                      When a method invokes itself, that’s called recursion, and such methods                    are recursive.","46                             Chapter 4. Conditionals and recursion                              4.9      Stack diagrams for recursive methods                               In the previous chapter we used a stack diagram to represent the state of a                             program during a method invocation. The same kind of diagram can make                             it easier to interpret a recursive method.                              Remember that every time a method gets called it creates a new frame that                             contains a new version of the method’s parameters and variables.                             The following ﬁgure is a stack diagram for countdown, called with n = 3:                                      main                                countdown    n    3                                countdown    n    2                                countdown    n    1                                countdown    n    0                               There is one frame for main and four frames for countdown, each with a                             diﬀerent value for the parameter n. The bottom of the stack, countdown                             with n=0 is called the base case. It does not make a recursive call, so there                             are no more frames for countdown.                              The frame for main is empty because main does not have any parameters or                             variables.                                4.10       Glossary                               modulus: An operator that works on integers and yields the remainder                                   when one number is divided by another. In Java it is denoted with a                                   percent sign(%).                              conditional: A block of statements that may or may not be executed de-                                   pending on some condition.","4.11. Exercises                                                            47                      chaining: A way of joining several conditional statements in sequence.                     nesting: Putting a conditional statement inside one or both branches of                          another conditional statement.                      typecast: An operator that converts from one type to another. In Java it                          appears as a type name in parentheses, like (int).                     recursion: The process of invoking the same method you are currently ex-                          ecuting.                     base case: A condition that causes a recursive method not to make a recur-                          sive call.                       4.11       Exercises                      Exercise 4.1. Draw a stack diagram that shows the state of the program in                    Section 4.8 after main invokes nLines with the parameter n=4, just before                    the last invocation of nLines returns.                     Exercise 4.2. This exercise reviews the ﬂow of execution through a program                    with multiple methods. Read the following code and answer the questions                    below.                     public class Buzz {                          public static void baffle(String blimp) {                              System.out.println(blimp);                              zippo(\"ping\", -5);                         }                           public static void zippo(String quince, int flag) {                              if (flag < 0) {                                   System.out.println(quince + \" zoop\");                              } else {                                   System.out.println(\"ik\");                                   baffle(quince);                                   System.out.println(\"boo-wa-ha-ha\");                              }","48                             Chapter 4. Conditionals and recursion                                    }                                    public static void main(String[] args) {                                       zippo(\"rattle\", 13);                                  }                             }                                1. Write the number 1 next to the ﬁrst statement of this program that                                   will be executed. Be careful to distinguish things that are statements                                   from things that are not.                                 2. Write the number 2 next to the second statement, and so on until the                                   end of the program. If a statement is executed more than once, it might                                   end up with more than one number next to it.                                3. What is the value of the parameter blimp when baffle gets invoked?                                  4. What is the output of this program?                             Exercise 4.3. The ﬁrst verse of the song “99 Bottles of Beer” is:                                    99 bottles of beer on the wall, 99 bottles of beer, ya’ take one                                   down, ya’ pass it around, 98 bottles of beer on the wall.                              Subsequent verses are identical except that the number of bottles gets smaller                             by one in each verse, until the last verse:                                   No bottles of beer on the wall, no bottles of beer, ya’ can’t take                                   one down, ya’ can’t pass it around, ’cause there are no more                                   bottles of beer on the wall!                              And then the song(ﬁnally) ends.                              Write a program that prints the entire lyrics of “99 Bottles of Beer.” Your                             program should include a recursive method that does the hard part, but you                             might want to write additional methods to separate the major functions of                             the program.                              As you develop your code, test it with a small number of verses, like “3                             Bottles of Beer.”                              The purpose of this exercise is to take a problem and break it into smaller                             problems, and to solve the smaller problems by writing simple methods.","4.11. Exercises                                                            49                      Exercise 4.4. What is the output of the following program?                    public class Narf {                           public static void zoop(String fred, int bob) {                              System.out.println(fred);                              if (bob == 5) {                                   ping(\"not \");                              } else {                                   System.out.println(\"!\");                              }                         }                          public static void main(String[] args) {                              int bizz = 5;                              int buzz = 2;                              zoop(\"just for\", bizz);                              clink(2*buzz);                         }                          public static void clink(int fork) {                              System.out.print(\"It's \");                              zoop(\"breakfast \", fork) ;                         }                          public static void ping(String strangStrung) {                              System.out.println(\"any \" + strangStrung + \"more \");                         }                    }                     Exercise 4.5. Fermat’s Last Theorem says that there are no integers a, b,                    and c such that                                                      n                                                           n                                                    a + b = c   n                    except in the case when n = 2.                     Write a method named checkFermat that takes four integers as parameters—                    a, b, c and n—and that checks to see if Fermat’s theorem holds. If n is greater                                                                n                                                                      n                                                            n                    than 2 and it turns out to be true that a +b = c , the program should print","50                             Chapter 4. Conditionals and recursion                               “Holy smokes, Fermat was wrong!” Otherwise the program should print “No,                             that doesn’t work.”                             You should assume that there is a method named raiseToPow that takes two                             integers as arguments and that raises the ﬁrst argument to the power of the                             second. For example:                                   int x = raiseToPow(2, 3);                                                                      3                             would assign the value 8 to x, because 2 = 8.","Chapter 5                         GridWorld: Part 1                            5.1      Getting started                      Now is a good time to start working with the AP Computer Science                    Case Study, which is a program called GridWorld.         To get started, in-                    stall GridWorld, which you can download from the College Board: http:                    //www.collegeboard.com/student/testing/ap/compsci_a/case.html.                     When you unpack this code, you should have a folder named GridWorldCode                    that contains projects/firstProject, which contains BugRunner.java.                     Make a copy of BugRunner.java in another folder and then import it                    into your development environment.        There are instructions here that                    might help:    http://www.collegeboard.com/prod_downloads/student/                    testing/ap/compsci_a/ap07_gridworld_installation_guide.pdf.                    Once you run BugRunner.java,           download the GridWorld Student                    Manual from http://www.collegeboard.com/prod_downloads/student/                    testing/ap/compsci_a/ap07_gridworld_studmanual_appends_v3.pdf.                     The Student Manual uses vocabulary I have not presented yet, so to get you                    started, here is a quick preview:                          The components of GridWorld, including Bugs, Rocks and the Grid                          itself, are objects.","52                                       Chapter 5. GridWorld: Part 1                                   A constructor is a special method that creates new objects.                                  A class is a set of objects; every object belongs to a class.                                  An object is also called an instance because it is a member, or instance,                                   of a class.                                 An attribute is a piece of information about an object, like its color                                   or location.                                  An accessor method is a method that returns an attribute of an                                   object.                                  A modiﬁer method changes an attribute of an object.                              Now you should be able to read Part 1 of the Student Manual and do the                             exercises.                                 5.2      BugRunner                              BugRunner.java contains this code:                              import info.gridworld.actor.ActorWorld;                             import info.gridworld.actor.Bug;                             import info.gridworld.actor.Rock;                               public class BugRunner                             {                                  public static void main(String[] args)                                  {                                       ActorWorld world = new ActorWorld();                                       world.add(new Bug());                                       world.add(new Rock());                                       world.show();                                  }                             }                             The ﬁrst three lines are import statements; they list the classes from Grid-                             World used in this program. You can ﬁnd the documentation for these classes                             at http://www.greenteapress.com/thinkapjava/javadoc/gridworld/.","5.3. Exercises                                                             53                      Like the other programs we have seen, BugRunner deﬁnes a class that pro-                    vides a main method. The ﬁrst line of main creates an ActorWorld object.                    new is a Java keyword that creates new objects.                     The next two lines create a Bug and a Rock, and add them to world. The                    last line shows the world on the screen.                     Open BugRunner.java for editing and replace this line:                          world.add(new Bug());                    with these lines:                         Bug redBug = new Bug();                         world.add(redBug);                     The ﬁrst line assigns the Bug to a variable named redBug; we can use redBug                    to invoke the Bug’s methods. Try this:                          System.out.println(redBug.getLocation());                    Note: If you run this before adding the Bug to the world, the result is null,                    which means that the Bug doesn’t have a location yet.                     Invoke the other accessor methods and print the bug’s attributes. Invoke the                    methods canMove, move and turn and be sure you understand what they do.                        5.3      Exercises                      Exercise 5.1.     1. Write a method named moveBug that takes a bug as a                          parameter and invokes move. Test your method by calling it from main.                        2. Modify moveBug so that it invokes canMove and moves the bug only if                          it can.                        3. Modify moveBug so that it takes an integer, n, as a parameter, and                          moves the bug n times (if it can).                        4. Modify moveBug so that if the bug can’t move, it invokes turn instead.                      Exercise 5.2.     1. The Math class provides a method named random that                          returns a double between 0.0 and 1.0 (not including 1.0).","54                                       Chapter 5. GridWorld: Part 1                                  2. Write a method named randomBug that takes a Bug as a parameter                                   and sets the Bug’s direction to one of 0, 90, 180 or 270 with equal                                   probability, and then moves the bug if it can.                                 3. Modify randomBug to take an integer n and repeat n times.                                    The result is a random walk, which you can read about at http://en.                                   wikipedia.org/wiki/Random_walk.                                 4. To see a longer random walk, you can give ActorWorld a bigger stage.                                   At the top of BugRunner.java, add this import statement:                                   import info.gridworld.grid.UnboundedGrid;                                   Now replace the line that creates the ActorWorld with this:                                        ActorWorld world = new ActorWorld(new UnboundedGrid());                                   You should be able to run your random walk for a few thousand steps                                   (you might have to use the scrollbars to ﬁnd the Bug).                              Exercise 5.3. GridWorld uses Color objects, which are deﬁned in a Java                             library. You can read the documentation at http://download.oracle.com/                             javase/6/docs/api/java/awt/Color.html.                              To create Bugs with diﬀerent colors, we have to import Color:                             import java.awt.Color;                              Then you can access the predeﬁned colors, like Color.blue, or create a new                             color like this:                                   Color purple = new Color(148, 0, 211);                             Make a few bugs with diﬀerent colors. Then write a method named colorBug                             that takes a Bug as a parameter, reads its location, and sets the color.                              The Location object you get from getLocation has methods named getRow                             and getCol that return integers. So you can get the x-coordinate of a Bug                             like this:                                  int x = bug.getLocation().getCol();                              Write a method named makeBugs that takes an ActorWorld and an integer n                             and creates n bugs colored according to their location. Use the row number                             to control the red level and the column to control the blue.","Chapter 6                         Value methods                            6.1      Return values                     Some of the methods we have used, like the Math functions, produce results.                    That is, the eﬀect of invoking the method is to generate a new value, which                    we usually assign to a variable or use as part of an expression. For example:                         double e = Math.exp(1.0);                         double height = radius * Math.sin(angle);                     But so far all our methods have been void; that is, methods that return no                    value. When you invoke a void method, it is typically on a line by itself, with                    no assignment:                          countdown(3);                         nLines(3);                     In this chapter we write methods that return things, which I call value                    methods. The ﬁrst example is area, which takes a double as a parameter,                    and returns the area of a circle with the given radius:                       public static double area(double radius) {                         double area = Math.PI * radius * radius;                         return area;                      }                     The ﬁrst thing you should notice is that the beginning of the method deﬁ-                    nition is diﬀerent. Instead of public static void, which indicates a void","56                                           Chapter 6. Value methods                               method, we see public static double, which means that the return value                             from this method is a double. I still haven’t explained what public static                             means, but be patient.                              The last line is a new form of the return statement that includes a return                             value. This statement means, “return immediately from this method and use                             the following expression as the return value.” The expression you provide                             can be arbitrarily complicated, so we could have written this method more                             concisely:                                public static double area(double radius) {                                  return Math.PI * radius * radius;                               }                             On the other hand, temporary variables like area often make debugging                             easier. In either case, the type of the expression in the return statement must                             match the return type of the method. In other words, when you declare that                             the return type is double, you are making a promise that this method will                             eventually produce a double. If you try to return with no expression, or an                             expression with the wrong type, the compiler will take you to task.                              Sometimes it is useful to have multiple return statements, one in each branch                             of a conditional:                               public static double absoluteValue(double x) {                                  if (x < 0) {                                    return -x;                                  } else {                                    return x;                                  }                               }                             Since these return statements are in an alternative conditional, only one will                             be executed. Although it is legal to have more than one return statement                             in a method, you should keep in mind that as soon as one is executed, the                             method terminates without executing any subsequent statements.                             Code that appears after a return statement, or any place else where it can                             never be executed, is called dead code. Some compilers warn you if part of                             your code is dead.                              If you put return statements inside a conditional, then you have to guarantee                             that every possible path through the program hits a return statement. For","6.2. Program development                                                   57                      example:                      public static double absoluteValue(double x) {                         if (x < 0) {                           return -x;                         } else if (x > 0) {                           return x;                         }                                // WRONG!!                      }                    This program is not legal because if x is 0, neither condition is true and the                    method ends without hitting a return statement. A typical compiler message                    would be “return statement required in absoluteValue,” which is a confusing                    message since there are already two of them.                       6.2      Program development                      At this point you should be able to look at complete Java methods and tell                    what they do. But it may not be clear yet how to go about writing them. I                    am going to suggest a method called incremental development.                    As an example, imagine you want to ﬁnd the distance between two points,                    given by the coordinates (x 1 , y 1 ) and (x 2 , y 2 ). By the usual deﬁnition,                                                     p                                        distance =    (x 2 − x 1 ) + (y 2 − y 1 ) 2                                                                2                    The ﬁrst step is to consider what a distance method should look like in                    Java. In other words, what are the inputs (parameters) and what is the                    output (return value)?                    In this case, the two points are the parameters, and it is natural to represent                    them using four doubles, although we will see later that there is a Point                    object in Java that we could use. The return value is the distance, which                    will have type double.                     Already we can write an outline of the method:                      public static double distance                                     (double x1, double y1, double x2, double y2) {                         return 0.0;                      }","58                                           Chapter 6. Value methods                               The statement return 0.0; is a place-keeper that is necessary to compile the                             program. Obviously, at this stage the program doesn’t do anything useful,                             but it is worthwhile to try compiling it so we can identify any syntax errors                             before we add more code.                              To test the new method, we have to invoke it with sample values. Somewhere                             in main I would add:                                  double dist = distance(1.0, 2.0, 4.0, 6.0);                              I chose these values so that the horizontal distance is 3 and the vertical dis-                             tance is 4; that way, the result will be 5 (the hypotenuse of a 3-4-5 triangle).                             When you are testing a method, it is useful to know the right answer.                              Once we have checked the syntax of the method deﬁnition, we can start                             adding lines of code one at a time. After each incremental change, we recom-                             pile and run the program. If there is an error at any point, we have a good                             idea where to look: in the last line we added.                              The next step is to ﬁnd the diﬀerences x 2 − x 1 and y 2 − y 1 . I store those                             values in temporary variables named dx and dy.                               public static double distance                                              (double x1, double y1, double x2, double y2) {                                  double dx = x2 - x1;                                  double dy = y2 - y1;                                  System.out.println(\"dx is \" + dx);                                  System.out.println(\"dy is \" + dy);                                  return 0.0;                               }                             I added print statements so we can check the intermediate values before                             proceeding. They should be 3.0 and 4.0.                              When the method is ﬁnished I remove the print statements. Code like that                             is called scaﬀolding, because it is helpful for building the program, but it                             is not part of the ﬁnal product.                             The next step is to square dx and dy. We could use the Math.pow method,                             but it is simpler to multiply each term by itself.                                public static double distance                                              (double x1, double y1, double x2, double y2) {","6.3. Composition                                                           59                           double dx = x2 - x1;                         double dy = y2 - y1;                         double dsquared = dx*dx + dy*dy;                         System.out.println(\"dsquared is \" + dsquared);                         return 0.0;                      }                    Again, I would compile and run the program at this stage and check the                    intermediate value (which should be 25.0).                     Finally, we can use Math.sqrt to compute and return the result.                      public static double distance                                     (double x1, double y1, double x2, double y2) {                         double dx = x2 - x1;                         double dy = y2 - y1;                         double dsquared = dx*dx + dy*dy;                         double result = Math.sqrt(dsquared);                         return result;                      }                    In main, we can print and check the value of the result.                     As you gain more experience programming, you might write and debug more                    than one line at a time. Nevertheless, incremental development can save you                    a lot of time. The key aspects of the process are:                        Start with a working program and make small, incremental changes.                          At any point, if there is an error, you will know exactly where it is.                         Use temporary variables to hold intermediate values so you can print                          and check them.                         Once the program is working, you can remove scaﬀolding and consoli-                          date multiple statements into compound expressions, but only if it does                          not make the program diﬃcult to read.                       6.3      Composition                      Once you deﬁne a new method, you can use it as part of an expression, and                    you can build new methods using existing methods. For example, what if","60                                           Chapter 6. Value methods                               someone gave you two points, the center of the circle and a point on the                             perimeter, and asked for the area of the circle?                             Let’s say the center point is stored in the variables xc and yc, and the                             perimeter point is in xp and yp. The ﬁrst step is to ﬁnd the radius of the                             circle, which is the distance between the two points. Fortunately, we have a                             method, distance that does that.                                  double radius = distance(xc, yc, xp, yp);                             The second step is to ﬁnd the area of a circle with that radius, and return it.                                   double area = area(radius);                                  return area;                             Wrapping that all up in a method, we get:                               public static double circleArea                                              (double xc, double yc, double xp, double yp) {                                  double radius = distance(xc, yc, xp, yp);                                  double area = area(radius);                                  return area;                               }                             The temporary variables radius and area are useful for development and                             debugging, but once the program is working we can make it more concise by                             composing the method invocations:                                public static double circleArea                                              (double xc, double yc, double xp, double yp) {                                  return area(distance(xc, yc, xp, yp));                               }                                6.4      Overloading                               You might have noticed that circleArea and area perform similar                             functions—ﬁnding the area of a circle—but take diﬀerent parameters. For                             area, we have to provide the radius; for circleArea we provide two points.                              If two methods do the same thing, it is natural to give them the same name.                             Having more than one method with the same name, which is called over-                             loading, is legal in Java as long as each version takes diﬀerent parameters.                             So we could rename circleArea:","6.5. Boolean expressions                                                   61                        public static double area                                     (double x1, double y1, double x2, double y2) {                         return area(distance(xc, yc, xp, yp));                      }                    When you invoke an overloaded method, Java knows which version you want                    by looking at the arguments that you provide. If you write:                          double x = area(3.0);                    Java goes looking for a method named area that takes one double as an                    argument, and so it uses the ﬁrst version, which interprets the argument as                    a radius. If you write:                          double x = area(1.0, 2.0, 4.0, 6.0);                    Java uses the second version of area. And notice that the second version of                    area actually invokes the ﬁrst.                    Many Java methods are overloaded, meaning that there are diﬀerent versions                    that accept diﬀerent numbers or types of parameters. For example, there are                    versions of print and println that accept a single parameter of any type.                    In the Math class, there is a version of abs that works on doubles, and there                    is also a version for ints.                     Although overloading is a useful feature, it should be used with caution. You                    might get yourself nicely confused if you are trying to debug one version of                    a method while accidently invoking a diﬀerent one.                    And that reminds me of one of the cardinal rules of debugging: make sure                    that the version of the program you are looking at is the version                    of the program that is running!                     Some day you may ﬁnd yourself making one change after another in your                    program, and seeing the same thing every time you run it. This is a warning                    sign that you are not running the version of the program you think you are.                    To check, add a print statement (it doesn’t matter what you print) and                    make sure the behavior of the program changes accordingly.                       6.5      Boolean expressions                      Most of the operations we have seen produce results that are the same type                    as their operands. For example, the + operator takes two ints and produces","62                                           Chapter 6. Value methods                               an int, or two doubles and produces a double, etc.                             The exceptions we have seen are the relational operators, which compare                             ints and floats and return either true or false. true and false are special                             values in Java, and together they make up a type called boolean. You might                             recall that when I deﬁned a type, I said it was a set of values. In the case of                             ints, doubles and Strings, those sets are pretty big. For booleans, there                             are only two values.                             Boolean expressions and variables work just like other types of expressions                             and variables:                                  boolean flag;                                  flag = true;                                  boolean testResult = false;                             The ﬁrst example is a simple variable declaration; the second example is an                             assignment, and the third example is an initialization.                              The values true and false are keywords in Java, so they may appear in a                             diﬀerent color, depending on your development environment.                              The result of a conditional operator is a boolean, so you can store the result                             of a comparison in a variable:                                   boolean evenFlag = (n%2 == 0);             // true if n is even                                  boolean positiveFlag = (x > 0);            // true if x is positive                             and then use it as part of a conditional statement later:                                  if (evenFlag) {                                    System.out.println(\"n was even when I checked it\");                                  }                             A variable used in this way is called a ﬂag because it ﬂags the presence or                             absence of some condition.                                6.6      Logical operators                               There are three logical operators in Java: AND, OR and NOT, which are                             denoted by the symbols \&\&, || and !. The semantics of these operators is                             similar to their meaning in English. For example x > 0 \&\& x < 10 is true                             only if x is greater than zero AND less than 10.","6.7. Boolean methods                                                       63                      evenFlag || n%3 == 0 is true if either of the conditions is true, that is, if                    evenFlag is true OR the number is divisible by 3.                    Finally, the NOT operator inverts a boolean expression, so !evenFlag is true                    if evenFlag is false—if the number is odd.                     Logical operators can simplify nested conditional statements. For example,                    can you re-write this code using a single conditional?                         if (x > 0) {                           if (x < 10) {                              System.out.println(\"x is a positive single digit.\");                           }                         }                       6.7      Boolean methods                      Methods can return boolean values just like any other type, which is often                    convenient for hiding tests inside methods. For example:                      public static boolean isSingleDigit(int x) {                         if (x >= 0 \&\& x < 10) {                           return true;                         } else {                           return false;                         }                      }                    The name of this method is isSingleDigit. It is common to give boolean                    methods names that sound like yes/no questions. The return type is boolean,                    which means that every return statement has to provide a boolean expression.                     The code itself is straightforward, although it is longer than it needs to be.                    Remember that the expression x >= 0 \&\& x < 10 has type boolean, so there                    is nothing wrong with returning it directly and avoiding the if statement                    altogether:                       public static boolean isSingleDigit(int x) {                         return (x >= 0 \&\& x < 10);                      }                    In main you can invoke this method in the usual ways:","64                                           Chapter 6. Value methods                                 boolean bigFlag = !isSingleDigit(17);                               System.out.println(isSingleDigit(2));                             The ﬁrst line sets bigFlag to true only if 17 is not a single-digit number.                             The second line prints true because 2 is a single-digit number.                             The most common use of boolean methods is inside conditional statements                                   if (isSingleDigit(x)) {                                    System.out.println(\"x is little\");                                  } else {                                    System.out.println(\"x is big\");                                  }                                6.8      More recursion                               Now that we have methods that return values, we have a Turing com-                             plete programming language, which means that we can compute anything                             computable, for any reasonable deﬁnition of “computable.”      This idea was                             developed by Alonzo Church and Alan Turing, so it is known as the Church-                             Turing thesis. You can read more about it at http://en.wikipedia.org/                             wiki/Turing_thesis.                              To give you an idea of what you can do with the tools we have learned,                             let’s look at some methods for evaluating recursively-deﬁned mathematical                             functions. A recursive deﬁnition is similar to a circular deﬁnition, in the                             sense that the deﬁnition contains a reference to the thing being deﬁned. A                             truly circular deﬁnition is not very useful:                              recursive: an adjective used to describe a method that is recursive.                               If you saw that deﬁnition in the dictionary, you might be annoyed. On the                             other hand, if you looked up the deﬁnition of the mathematical function                             factorial, you might get something like:                                                              0! = 1                                                              n! = n · (n − 1)!                              (Factorial is usually denoted with the symbol !, which is not to be confused                             with the logical operator ! which means NOT.) This deﬁnition says that the","6.8. More recursion                                                        65                      factorial of 0 is 1, and the factorial of any other value, n, is n multiplied by                    the factorial of n − 1. So 3! is 3 times 2!, which is 2 times 1!, which is 1                    times 0!. Putting it all together, we get 3! equal to 3 times 2 times 1 times                    1, which is 6.                     If you can write a recursive deﬁnition of something, you can usually write a                    Java method to evaluate it. The ﬁrst step is to decide what the parameters                    are and what the return type is. Since factorial is deﬁned for integers, the                    method takes an integer as a parameter and returns an integer:                       public static int factorial(int n) {                      }                    If the argument happens to be zero, return 1:                      public static int factorial(int n) {                         if (n == 0) {                           return 1;                         }                      }                    That’s the base case.                    Otherwise, and this is the interesting part, we have to make a recursive call                    to ﬁnd the factorial of n − 1, and then multiply it by n.                      public static int factorial(int n) {                         if (n == 0) {                           return 1;                         } else {                           int recurse = factorial(n-1);                           int result = n * recurse;                           return result;                         }                      }                    The ﬂow of execution for this program is similar to countdown from Sec-                    tion 4.8. If we invoke factorial with the value 3:                     Since 3 is not zero, we take the second branch and calculate the factorial of                    n − 1...                           Since 2 is not zero, we take the second branch and calculate the                          factorial of n − 1...","66                                           Chapter 6. Value methods                                          Since 1 is not zero, we take the second branch and                                        calculate the factorial of n − 1...                                            Since 0 is zero, we take the ﬁrst branch and re-                                            turn the value 1 immediately without making                                            any more recursive invocations.                                        The return value (1) gets multiplied by n, which is 1,                                        and the result is returned.                                    The return value (1) gets multiplied by n, which is 2, and the                                   result is returned.                               The return value (2) gets multiplied by n, which is 3, and the result, 6, is                             returned to main, or whoever invoked factorial(3).                              Here is what the stack diagram looks like for this sequence of method invo-                             cations:                                 main                                                                                   6                             factorial  n  3       recurse  2      result  6                                                                                   2                             factorial  n  2       recurse  1      result  2                                                                                   1                             factorial  n  1       recurse  1      result  1                                                                                   1                             factorial  n  0                               The return values are shown being passed back up the stack.                              Notice that in the last frame recurse and result do not exist because when                             n=0 the branch that creates them does not execute.                                 6.9      Leap of faith                               Following the ﬂow of execution is one way to read programs, but it can quickly                             become disorienting. An alternative is what I call the “leap of faith.” When","6.10. One more example                                                     67                      you come to a method invocation, instead of following the ﬂow of execution,                    you assume that the method works correctly and returns the appropriate                    value.                     In fact, you are already practicing this leap of faith when you use Java                    methods. When you invoke Math.cos or System.out.println, you don’t                    examine the implementations of those methods. You just assume that they                    work.                    You can apply the same logic to your own methods. For example, in Sec-                    tion 6.7 we wrote a method called isSingleDigit that determines whether                    a number is between 0 and 9. Once we convince ourselves that this method                    is correct—by testing and examination of the code—we can use the method                    without ever looking at the code again.                     The same is true of recursive programs. When you get to the recursive                    invocation, instead of following the ﬂow of execution, you should assume                    that the recursive invocation works, and then ask yourself, “Assuming that                    I can ﬁnd the factorial of n − 1, can I compute the factorial of n?” Yes, you                    can, by multiplying by n.                     Of course, it is strange to assume that the method works correctly when you                    have not even ﬁnished writing it, but that’s why it’s called a leap of faith!                        6.10       One more example                      The second most common example of a recursively-deﬁned mathematical                    function is fibonacci, which has the following deﬁnition:                                   fibonacci(0) = 1                                  fibonacci(1) = 1                                  fibonacci(n) = fibonacci(n − 1) + fibonacci(n − 2);                      Translated into Java, this is                      public static int fibonacci(int n) {                         if (n == 0 || n == 1) {                           return 1;                         } else {","68                                           Chapter 6. Value methods                                      return fibonacci(n-1) + fibonacci(n-2);                                  }                               }                             If you try to follow the ﬂow of execution here, even for small values of n,                             your head explodes. But according to the leap of faith, if we assume that                             the two recursive invocations work correctly, then it is clear that we get the                             right result by adding them together.                                 6.11       Glossary                              return type: The part of a method declaration that indicates what type of                                   value the method returns.                              return value: The value provided as the result of a method invocation.                              dead code: Part of a program that can never be executed, often because it                                   appears after a return statement.                              scaﬀolding: Code that is used during program development but is not part                                   of the ﬁnal version.                              void: A special return type that indicates a void method; that is, one that                                   does not return a value.                              overloading: Having more than one method with the same name but diﬀer-                                   ent parameters. When you invoke an overloaded method, Java knows                                   which version to use by looking at the arguments you provide.                              boolean: A type of variable that can contain only the two values true and                                   false.                              ﬂag: A variable (usually boolean) that records a condition or status infor-                                   mation.                              conditional operator: An operator that compares two values and produces                                   a boolean that indicates the relationship between the operands.                              logical operator: An operator that combines boolean values and produces                                   boolean values.","6.12. Exercises                                                            69                     6.12       Exercises                      Exercise 6.1. Write a method named isDivisible that takes two integers,                    n and m and that returns true if n is divisible by m and false otherwise.                     Exercise 6.2. Many computations can be expressed concisely using the                    “multadd” operation, which takes three operands and computes a*b + c.                    Some processors even provide a hardware implementation of this operation                    for ﬂoating-point numbers.                         1. Create a new program called Multadd.java.                        2. Write a method called multadd that takes three doubles as parameters                          and that returns their multadditionization.                        3. Write a main method that tests multadd by invoking it with a few                          simple parameters, like 1.0, 2.0, 3.0.                        4. Also in main, use multadd to compute the following values:                                                          sin  π  +  cos  π 4                                                           4     2                                                      log 10 + log 20                         5. Write a method called yikes that takes a double as a parameter and                          that uses multadd to calculate                                                           √                                                   xe −x  +  1 − e −x                           HINT: the Math method for raising e to a power is Math.exp.                      In the last part, you get a chance to write a method that invokes a method                    you wrote. Whenever you do that, it is a good idea to test the ﬁrst method                    carefully before you start working on the second. Otherwise, you might ﬁnd                    yourself debugging two methods at the same time, which can be diﬃcult.                    One of the purposes of this exercise is to practice pattern-matching: the                    ability to recognize a speciﬁc problem as an instance of a general category of                    problems.","70                                           Chapter 6. Value methods                               Exercise 6.3. If you are given three sticks, you may or may not be able to                             arrange them in a triangle. For example, if one of the sticks is 12 inches long                             and the other two are one inch long, you will not be able to get the short                             sticks to meet in the middle. For any three lengths, there is a simple test to                             see if it is possible to form a triangle:                                       “If any of the three lengths is greater than the sum of the                                   other two, then you cannot form a triangle. Otherwise, you can.”                               Write a method named isTriangle that it takes three integers as arguments,                             and that returns either true or false, depending on whether you can or                             cannot form a triangle from sticks with the given lengths.                             The point of this exercise is to use conditional statements to write a value                             method.                              Exercise 6.4. What is the output of the following program? The purpose                             of this exercise is to make sure you understand logical operators and the ﬂow                             of execution through value methods.                                public static void main(String[] args) {                                    boolean flag1 = isHoopy(202);                                    boolean flag2 = isFrabjuous(202);                                    System.out.println(flag1);                                    System.out.println(flag2);                                    if (flag1 \&\& flag2) {                                         System.out.println(\"ping!\");                                    }                                    if (flag1 || flag2) {                                         System.out.println(\"pong!\");                                    }                               }                                public static boolean isHoopy(int x) {                                    boolean hoopyFlag;                                    if (x%2 == 0) {                                         hoopyFlag = true;                                    } else {                                         hoopyFlag = false;","6.12. Exercises                                                            71                             }                           return hoopyFlag;                      }                       public static boolean isFrabjuous(int x) {                           boolean frabjuousFlag;                           if (x > 0) {                                frabjuousFlag = true;                           } else {                                frabjuousFlag = false;                           }                           return frabjuousFlag;                      }                    Exercise 6.5. The distance between two points (x 1 , y 1 ) and (x 2 , y 2 ) is                                                     p                                                                2                                        Distance =     (x 2 − x 1 ) + (y 2 − y 1 ) 2                    Write a method named distance that takes four doubles as parameters—x1,                    y1, x2 and y2—and that prints the distance between the points.                     You should assume that there is a method named sumSquares that calculates                    and returns the sum of the squares of its arguments. For example:                          double x = sumSquares(3.0, 4.0);                    would assign the value 25.0 to x.                     The point of this exercise is to write a new method that uses an existing                    one. You should write only one method: distance. You should not write                    sumSquares or main and you should not invoke distance.                     Exercise 6.6. The point of this exercise is to use a stack diagram to under-                    stand the execution of a recursive program.                     public class Prod {                          public static void main(String[] args) {                              System.out.println(prod(1, 4));                         }                           public static int prod(int m, int n) {","72                                           Chapter 6. Value methods                                         if (m == n) {                                            return n;                                       } else {                                            int recurse = prod(m, n-1);                                            int result = n * recurse;                                            return result;                                       }                                  }                             }                                  1. Draw a stack diagram showing the state of the program just before the                                   last instance of prod completes. What is the output of this program?                                 2. Explain in a few words what prod does.                                 3. Rewrite prod without using the temporary variables recurse and                                   result.                              Exercise 6.7. The purpose of this exercise is to translate a recursive deﬁni-                             tion into a Java method. The Ackerman function is deﬁned for non-negative                             integers as follows:                                                                                                n + 1                      if m = 0                                                                                   A(m, n) =    A(m − 1, 1)               if m > 0 and n = 0         (6.1)                                                                                                A(m − 1, A(m, n − 1)) if m > 0 and n > 0.                                                                            Write a method called ack that takes two ints as parameters and that com-                             putes and returns the value of the Ackerman function.                              Test your implementation of Ackerman by invoking it from main and printing                             the return value.                               WARNING: the return value gets very big very quickly. You should try it                             only for small values of m and n (not bigger than 2).                              Exercise 6.8.     1. Create a program called Recurse.java and type in the                                   following methods:                                         // first: returns the first character of the given String                                        public static char first(String s) {","6.12. Exercises                                                            73                                     return s.charAt(0);                               }                                // last: returns a new String that contains all but the                               // first letter of the given String                               public static String rest(String s) {                                   return s.substring(1, s.length());                               }                                // length: returns the length of the given String                               public static int length(String s) {                                   return s.length();                               }                       2. Write some code in main that tests each of these methods. Make sure                          they work, and make sure you understand what they do.                        3. Write a method called printString that takes a String as a parameter                          and that prints the letters of the String, one on each line. It should be                          a void method.                        4. Write a method called printBackward that does the same thing as                          printString but that prints the String backward (one character per                          line).                       5. Write a method called reverseString that takes a String as a param-                          eter and that returns a new String as a return value. The new String                          should contain the same letters as the parameter, but in reverse order.                          For example, the output of the following code                               String backwards = reverseString(\"Allen Downey\");                               System.out.println(backwards);                          should be                           yenwoD nellA                     Exercise 6.9. Write a recursive method called power that takes a double x                                                        n                    and an integer n and that returns x .                                                                    n                    Hint: a recursive deﬁnition of this operation is x = x·x n−1 . Also, remember                    that anything raised to the zeroeth power is 1.","74                                           Chapter 6. Value methods                               Optional challenge: you can make this method more eﬃcient, when n is even,                                                2                                    n                             using x = x   n/2  .                             Exercise 6.10. (This exercise is based on page 44 of Ableson and Sussman’s                             Structure and Interpretation of Computer Programs.)                              The following technique is known as Euclid’s Algorithm because it appears                             in Euclid’s Elements (Book 7, ca. 300 BC). It may be the oldest nontrivial                                       1                             algorithm .                             The process is based on the observation that, if r is the remainder when a                             is divided by b, then the common divisors of a and b are the same as the                             common divisors of b and r. Thus we can use the equation                                                           gcd(a, b) = gcd(b, r)                              to successively reduce the problem of computing a GCD to the problem of                             computing the GCD of smaller and smaller pairs of integers. For example,                                           gcd(36, 20) = gcd(20, 16) = gcd(16, 4) = gcd(4, 0) = 4                              implies that the GCD of 36 and 20 is 4. It can be shown that for any two                             starting numbers, this repeated reduction eventually produces a pair where                             the second number is 0. Then the GCD is the other number in the pair.                              Write a method called gcd that takes two integer parameters and that uses                             Euclid’s algorithm to compute and return the greatest common divisor of the                             two numbers.                                                  1 For a deﬁnition of “algorithm”, jump ahead to Section 11.13.","Chapter 7                         Iteration and loops                           7.1      Multiple assignment                      You can make more than one assignment to the same variable; the eﬀect is                    to replace the old value with the new.                         int liz = 5;                         System.out.print(liz);                         liz = 7;                         System.out.println(liz);                    The output of this program is 57, because the ﬁrst time we print liz her                    value is 5, and the second time her value is 7.                     This kind of multiple assignment is the reason I described variables as a                    container for values. When you assign a value to a variable, you change the                    contents of the container, as shown in the ﬁgure:                      int liz = 5;              liz  5                      liz = 7;                  liz  5  7                     When there are multiple assignments to a variable, it is especially important                    to distinguish between an assignment statement and a statement of equality.                    Because Java uses the = symbol for assignment, it is tempting to interpret a                    statement like a = b as a statement of equality. It is not!","76                                      Chapter 7. Iteration and loops                               First of all, equality is commutative, and assignment is not. For example, in                             mathematics if a = 7 then 7 = a. But in Java a = 7; is a legal assignment                             statement, and 7 = a; is not.                              Furthermore, in mathematics, a statement of equality is true for all time. If                             a = b now, then a will always equal b. In Java, an assignment statement can                             make two variables equal, but they don’t have to stay that way!                                  int a = 5;                                  int b = a;        // a and b are now equal                                  a = 3;            // a and b are no longer equal                             The third line changes the value of a but it does not change the value of b, so                             they are no longer equal. In some programming languages a diﬀerent symbol                             is used for assignment, such as <- or :=, to avoid this confusion.                             Although multiple assignment is frequently useful, you should use it with                             caution. If the values of variables change often, it can make the code diﬃcult                             to read and debug.                                7.2      The while statement                               Computers are often used to automate repetitive tasks. Repeating tasks                             without making errors is something that computers do well and people do                             poorly.                              We have already seen methods like countdown and factorial that use re-                             cursion to perform repetition. This process is also called iteration. Java                             provides language features that make it easier to write these methods. In                             this chapter we are going to look at the while statement. Later on (in                             Section 12.4) will check out the for statement.                              Using a while statement, we can rewrite countdown:                                public static void countdown(int n) {                                  while (n > 0) {                                    System.out.println(n);                                    n = n-1;                                  }                                  System.out.println(\"Blastoff!\");                               }","7.2. The while statement                                                   77                      You can almost read a while statement like English. What this means is,                    “While n is greater than zero, print the value of n and then reduce the value                    of n by 1. When you get to zero, print the word ‘Blastoﬀ!”’                     More formally, the ﬂow of execution for a while statement is as follows:                         1. Evaluate the condition in parentheses, yielding true or false.                        2. If the condition is false, exit the while statement and continue execu-                          tion at the next statement.                        3. If the condition is true, execute the statements between the squiggly-                          brackets, and then go back to step 1.                     This type of ﬂow is called a loop because the third step loops back around                    to the top. The statements inside the loop are called the body of the loop.                    If the condition is false the ﬁrst time through the loop, the statements inside                    the loop are never executed.                      The body of the loop should change the value of one or more variables so                    that, eventually, the condition becomes false and the loop terminates. Oth-                    erwise the loop will repeat forever, which is called an inﬁnite loop. An                    endless source of amusement for computer scientists is the observation that                    the directions on shampoo, “Lather, rinse, repeat,” are an inﬁnite loop.                     In the case of countdown, we can prove that the loop terminates if n is                    positive. In other cases it is not so easy to tell:                       public static void sequence(int n) {                         while (n != 1) {                           System.out.println(n);                           if (n%2 == 0) {                 // n is even                              n = n / 2;                           } else {                        // n is odd                              n = n*3 + 1;                           }                         }                      }                     The condition for this loop is n != 1, so the loop will continue until n is 1,                    which will make the condition false.","78                                      Chapter 7. Iteration and loops                               At each iteration, the program prints the value of n and then checks whether                             it is even or odd. If it is even, the value of n is divided by two. If it is odd, the                             value is replaced by 3n + 1. For example, if the starting value (the argument                             passed to sequence) is 3, the resulting sequence is 3, 10, 5, 16, 8, 4, 2, 1.                              Since n sometimes increases and sometimes decreases, there is no obvious                             proof that n will ever reach 1, or that the program will terminate. For some                             particular values of n, we can prove termination. For example, if the starting                             value is a power of two, then the value of n will be even every time through                             the loop, until we get to 1. The previous example ends with such a sequence,                             starting with 16.                              Particular values aside, the interesting question is whether we can prove that                             this program terminates for all values of n. So far, no one has been able to                             prove it or disprove it! For more information, see http://en.wikipedia.                             org/wiki/Collatz_conjecture.                                7.3      Tables                               One of the things loops are good for is generating and printing tabular data.                             For example, before computers were readily available, people had to calculate                             logarithms, sines and cosines, and other common mathematical functions by                             hand.                             To make that easier, there were books containing long tables where you                             could ﬁnd the values of various functions. Creating these tables was slow                             and boring, and the results were full of errors.                              When computers appeared on the scene, one of the initial reactions was,                             “This is great! We can use the computers to generate the tables, so there                             will be no errors.” That turned out to be true (mostly), but shortsighted.                             Soon thereafter computers were so pervasive that the tables became obsolete.                              Well, almost. For some operations, computers use tables of values to get an                             approximate answer, and then perform computations to improve the approxi-                             mation. In some cases, there have been errors in the underlying tables, most                             famously in the table the original Intel Pentium used to perform ﬂoating-                                           1                             point division .                               1 See http://en.wikipedia.org/wiki/Pentium_FDIV_bug.","7.3. Tables                                                                79                      Although a “log table” is not as useful as it once was, it still makes a good                    example of iteration. The following program prints a sequence of values in                    the left column and their logarithms in the right column:                          double x = 1.0;                         while (x < 10.0) {                           System.out.println(x + \"         \" + Math.log(x));                           x = x + 1.0;                         }                    The output of this program is                     1.0    0.0                    2.0    0.6931471805599453                    3.0    1.0986122886681098                    4.0    1.3862943611198906                    5.0    1.6094379124341003                    6.0    1.791759469228055                    7.0    1.9459101490553132                    8.0    2.0794415416798357                    9.0    2.1972245773362196                    Looking at these values, can you tell what base the log method uses?                     Since powers of two are important in computer science, we often want loga-                    rithms with respect to base 2. To compute them, we can use the formula:                                                 log x = log e x/log e 2                                                    2                    Changing the print statement to                           System.out.println(x + \"         \" + Math.log(x) / Math.log(2.0));                     yields                    1.0    0.0                    2.0    1.0                    3.0    1.5849625007211563                    4.0    2.0                    5.0    2.321928094887362                    6.0    2.584962500721156                    7.0    2.807354922057604                    8.0    3.0                    9.0    3.1699250014423126","80                                      Chapter 7. Iteration and loops                               We can see that 1, 2, 4 and 8 are powers of two, because their logarithms base                             2 are round numbers. If we wanted to ﬁnd the logarithms of other powers of                             two, we could modify the program like this:                                   double x = 1.0;                                  while (x < 100.0) {                                    System.out.println(x + \"         \" + Math.log(x) / Math.log(2.0));                                    x = x * 2.0;                                  }                             Now instead of adding something to x each time through the loop, which                             yields an arithmetic sequence, we multiply x by something, yielding a geo-                             metric sequence. The result is:                             1.0    0.0                             2.0    1.0                             4.0    2.0                             8.0    3.0                             16.0    4.0                             32.0    5.0                             64.0    6.0                             Log tables may not be useful any more, but for computer scientists, knowing                             the powers of two is! When you have an idle moment, you should memorize                                                                     16                             the powers of two up to 65536 (that’s 2 ).                               7.4      Two-dimensional tables                               A two-dimensional table consists of rows and columns that make it easy to                             ﬁnd values at the intersections. A multiplication table is a good example.                             Let’s say you want to print a multiplication table for the values from 1 to 6.                              A good way to start is to write a simple loop that prints the multiples of 2,                             all on one line.                                  int i = 1;                                  while (i <= 6) {                                    System.out.print(2*i + \"         \");                                    i = i + 1;                                  }                                  System.out.println(\"\");","7.5. Encapsulation and generalization                                      81                      The ﬁrst line initializes a variable named i, which is going to act as a counter,                    or loop variable. As the loop executes, the value of i increases from 1 to                    6; when i is 7, the loop terminates. Each time through the loop, we print                    the value 2*i and three spaces. Since we use System.out.print, the output                    appears on a single line.                     In some environments the output from print gets stored without being dis-                    played until println is invoked. If the program terminates, and you forget                    to invoke println, you may never see the stored output.                     The output of this program is:                     2    4    6    8   10     12                    So far, so good. The next step is to encapsulate and generalize.                        7.5      Encapsulation and generalization                     Encapsulation means taking a piece of code and wrapping it up in a method,                    allowing you to take advantage of all the things methods are good for. We                    have seen two examples of encapsulation, when we wrote printParity in                    Section 4.3 and isSingleDigit in Section 6.7.                     Generalization means taking something speciﬁc, like printing multiples of 2,                    and making it more general, like printing the multiples of any integer.                     Here’s a method that encapsulates the loop from the previous section and                    generalizes it to print multiples of n.                       public static void printMultiples(int n) {                         int i = 1;                         while (i <= 6) {                           System.out.print(n*i + \"         \");                           i = i + 1;                         }                         System.out.println(\"\");                      }                    To encapsulate, all I had to do was add the ﬁrst line, which declares the                    name, parameter, and return type. To generalize, all I had to do was replace                    the value 2 with the parameter n.","82                                      Chapter 7. Iteration and loops                               If I invoke this method with the argument 2, I get the same output as before.                             With argument 3, the output is:                             3    6    9    12    15    18                             and with argument 4, the output is                              4    8    12    16    20    24                             By now you can probably guess how we are going to print a multiplication                             table: we’ll invoke printMultiples repeatedly with diﬀerent arguments. In                             fact, we are going to use another loop to iterate through the rows.                                  int i = 1;                                  while (i <= 6) {                                    printMultiples(i);                                    i = i + 1;                                  }                             First of all, notice how similar this loop is to the one inside printMultiples.                             All I did was replace the print statement with a method invocation.                              The output of this program is                             1    2    3    4   5    6                             2    4    6    8   10     12                             3    6    9    12    15    18                             4    8    12    16    20    24                             5    10    15    20    25    30                             6    12    18    24    30    36                             which is a (slightly sloppy) multiplication table. If the sloppiness bothers                             you, Java provides methods that give you more control over the format of                             the output, but I’m not going to get into that here.                                 7.6      Methods and encapsulation                               In Section 3.5 I listed some of the reasons methods are useful. Here are                             several more:                                   By giving a name to a sequence of statements, you make your program                                   easier to read and debug.","7.7. Local variables                                                       83                          Dividing a long program into methods allows you to separate parts of                          the program, debug them in isolation, and then compose them into a                          whole.                         Methods facilitate both recursion and iteration.                          Well-designed methods are often useful for many programs. Once you                          write and debug one, you can reuse it.                      To demonstrate encapsulation again, I’ll take the code from the previous                    section and wrap it up in a method:                      public static void printMultTable() {                         int i = 1;                         while (i <= 6) {                           printMultiples(i);                           i = i + 1;                         }                      }                     The development process I am demonstrating is called encapsulation and                    generalization. You start by adding code to main or another method.                    When you get it working, you extract it and wrap it up in a method. Then                    you generalize the method by adding parameters.                     Sometimes you don’t know when you start writing exactly how to divide the                    program into methods. This process lets you design as you go along.                        7.7      Local variables                      You might wonder how we can use the same variable i in both                    printMultiples and printMultTable. Didn’t I say that you can only de-                    clare a variable once? And doesn’t it cause problems when one of the methods                    changes the value of the variable?                     The answer to both questions is “no,” because the i in printMultiples and                    the i in printMultTable are not the same variable. They have the same                    name, but they do not refer to the same storage location, and changing the                    value of one has no eﬀect on the other.","84                                      Chapter 7. Iteration and loops                               Variables declared inside a method deﬁnition are called local variables be-                             cause they only exist inside the method. You cannot access a local variable                             from outside its “home” method, and you are free to have multiple variables                             with the same name, as long as they are not in the same method.                              Although it can be confusing, there are good reasons to reuse names. For                             example, it is common to use the names i, j and k as loop variables. If you                             avoid using them in one method just because you used them somewhere else,                             you make the program harder to read.                                7.8      More generalization                               As another example of generalization, imagine you wanted a program that                             would print a multiplication table of any size, not just the 6x6 table. You                             could add a parameter to printMultTable:                               public static void printMultTable(int high) {                                  int i = 1;                                  while (i <= high) {                                    printMultiples(i);                                    i = i + 1;                                  }                               }                             I replaced the value 6 with the parameter high. If I invoke printMultTable                             with the argument 7, I get                             1    2    3    4   5    6                             2    4    6    8   10     12                             3    6    9    12    15    18                             4    8    12    16    20    24                             5    10    15    20    25    30                             6    12    18    24    30    36                             7    14    21    28    35    42                             which is ﬁne, except that I probably want the table to be square (same                             number of rows and columns), which means I have to add another parameter                             to printMultiples, to specify how many columns the table should have.                              I also call this parameter high, demonstrating that diﬀerent methods can                             have parameters with the same name (just like local variables):","7.8. More generalization                                                   85                        public static void printMultiples(int n, int high) {                         int i = 1;                         while (i <= high) {                           System.out.print(n*i + \"         \");                           i = i + 1;                         }                         System.out.println(\"\");                      }                       public static void printMultTable(int high) {                         int i = 1;                         while (i <= high) {                           printMultiples(i, high);                           i = i + 1;                         }                      }                     Notice that when I added a new parameter, I had to change the ﬁrst line, and I                    also had to change the place where the method is invoked in printMultTable.                    As expected, this program generates a square 7x7 table:                    1    2    3    4   5    6    7                    2    4    6    8   10     12    14                    3    6    9    12    15    18    21                    4    8    12    16    20    24    28                    5    10    15    20    25    30    35                    6    12    18    24    30    36    42                    7    14    21    28    35    42    49                     When you generalize a method appropriately, you often ﬁnd that it has ca-                    pabilities you did not plan. For example, you might notice that the multi-                    plication table is symmetric, because ab = ba, so all the entries in the table                    appear twice. You could save ink by printing only half the table. To do that,                    you only have to change one line of printMultTable. Change                           printMultiples(i, high);                     to                           printMultiples(i, i);                    and you get","86                                      Chapter 7. Iteration and loops                               1                             2    4                             3    6    9                             4    8    12    16                             5    10    15    20    25                             6    12    18    24    30    36                             7    14    21    28    35    42    49                             I’ll leave it up to you to ﬁgure out how it works.                                  7.9      Glossary                               loop: A statement that executes repeatedly while some condition is satisﬁed.                              inﬁnite loop: A loop whose condition is always true.                               body: The statements inside the loop.                              iteration: One pass through (execution of) the body of the loop, including                                   the evaluation of the condition.                               encapsulate: To divide a large complex program into components (like                                   methods) and isolate the components from each other (for example,                                   by using local variables).                               local variable: A variable that is declared inside a method and that exists                                   only within that method. Local variables cannot be accessed from out-                                   side their home method, and do not interfere with any other methods.                               generalize: To replace something unnecessarily speciﬁc (like a constant                                   value) with something appropriately general (like a variable or param-                                   eter). Generalization makes code more versatile, more likely to be                                   reused, and sometimes even easier to write.                               program development: A process for writing programs. So far we have                                   seen “incremental development” and “encapsulation and generaliza-                                   tion”.","7.10. Exercises                                                            87                     7.10       Exercises                      Exercise 7.1. Consider the following code:                    public static void main(String[] args) {                         loop(10);                    }                      public static void loop(int n) {                         int i = n;                         while (i > 0) {                              System.out.println(i);                              if (i%2 == 0) {                                   i = i/2;                              } else {                                   i = i+1;                              }                         }                    }                       1. Draw a table that shows the value of the variables i and n during                          the execution of loop. The table should contain one column for each                          variable and one line for each iteration.                        2. What is the output of this program?                     Exercise 7.2. Let’s say you are given a number, a, and you want to ﬁnd its                    square root. One way to do that is to start with a very rough guess about                    the answer, x 0 , and then improve the guess using the following formula:                                                  x 1 = (x 0 + a/x 0 )/2                     For example, if we want to ﬁnd the square root of 9, and we start with x 0 = 6,                    then x 1 = (6 + 9/6)/2 = 15/4 = 3.75, which is closer.                    We can repeat the procedure, using x 1 to calculate x 2 , and so on. In this                    case, x 2 = 3.075 and x 3 = 3.00091. So that is converging very quickly on the                    right answer(which is 3).                     Write a method called squareRoot that takes a double as a parameter and                    that returns an approximation of the square root of the parameter, using this                    technique. You may not use Math.sqrt.","88                                      Chapter 7. Iteration and loops                               As your initial guess, you should use a/2. Your method should iterate until                             it gets two consecutive estimates that diﬀer by less than 0.0001; in other                             words, until the absolute value of x n − x n−1 is less than 0.0001. You can use                             Math.abs to calculate the absolute value.                              Exercise 7.3. In Exercise 6.9 we wrote a recursive version of power, which                                                                                n                             takes a double x and an integer n and returns x . Now write an iterative                             method to perform the same calculation.                              Exercise 7.4. Section 6.8 presents a recursive method that computes the                             factorial function. Write an iterative version of factorial.                                                                    x                             Exercise 7.5. One way to calculate e is to use the inﬁnite series expansion                                                                       3                                                                               4                                                 x                                                               2                                                e = 1 + x + x /2! + x /3! + x /4! + ...                                                                                    i                             If the loop variable is named i, then the ith term is x /i!.                                1. Write a method called myexp that adds up the ﬁrst n terms of this                                   series. You can use the factorial method from Section 6.8 or your                                   iterative version from the previous exercise.                                 2. You can make this method much more eﬃcient if you realize that in                                   each iteration the numerator of the term is the same as its predecessor                                   multiplied by x and the denominator is the same as its predecessor                                   multiplied by i. Use this observation to eliminate the use of Math.pow                                   and factorial, and check that you still get the same result.                                 3. Write a method called check that takes a single parameter, x, and that                                   prints the values of x, Math.exp(x) and myexp(x) for various values of                                   x. The output should look something like:                                    1.0      2.708333333333333             2.718281828459045                                    HINT: you can use the String \"\\t\" to print a tab character between                                   columns of a table.                                 4. Vary the number of terms in the series (the second argument that check                                   sends to myexp) and see the eﬀect on the accuracy of the result. Adjust                                   this value until the estimated value agrees with the “correct” answer                                   when x is 1.","7.10. Exercises                                                            89                         5. Write a loop in main that invokes check with the values 0.1, 1.0, 10.0,                          and 100.0. How does the accuracy of the result vary as x varies? Com-                          pare the number of digits of agreement rather than the diﬀerence be-                          tween the actual and estimated values.                        6. Add a loop in main that checks myexp with the values -0.1, -1.0, -10.0,                          and -100.0. Comment on the accuracy.                                                                   2                    Exercise 7.6. One way to evaluate exp(−x ) is to use the inﬁnite series                    expansion                                                              4                                                         2                                                                      6                                              2                                       exp(−x ) = 1 − x + x /2 − x /6 + . . .                    In other words, we need to add up a series of terms where the ith term is                                  i 2i                    equal to (−1) x /i!. Write a method named gauss that takes x and n as                    arguments and that returns the sum of the ﬁrst n terms of the series. You                    should not use factorial or pow.","90                                      Chapter 7. Iteration and loops","Chapter 8                         Strings and things                           8.1      Characters                      In Java and other object-oriented languages, objects are collections of re-                    lated data that come with a set of methods. These methods operate on                    the objects, performing computations and sometimes modifying the object’s                    data.                    Strings are objects, so you might ask “What is the data contained in a                    String object?” and “What are the methods we can invoke on String ob-                    jects?” The components of a String object are letters or, more generally,                    characters. Not all characters are letters; some are numbers, symbols, and                    other things. For simplicity I call them all letters. There are many meth-                    ods, but I use only a few in this book. The rest are documented at http:                    //download.oracle.com/javase/6/docs/api/java/lang/String.html.                     The ﬁrst method we will look at is charAt, which allows you to extract letters                    from a String. char is the variable type that can store individual characters                    (as opposed to strings of them).                     chars work just like the other types we have seen:                         char ltr = 'c';                         if (ltr == 'c') {                           System.out.println(ltr);                         }","92                                       Chapter 8. Strings and things                               Character values appear in single quotes, like ’c’. Unlike string values                             (which appear in double quotes), character values can contain only a sin-                             gle letter or symbol.                              Here’s how the charAt method is used:                                   String fruit = \"banana\";                                  char letter = fruit.charAt(1);                                  System.out.println(letter);                              fruit.charAt() means that I am invoking the charAt method on the object                             named fruit. I am passing the argument 1 to this method, which means                             that I want to know the ﬁrst letter of the string. The result is a character,                             which is stored in a char named letter. When I print the value of letter,                             I get a surprise:                              a                             a is not the ﬁrst letter of \"banana\". Unless you are a computer scientist.                             For technical reasons, computer scientists start counting from zero. The 0th                             letter (“zeroeth”) of \"banana\" is b. The 1th letter (“oneth”) is a and the                             2th (“twooth”) letter is n.                              If you want the zereoth letter of a string, you have to pass 0 as an argument:                                   char letter = fruit.charAt(0);                                8.2      Length                               The next String method we’ll look at is length, which returns the number                             of characters in the string. For example:                                   int length = fruit.length();                             length takes no arguments and returns an integer, in this case 6. Notice                             that it is legal to have a variable with the same name as a method (although                             it can be confusing for human readers).                             To ﬁnd the last letter of a string, you might be tempted to try something                             like                                   int length = fruit.length();                                  char last = fruit.charAt(length);                // WRONG!!","8.3. Traversal                                                             93                      That won’t work. The reason is that there is no 6th letter in \"banana\".                    Since we started counting at 0, the 6 letters are numbered from 0 to 5. To                    get the last character, you have to subtract 1 from length.                          int length = fruit.length();                         char last = fruit.charAt(length-1);                      8.3      Traversal                      A common thing to do with a string is start at the beginning, select each                    character in turn, do some computation with it, and continue until the end.                    This pattern of processing is called a traversal. A natural way to encode a                    traversal is with a while statement:                         int index = 0;                         while (index < fruit.length()) {                              char letter = fruit.charAt(index);                              System.out.println(letter);                              index = index + 1;                         }                     This loop traverses the string and prints each letter on a line by itself. Notice                    that the condition is index < fruit.length(), which means that when                    index is equal to the length of the string, the condition is false and the body                    of the loop is not executed. The last character we access is the one with the                    index fruit.length()-1.                     The name of the loop variable is index. An index is a variable or value used                    to specify a member of an ordered set, in this case the string of characters.                    The index indicates (hence the name) which one you want.                        8.4      Run-time errors                     Way back in Section 1.3.2 I talked about run-time errors, which are errors                    that don’t appear until a program has started running. In Java run-time                    errors are called exceptions.                     You probably haven’t seen many run-time errors, because we haven’t been do-                    ing many things that can cause one. Well, now we are. If you use the charAt","94                                       Chapter 8. Strings and things                               method and provide an index that is negative or greater than length-1, it                             throws an exception. You can think of “throwing” an exception like throw-                             ing a tantrum.                               When that happens, Java prints an error message with the type of exception                             and a stack trace, which shows the methods that were running when the                             exception occurred. Here is an example:                              public class BadString {                                   public static void main(String[] args) {                                       processWord(\"banana\");                                  }                                   public static void processWord(String s) {                                       char c = getLastLetter(s);                                       System.out.println(c);                                  }                                    public static char getLastLetter(String s) {                                       int index = s.length();                // WRONG!                                       char c = s.charAt(index);                                       return c;                                  }                             }                              Notice the error in getLastLetter: the index of the last character should                             be s.length()-1. Here’s what you get:                               Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException:                             String index out of range: 6                                       at java.lang.String.charAt(String.java:694)                                       at BadString.getLastLetter(BadString.java:24)                                       at BadString.processWord(BadString.java:18)                                       at BadString.main(BadString.java:14)                               Then the program ends. The stack trace can be hard to read, but it contains                             a lot of information.","8.5. Reading documentation                                                 95                     8.5      Reading documentation                      If you go to http://download.oracle.com/javase/6/docs/api/java/                    lang/String.html. and click on charAt, you get the following documenta-                    tion (or something like it):                    public char charAt(int index)                      Returns the char value at the specified index. An index ranges                    from 0 to length() - 1. The first char value of the sequence is                    at index 0, the next at index 1, and so on, as for array indexing.                     Parameters: index - the index of the char value.                      Returns: the char value at the specified index of this string.                      The first char value is at index 0.                      Throws: IndexOutOfBoundsException - if the index argument is                      negative or not less than the length of this string.                     The ﬁrst line is the method’s prototype, which speciﬁes the name of the                    method, the type of the parameters, and the return type.                     The next line describes what the method does. The following lines explain the                    parameters and return values. In this case the explanations are redundant,                    but the documentation is supposed to ﬁt a standard format. The last line                    describes the exceptions this method might throw.                     It might take some time to get comfortable with this kind of documentation,                    but it is worth the eﬀort.                        8.6      The indexOf method                      indexOf is the inverse of charAt: charAt takes an index and returns the                    character at that index; indexOf takes a character and ﬁnds the index where                    that character appears.                     charAt fails if the index is out of range, and throws an exception. indexOf                    fails if the character does not appear in the string, and returns the value -1.","96                                       Chapter 8. Strings and things                                    String fruit = \"banana\";                                  int index = fruit.indexOf('a');                             This ﬁnds the index of the letter ’a’ in the string. In this case, the letter                             appears three times, so it is not obvious what indexOf should do. According                             to the documentation, it returns the index of the ﬁrst appearance.                              To ﬁnd subsequent appearances, there is another version of indexOf. It takes                             a second argument that indicates where in the string to start looking. For                             an explanation of this kind of overloading, see Section 6.4.                              If we invoke:                                  int index = fruit.indexOf('a', 2);                              it starts at the twoeth letter (the ﬁrst n) and ﬁnds the second a, which is at                             index 3. If the letter happens to appear at the starting index, the starting                             index is the answer. So                                   int index = fruit.indexOf('a', 5);                             returns 5.                                  8.7      Looping and counting                               The following program counts the number of times the letter ’a’ appears in                             a string:                                  String fruit = \"banana\";                                  int length = fruit.length();                                  int count = 0;                                    int index = 0;                                  while (index < length) {                                       if (fruit.charAt(index) == 'a') {                                            count = count + 1;                                       }                                       index = index + 1;                                  }                                  System.out.println(count);","8.8. Increment and decrement operators                                     97                      This program demonstrates a common idiom, called a counter. The variable                    count is initialized to zero and then incremented each time we ﬁnd an ’a’.                    To increment is to increase by one; it is the opposite of decrement. When                    we exit the loop, count contains the result: the total number of a’s.                       8.8      Increment and decrement operators                      Incrementing and decrementing are such common operations that Java pro-                    vides special operators for them. The ++ operator adds one to the cur-                    rent value of an int or char. -- subtracts one. Neither operator works on                    doubles, booleans or Strings.                    Technically, it is legal to increment a variable and use it in an expression at                    the same time. For example, you might see something like:                         System.out.println(i++);                    Looking at this, it is not clear whether the increment will take eﬀect before or                    after the value is printed. Because expressions like this tend to be confusing,                    I discourage you from using them. In fact, to discourage you even more, I’m                    not going to tell you what the result is. If you really want to know, you can                    try it.                    Using the increment operators, we can rewrite the letter-counter:                          int index = 0;                         while (index < length) {                           if (fruit.charAt(index) == 'a') {                              count++;                           }                           index++;                         }                    It is a common error to write something like                         index = index++;                   // WRONG!!                    Unfortunately, this is syntactically legal, so the compiler will not warn you.                    The eﬀect of this statement is to leave the value of index unchanged. This                    is often a diﬃcult bug to track down.                     Remember, you can write index = index+1, or you can write index++, but                    you shouldn’t mix them.","98                                       Chapter 8. Strings and things                              8.9      Strings are immutable                               As you read the documentation of the String methods, you might notice                             toUpperCase and toLowerCase. These methods are often a source of confu-                             sion, because it sounds like they have the eﬀect of changing (or mutating) an                             existing string. Actually, neither these methods nor any others can change a                             string, because strings are immutable.                              When you invoke toUpperCase on a String, you get a new String as a                             return value. For example:                                   String name = \"Alan Turing\";                                  String upperName = name.toUpperCase();                             After the second line is executed, upperName contains the value \"ALAN                             TURING\", but name still contains \"Alan Turing\".                                 8.10       Strings are incomparable                               It is often necessary to compare strings to see if they are the same, or to see                             which comes ﬁrst in alphabetical order. It would be nice if we could use the                             comparison operators, like == and >, but we can’t.                              To compare Strings, we have to use the equals and compareTo methods.                             For example:                                  String name1 = \"Alan Turing\";                                  String name2 = \"Ada Lovelace\";                                    if (name1.equals (name2)) {                                    System.out.println(\"The names are the same.\");                                  }                                   int flag = name1.compareTo (name2);                                  if (flag == 0) {                                    System.out.println(\"The names are the same.\");                                  } else if (flag < 0) {                                    System.out.println(\"name1 comes before name2.\");                                  } else if (flag > 0) {","8.11. Glossary                                                             99                             System.out.println(\"name2 comes before name1.\");                         }                    The syntax here is a little weird. To compare two Strings, you have to                    invoke a method on one of them and pass the other as an argument.                    The return value from equals is straightforward enough; true if the strings                    contain the same characters, and false otherwise.                     The return value from compareTo is a weird, too. It is the diﬀerence between                    the ﬁrst characters in the strings that diﬀer. If the strings are equal, it is 0.                    If the ﬁrst string (the one on which the method is invoked) comes ﬁrst in the                    alphabet, the diﬀerence is negative. Otherwise, the diﬀerence is positive. In                    this case the return value is positive 8, because the second letter of “Ada”                    comes before the second letter of “Alan” by 8 letters.                     Just for completeness, I should admit that it is legal, but very seldom correct,                    to use the == operator with Strings. I explain why in Section 13.4; for now,                    don’t do it.                       8.11       Glossary                      object: A collection of related data that comes with a set of methods that                          operate on it. The objects we have used so far are Strings, Bugs,                          Rocks, and the other GridWorld objects.                     index: A variable or value used to select one of the members of an ordered                          set, like a character from a string.                     exception: A run-time error.                     throw: Cause an exception.                     stack trace: A report that shows the state of a program when an exception                          occurs.                     prototype: The ﬁrst line of a method, which speciﬁes the name, parameters                          and return type.                     traverse: To iterate through all the elements of a set performing a similar                          operation on each.","100                                      Chapter 8. Strings and things                               counter: A variable used to count something, usually initialized to zero and                                   then incremented.                             increment: Increase the value of a variable by one. The increment operator                                   in Java is ++.                              decrement: Decrease the value of a variable by one. The decrement oper-                                   ator in Java is --.                                8.12       Exercises                               Exercise 8.1. Write a method that takes a String as an argument and that                             prints the letters backwards all on one line.                              Exercise 8.2. Read the stack trace in Section 8.4 and answer these ques-                             tions:                                  What kind of Exception occurred, and what package is it deﬁned in?                                  What is the value of the index that caused the exception?                                  What method threw the exception, and where is that method deﬁned?                                  What method invoked charAt?                                  In BadString.java, what is the line number where charAt was in-                                   voked?                              Exercise 8.3. Encapsulate the code in Section 8.7 in a method named                             countLetters, and generalize it so that it accepts the string and the let-                             ter as arguments.                              Then rewrite the method so that it uses indexOf to locate the a’s, rather                             than checking the characters one by one.                              Exercise 8.4. The purpose of this exercise is to review encapsulation and                             generalization.                                 1. Encapsulate the following code fragment, transforming it into a method                                   that takes a String as an argument and that returns the ﬁnal value of                                   count.","8.12. Exercises                                                          101                         2. In a sentence or two, describe what the resulting method does (without                          getting into the details of how).                        3. Now that you have generalized the code so that it works on any String,                          what could you do to generalize it more?                          String s = \"((3 + 7) * 2)\";                         int len = s.length();                           int i = 0;                         int count = 0;                          while (i < len) {                              char c = s.charAt(i);                                if (c == '(') {                                 count = count + 1;                              } else if (c == ')') {                                 count = count - 1;                              }                              i = i + 1;                         }                           System.out.println(count);                    Exercise 8.5. The point of this exercise is to explore Java types and ﬁll in                    some of the details that aren’t covered in the chapter.                         1. Create a new program named Test.java and write a main method that                          contains expressions that combine various types using the + operator.                          For example, what happens when you “add” a String and a char?                          Does it perform addition or concatenation? What is the type of the                          result? (How can you determine the type of the result?)                        2. Make a bigger copy of the following table and ﬁll it in. At the intersec-                          tion of each pair of types, you should indicate whether it is legal to use                          the + operator with these types, what operation is performed (addition                          or concatenation), and what the type of the result is.","102                                      Chapter 8. Strings and things                                                boolean   char int String                                    boolean                                    char                                    int                                    String                                 3. Think about some of the choices the designers of Java made when they                                   ﬁlled in this table. How many of the entries seem unavoidable, as if                                   there were no other choice? How many seem like arbitrary choices from                                   several equally reasonable possibilities? How many seem problematic?                                 4. Here’s a puzzler: normally, the statement x++ is exactly equivalent to                                   x = x + 1. But if x is a char, it’s not! In that case, x++ is legal, but                                   x = x + 1 causes an error. Try it out and see what the error message                                   is, then see if you can ﬁgure out what is going on.                              Exercise 8.6. What is the output of this program? Describe in a sentence                             what mystery does (not how it works).                              public class Mystery {                                   public static String mystery(String s) {                                       int i = s.length() - 1;                                       String total = \"\";                                         while (i >= 0 ) {                                            char ch = s.charAt(i);                                            System.out.println(i + \"           \" + ch);                                              total = total + ch;                                            i--;                                       }                                       return total;                                  }                                    public static void main(String[] args) {                                       System.out.println(mystery(\"Allen\"));                                  }                             }","8.12. Exercises                                                          103                      Exercise 8.7. A friend of yours shows you the following method and explains                    that if number is any two-digit number, the program will output the number                    backwards. He claims that if number is 17, the method will output 71.                     Is he right? If not, explain what the program actually does and modify it so                    that it does the right thing.                           int number = 17;                          int lastDigit = number%10;                          int firstDigit = number/10;                          System.out.println(lastDigit + firstDigit);                     Exercise 8.8. What is the output of the following program?                    public class Enigma {                           public static void enigma(int x) {                              if (x == 0) {                                   return;                              } else {                                   enigma(x/2);                              }                                System.out.print(x%2);                         }                          public static void main(String[] args) {                              enigma(5);                              System.out.println(\"\");                         }                    }                    Explain in 4-5 words what the method enigma really does.                     Exercise 8.9.     1. Create a new program named Palindrome.java.                         2. Write a method named first that takes a String and returns the ﬁrst                          letter, and one named last that returns the last letter.                         3. Write a method named middle that takes a String and returns a sub-                          string that contains everything except the ﬁrst and last characters.","104                                      Chapter 8. Strings and things                                     Hint: read the documentation of the substring method in the String                                   class. Run a few tests to make sure you understand how substring                                   works before you try to write middle.                                    What happens if you invoke middle on a string that has only two                                   letters? One letter? No letters?                                 4. The usual deﬁnition of a palindrome is a word that reads the same                                   both forward and backward, like “otto” and “palindromeemordnilap.”                                   An alternative way to deﬁne a property like this is to specify a way of                                   testing for the property. For example, we might say, “a single letter is                                   a palindrome, and a two-letter word is a palindrome if the letters are                                   the same, and any other word is a palindrome if the ﬁrst letter is the                                   same as the last and the middle is a palindrome.”                                    Write a recursive method named isPalindrome that takes a String                                   and that returns a boolean indicating whether the word is a palindrome                                   or not.                                 5. Once you have a working palindrome checker, look for ways to simplify                                   it by reducing the number of conditions you check. Hint: it might be                                   useful to adopt the deﬁnition that the empty string is a palindrome.                                 6. On a piece of paper, ﬁgure out a strategy for checking palindromes                                   iteratively. There are several possible approaches, so make sure you                                   have a solid plan before you start writing code.                                 7. Implement your strategy in a method called isPalindromeIter.                                  8. Optional: Appendix B provides code for reading a list of words from a                                   ﬁle. Read a list of words and print the palindromes.                              Exercise 8.10. A word is said to be “abecedarian” if the letters in the                             word appear in alphabetical order. For example, the following are all 6-letter                             English abecedarian words.                                     abdest, acknow, acorsy, adempt, adipsy, agnosy, beﬁst, behint,                                   beknow, bijoux, biopsy, cestuy, chintz, deﬂux, dehors, dehort,                                   deinos, diluvy, dimpsy","8.12. Exercises                                                          105                         1. Describe a process for checking whether a given word (String) is                          abecedarian, assuming that the word contains only lower-case letters.                          Your process can be iterative or recursive.                         2. Implement your process in a method called isAbecedarian.                     Exercise 8.11. A dupledrome is a word that contains only double letters,                    like “llaammaa” or “ssaabb”. I conjecture that there are no dupledromes                    in common English use. To test that conjecture, I would like a program                    that reads words from the dictionary one at a time and checks them for                    dupledromity.                     Write a method called isDupledrome that takes a String and returns a                    boolean indicating whether the word is a dupledrome.                      Exercise 8.12.      1. The Captain Crunch decoder ring works by taking                          each letter in a string and adding 13 to it. For example, ’a’ becomes                          ’n’ and ’b’ becomes ’o’. The letters “wrap around” at the end, so ’z’                          becomes ’m’.                           Write a method that takes a String and that returns a new String                          containing the encoded version. You should assume that the String                          contains upper and lower case letters, and spaces, but no other punc-                          tuation. Lower case letters should be tranformed into other lower case                          letters; upper into upper. You should not encode the spaces.                         2. Generalize the Captain Crunch method so that instead of adding 13                          to the letters, it adds any given amount. Now you should be able to                          encode things by adding 13 and decode them by adding -13. Try it.                      Exercise 8.13. If you did the GridWorld exercises in Chapter 5, you might                    enjoy this exercise. The goal is to use trigonometry to get the Bugs to chase                    each other.                     Make a copy of BugRunner.java named ChaseRunner.java and import it                    into your development environment. Before you change anything, check that                    you can compile and run it.                          Create two Bugs, one red and one blue.","106                                      Chapter 8. Strings and things                                   Write a method called distance that takes two Bugs and computes the                                   distance between them. Remember that you can get the x-coordinate                                   of a Bug like this:                                         int x = bug.getLocation().getCol();                                 Write a method called turnToward that takes two Bugs and turns one                                   to face the other. HINT: use Math.atan2, but remember that the                                   result is in radians, so you have to convert to degrees. Also, for Bugs,                                   0 degress is North, not East.                                  Write a method called moveToward that takes two Bugs, turns the ﬁrst                                   to face the second, and then moves the ﬁrst one, if it can.                                  Write a method called moveBugs that takes two Bugs and an integer                                   n, and moves each Bug toward the other n times. You can write this                                   method recursively, or use a while loop.                                  Test each of your methods as you develop them. When they are all                                   working, look for opportunities to improve them. For example, if you                                   have redundant code in distance and turnToward, you could encap-                                   sulate the repeated code in a method.","Chapter 9                         Mutable objects                           Strings are objects, but they are atypical objects because                          They are immutable.                         They have no attributes.                         You don’t have to use new to create one.                      In this chapter, we use two objects from Java libraries, Point and Rectangle.                    But ﬁrst, I want to make it clear that these points and rectangles are not                    graphical objects that appear on the screen. They are values that contain                    data, just like ints and doubles. Like other values, they are used internally                    to perform computations.                       9.1      Packages                      The Java libraries are divided into packages, including java.lang, which                    contains most of the classes we have used so far, and java.awt, the Ab-                    stract Window Toolkit (AWT), which contains classes for windows, but-                    tons, graphics, etc.                     To use a class deﬁned in another package, you have to import it. Point and                    Rectangle are in the java.awt package, so to import them like this:","108                                         Chapter 9. Mutable objects                                    import java.awt.Point;                                  import java.awt.Rectangle;                             All import statements appear at the beginning of the program, outside the                             class deﬁnition.                             The classes in java.lang, like Math and String, are imported automatically,                             which is why we haven’t needed the import statement yet.                                 9.2      Point objects                               A point is two numbers (coordinates) that we treat collectively as a single                             object. In mathematical notation, points are often written in parentheses,                             with a comma separating the coordinates. For example, (0, 0) indicates the                             origin, and (x, y) indicates the point x units to the right and y units up from                             the origin.                              In Java, a point is represented by a Point object. To create a new point,                             you have to use new:                                  Point blank;                                  blank = new Point(3, 4);                             The ﬁrst line is a conventional variable declaration: blank has type Point.                             The second line invokes new, speciﬁes the type of the new object, and provides                             arguments. The arguments are the coordinates of the new point, (3, 4).                             The result of new is a reference to the new point, so blank contains a                             reference to the newly-created object. There is a standard way to diagram                             this assignment, shown in the ﬁgure.                                               x  3                             blank                                            y  4                                As usual, the name of the variable blank appears outside the box and its                             value appears inside the box. In this case, that value is a reference, which                             is shown graphically with an arrow. The arrow points to the object we’re                             referring to.","9.3. Instance variables                                                  109                      The big box shows the newly-created object with the two values in it. The                    names x and y are the names of the instance variables.                     Taken together, all the variables, values, and objects in a program are called                    the state. Diagrams like this that show the state of the program are called                    state diagrams. As the program runs, the state changes, so you should                    think of a state diagram as a snapshot of a particular point in the execution.                          9.3      Instance variables                      The pieces of data that make up an object are called instance variables                    because each object, which is an instance of its type, has its own copy of                    the instance variables.                     It’s like the glove compartment of a car. Each car is an instance of the type                    “car,” and each car has its own glove compartment. If you ask me to get                    something from the glove compartment of your car, you have to tell me which                    car is yours.                     Similarly, if you want to read a value from an instance variable, you have to                    specify the object you want to get it from. In Java this is done using “dot                    notation.”                         int x = blank.x;                     The expression blank.x means “go to the object blank refers to, and get                    the value of x.” In this case we assign that value to a local variable named                    x. There is no conﬂict between the local variable named x and the instance                    variable named x. The purpose of dot notation is to identify which variable                    you are referring to unambiguously.                      You can use dot notation as part of any Java expression, so the following are                    legal.                          System.out.println(blank.x + \", \" + blank.y);                         int distance = blank.x * blank.x + blank.y * blank.y;                    The ﬁrst line prints 3, 4; the second line calculates the value 25.","110                                         Chapter 9. Mutable objects                              9.4      Objects as parameters                                You can pass objects as parameters in the usual way. For example:                               public static void printPoint(Point p) {                                  System.out.println(\"(\" + p.x + \", \" + p.y + \")\");                               }                             This method takes a point as an argument and prints it in the stan-                             dard format. If you invoke printPoint(blank), it prints (3, 4). Ac-                             tually, Java already has a method for printing Points.         If you invoke                             System.out.println(blank), you get                             java.awt.Point[x=3,y=4]                              This is a standard format Java uses for printing objects. It prints the name                             of the type, followed by the names and values of the instance variables.                               As a second example, we can rewrite the distance method from Section 6.2                             so that it takes two Points as parameters instead of four doubles.                               public static double distance(Point p1, Point p2) {                                  double dx = (double)(p2.x - p1.x);                                  double dy = (double)(p2.y - p1.y);                                  return Math.sqrt(dx*dx + dy*dy);                               }                              The typecasts are not really necessary; I added them as a reminder that the                             instance variables in a Point are integers.                                 9.5      Rectangles                                Rectangles are similar to points, except that they have four instance vari-                             ables: x, y, width and height. Other than that, everything is pretty much                             the same.                               This example creates a Rectangle object and makes box refer to it.                                  Rectangle box = new Rectangle(0, 0, 100, 200);                             This ﬁgure shows the eﬀect of this assignment.","9.6. Objects as return types                                             111                                    x     0      width  100                    box                                 y     0     height  200                       If you print box, you get                    java.awt.Rectangle[x=0,y=0,width=100,height=200]                     Again, this is the result of a Java method that knows how to print Rectangle                    objects.                         9.6      Objects as return types                      You can write methods that return objects. For example, findCenter takes a                    Rectangle as an argument and returns a Point that contains the coordinates                    of the center of the Rectangle:                      public static Point findCenter(Rectangle box) {                         int x = box.x + box.width/2;                         int y = box.y + box.height/2;                         return new Point(x, y);                      }                    Notice that you can use new to create a new object, and then immediately                    use the result as the return value.                         9.7      Objects are mutable                      You can change the contents of an object by making an assignment to one of                    its instance variables. For example, to “move” a rectangle without changing                    its size, you can modify the x and y values:                         box.x = box.x + 50;                         box.y = box.y + 100;                    The result is shown in the ﬁgure:","112                                         Chapter 9. Mutable objects                                             x   50       width  100                             box                                          y 100       height  200                               We can encapsulate this code in a method and generalize it to move the                             rectangle by any amount:                               public static void moveRect(Rectangle box, int dx, int dy) {                                  box.x = box.x + dx;                                  box.y = box.y + dy;                               }                             The variables dx and dy indicate how far to move the rectangle in each                             direction. Invoking this method has the eﬀect of modifying the Rectangle                             that is passed as an argument.                                  Rectangle box = new Rectangle(0, 0, 100, 200);                                  moveRect(box, 50, 100);                                  System.out.println(box);                             prints java.awt.Rectangle[x=50,y=100,width=100,height=200].                              Modifying objects by passing them as arguments to methods can be useful,                             but it can also make debugging more diﬃcult because it is not always clear                             which method invocations do or do not modify their arguments. Later, I                             discuss some pros and cons of this programming style.                              Java provides methods that operate on Points and Rectangles. You can                             read the documentation at http://download.oracle.com/javase/6/docs/                             api/java/awt/Point.html and http://download.oracle.com/javase/6/                             docs/api/java/awt/Rectangle.html.                              For example, translate has the same eﬀect as moveRect, but instead of                             passing the Rectangle as an argument, you use dot notation:                                  box.translate(50, 100);                                9.8      Aliasing                               Remember that when you assign an object to a variable, you are assigning a                             reference to an object. It is possible to have multiple variables that refer to","9.8. Aliasing                                                            113                      the same object. For example, this code:                         Rectangle box1 = new Rectangle(0, 0, 100, 200);                         Rectangle box2 = box1;                     generates a state diagram that looks like this:                       box1           x    0      width 100                     box2           y    0     height 200                       box1 and box2 refer to the same object. In other words, this object has two                    names, box1 and box2. When a person uses two names, it’s called aliasing.                    Same thing with objects.                     When two variables are aliased, any changes that aﬀect one variable also                    aﬀect the other. For example:                          System.out.println(box2.width);                         box1.grow(50, 50);                         System.out.println(box2.width);                    The ﬁrst line prints 100, which is the width of the Rectangle referred to by                    box2. The second line invokes the grow method on box1, which expands the                    Rectangle by 50 pixels in every direction (see the documentation for more                    details). The eﬀect is shown in the ﬁgure:                       box1           x −50       width 200                     box2           y −50      height 300                       Whatever changes are made to box1 also apply to box2. Thus, the value                    printed by the third line is 200, the width of the expanded rectangle. (As an                    aside, it is perfectly legal for the coordinates of a Rectangle to be negative.)                     As you can tell even from this simple example, code that involves aliasing                    can get confusing fast, and can be diﬃcult to debug. In general, aliasing                    should be avoided or used with care.","114                                         Chapter 9. Mutable objects                              9.9      null                               When you create an object variable, remember that you are creating a refer-                             ence to an object. Until you make the variable point to an object, the value                             of the variable is null. null is a special value (and a Java keyword) that                             means “no object.”                              The declaration Point blank; is equivalent to this initialization                                  Point blank = null;                              and is shown in the following state diagram:                              blank                              The value null is represented by a small square with no arrow.                              If you try to use a null object, either by accessing an instance variable or                             invoking a method, Java throws a NullPointerException, prints an error                             message and terminates the program.                                  Point blank = null;                                  int x = blank.x;                     // NullPointerException                                  blank.translate(50, 50);             // NullPointerException                             On the other hand, it is legal to pass a null object as an argument or receive                             one as a return value. In fact, it is common to do so, for example to represent                             an empty set or indicate an error condition.                                 9.10       Garbage collection                               In Section 9.8 we talked about what happens when more than one variable                             refers to the same object. What happens when no variable refers to an                             object? For example:                                  Point blank = new Point(3, 4);                                  blank = null;                              The ﬁrst line creates a new Point object and makes blank refer to it. The                             second line changes blank so that instead of referring to the object, it refers                             to nothing (the null object).","9.11. Objects and primitives                                             115                                      x  3                    blank                                   y  4                       If no one refers to an object, then no one can read or write any of its values,                    or invoke a method on it. In eﬀect, it ceases to exist. We could keep the                    object in memory, but it would only waste space, so periodically as your                    program runs, the system looks for stranded objects and reclaims them, in                    a process called garbage collection. Later, the memory space occupied by                    the object will be available to be used as part of a new object.                     You don’t have to do anything to make garbage collection happen, and in                    general you will not be aware of it. But you should know that it periodically                    runs in the background.                        9.11       Objects and primitives                      There are two kinds of types in Java, primitive types and object types. Prim-                    itives, like int and boolean begin with lower-case letters; object types begin                    with upper-case letters. This distinction is useful because it reminds us of                    some of the diﬀerences between them:                          When you declare a primitive variable, you get storage space for a                          primitive value. When you declare an object variable, you get a space                          for a reference to an object. To get space for the object itself, you have                          to use new.                        If you don’t initialize a primitive type, it is given a default value that                          depends on the type. For example, 0 for ints and false for booleans.                          The default value for object types is null, which indicates no object.                         Primitive variables are well isolated in the sense that there is nothing                          you can do in one method that will aﬀect a variable in another method.                          Object variables can be tricky to work with because they are not as                          well isolated. If you pass a reference to an object as an argument, the                          method you invoke might modify the object, in which case you will see","116                                         Chapter 9. Mutable objects                                     the eﬀect. Of course, that can be a good thing, but you have to be                                   aware of it.                               There is one other diﬀerence between primitives and object types. You can-                             not add new primitives to Java (unless you get yourself on the standards                             committee), but you can create new object types! We’ll see how in the next                             chapter.                                  9.12       Glossary                              package: A collection of classes. Java classes are organized in packages.                               AWT: The Abstract Window Toolkit, one of the biggest and commonly-                                   used Java packages.                               instance: An example from a category. My cat is an instance of the category                                   “feline things.” Every object is an instance of some class.                               instance variable: One of the named data items that make up an object.                                   Each object (instance) has its own copy of the instance variables for its                                   class.                               reference: A value that indicates an object. In a state diagram, a reference                                   appears as an arrow.                               aliasing: The condition when two or more variables refer to the same object.                               garbage collection: The process of ﬁnding objects that have no references                                   and reclaiming their storage space.                              state: A complete description of all the variables and objects and their val-                                   ues, at a given point during the execution of a program.                               state diagram: A snapshot of the state of a program, shown graphically.","9.13. Exercises                                                          117                     9.13       Exercises                      Exercise 9.1.     1. For the following program, draw a stack diagram show-                          ing the local variables and parameters of main and riddle, and show                          any objects those variables refer to.                        2. What is the output of this program?                     public static void main(String[] args)                    {                         int x = 5;                         Point blank = new Point(1, 2);                           System.out.println(riddle(x, blank));                         System.out.println(x);                         System.out.println(blank.x);                         System.out.println(blank.y);                    }                      public static int riddle(int x, Point p)                    {                         x = x + 7;                         return x + p.x + p.y;                    }                     The point of this exercise is to make sure you understand the mechanism for                    passing Objects as parameters.                     Exercise 9.2.     1. For the following program, draw a stack diagram show-                          ing the state of the program just before distance returns. Include all                          variables and parameters and the objects those variables refer to.                        2. What is the output of this program?                    public static double distance(Point p1, Point p2) {                         int dx = p1.x - p2.x;                         int dy = p1.y - p2.y;                         return Math.sqrt(dx*dx + dy*dy);                    }","118                                         Chapter 9. Mutable objects                               public static Point findCenter(Rectangle box) {                                  int x = box.x + box.width/2;                                  int y = box.y + box.height/2;                                  return new Point(x, y);                             }                               public static void main(String[] args) {                                  Point blank = new Point(5, 8);                                   Rectangle rect = new Rectangle(0, 2, 4, 4);                                  Point center = findCenter(rect);                                    double dist = distance(center, blank);                                    System.out.println(dist);                             }                              Exercise 9.3. The method grow is part of the Rectangle class. Read                             the documentation at http://download.oracle.com/javase/6/docs/api/                             java/awt/Rectangle.html#grow(int,int).                                 1. What is the output of the following program?                                 2. Draw a state diagram that shows the state of the program just before                                   the end of main. Include all local variables and the objects they refer                                   to.                                 3. At the end of main, are p1 and p2 aliased? Why or why not?                              public static void printPoint(Point p) {                                  System.out.println(\"(\" + p.x + \", \" + p.y + \")\");                             }                              public static Point findCenter(Rectangle box) {                                  int x = box.x + box.width/2;                                  int y = box.y + box.height/2;                                  return new Point(x, y);                             }","9.13. Exercises                                                          119                      public static void main(String[] args) {                           Rectangle box1 = new Rectangle(2, 4, 7, 9);                         Point p1 = findCenter(box1);                         printPoint(p1);                           box1.grow(1, 1);                         Point p2 = findCenter(box1);                         printPoint(p2);                    }                    Exercise 9.4. You might be sick of the factorial method by now, but we’re                    going to do one more version.                         1. Create a new program called Big.java and write an iterative version                          of factorial.                        2. Print a table of the integers from 0 to 30 along with their factorials.                          At some point around 15, you will probably see that the answers are                          not right any more. Why not?                        3. BigIntegers are Java objects that can represent arbitrarily big in-                          tegers.  There is no upper bound except the limitations of mem-                          ory size and processing speed.     Read the documentation of BigIn-                          tegers at http://download.oracle.com/javase/6/docs/api/java/                          math/BigInteger.html.                        4. To use BigIntegers, you have to add import java.math.BigInteger                          to the beginning of your program.                        5. There are several ways to create a BigInteger, but the one I recommend                          uses valueOf. The following code converts an integer to a BigInteger:                               int x = 17;                               BigInteger big = BigInteger.valueOf(x);                          Type in this code and try it out. Try printing a BigInteger.                        6. Because BigIntegers are not primitive types, the usual math operators                          don’t work. Instead we have to use methods like add. To add two                          BigIntegers, invoke add on one and pass the other as an argument. For                          example:","120                                         Chapter 9. Mutable objects                                          BigInteger small = BigInteger.valueOf(17);                                        BigInteger big = BigInteger.valueOf(1700000000);                                        BigInteger total = small.add(big);                                   Try out some of the other methods, like multiply and pow.                                 7. Convert factorial so that it performs its calculation using BigIntegers                                   and returns a BigInteger as a result. You can leave the parameter                                   alone—it will still be an integer.                                 8. Try printing the table again with your modiﬁed factorial method. Is                                   it correct up to 30? How high can you make it go? I calculated the                                   factorial of all the numbers from 0 to 999, but my machine is pretty                                   slow, so it took a while. The last number, 999!, has 2565 digits.                              Exercise 9.5. Many encryption techniques depend on the ability to raise                             large integers to an integer power. Here is a method that implements a                             (reasonably) fast technique for integer exponentiation:                              public static int pow(int x, int n) {                                  if (n == 0) return 1;                                   // find x to the n/2 recursively                                  int t = pow(x, n/2);                                    // if n is even, the result is t squared                                  // if n is odd, the result is t squared times x                                   if (n%2 == 0) {                                    return t*t;                                  } else {                                    return t*t*x;                                  }                             }                             The problem with this method is that it only works if the result is smaller                             than 2 billion. Rewrite it so that the result is a BigInteger. The parameters                             should still be integers, though.                             You can use the BigInteger methods add and multiply, but don’t use pow,                             which would spoil the fun.","9.13. Exercises                                                          121                      Exercise 9.6. If you are interested in graphics, now is a good time to read                    Appendix A and do the exercises there.","122                                         Chapter 9. Mutable objects","Chapter 10                         GridWorld: Part 2                           Part 2 of the GridWorld case study uses some features we haven’t seen                    yet, so you will get a preview now and more details later.          As a re-                    minder, you can ﬁnd the documentation for the GridWorld classes at http:                    //www.greenteapress.com/thinkapjava/javadoc/gridworld/.                    When you install GridWorld,          you should have a folder named                    projects/boxBug, which contains BoxBug.java, BoxBugRunner.java and                    BoxBug.gif.                     Copy these ﬁles into your working folder and import them into                    your development environment.           There are instructions here that                    might help:    http://www.collegeboard.com/prod_downloads/student/                    testing/ap/compsci_a/ap07_gridworld_installation_guide.pdf.                     Here is the code from BoxBugRunner.java:                     import info.gridworld.actor.ActorWorld;                    import info.gridworld.grid.Location;                     import java.awt.Color;                      public class BoxBugRunner {                         public static void main(String[] args) {                              ActorWorld world = new ActorWorld();                              BoxBug alice = new BoxBug(6);","124                                    Chapter 10. GridWorld: Part 2                                         alice.setColor(Color.ORANGE);                                       BoxBug bob = new BoxBug(3);                                       world.add(new Location(7, 8), alice);                                       world.add(new Location(5, 5), bob);                                       world.show();                                  }                             }                             Everything here should be familiar, with the possible exception of Location,                             which is part of GridWorld, and similar to java.awt.Point.                              BoxBug.java contains the class deﬁnition for BoxBug.                             public class BoxBug extends Bug {                                  private int steps;                                  private int sideLength;                                    public BoxBug(int length) {                                       steps = 0;                                       sideLength = length;                                  }                             }                              The ﬁrst line says that this class extends Bug, which means that a BoxBug is                             a kind of Bug.                              The next two lines are instance variables. Every Bug has variables named                             sideLength, which determines the size of the box it draws, and steps, which                             keeps track of how many steps the Bug has taken.                              The next line deﬁnes a constructor, which is a special method that initial-                             izes the instance variables. When you create a Bug by invoking new, Java                             invokes this constructor.                              The parameter of the constructor is the side length.                              Bug behavior is controlled by the act method. Here is the act method for                             BoxBug:                                   public void act() {                                       if (steps < sideLength \&\& canMove()) {                                            move();","10.1. Termites                                                           125                                     steps++;                              }                              else {                                   turn();                                   turn();                                   steps = 0;                              }                         }                    If the BoxBug can move, and has not taken the required number of steps, it                    moves and increments steps.                     If it hits a wall or completes one side of the box, it turns 90 degrees to the                    right and resets steps to 0.                     Run the program and see what it does. Did you get the behavior you ex-                    pected?                        10.1       Termites                      I wrote a class called Termite that extends Bug and adds the ability to                    interact with ﬂowers. To run it, download these ﬁles and import them into                    your development environment:                     http://thinkapjava.com/code/Termite.java                    http://thinkapjava.com/code/Termite.gif                    http://thinkapjava.com/code/TermiteRunner.java                    http://thinkapjava.com/code/EternalFlower.java                     Because Termite extends Bug, all Bug methods also work on Termites. But                    Termites have additional methods that Bugs don’t have.                          /**                          * Returns true if the termite has a flower.                          */                         public boolean hasFlower();                           /**                          * Returns true if the termite is facing a flower.","126                                    Chapter 10. GridWorld: Part 2                                     */                                  public boolean seeFlower();                                   /**                                   * Creates a flower unless the termite already has one.                                   */                                  public void createFlower();                                   /**                                   * Drops the flower in the termites current location.                                   *                                   * Note: only one Actor can occupy a grid cell, so the effect                                   * of dropping a flower is delayed until the termite moves.                                   */                                  public void dropFlower();                                   /**                                   * Throws the flower into the location the termite is facing.                                   */                                  public void throwFlower();                                   /**                                   * Picks up the flower the termite is facing, if there is                                   * one, and if the termite doesn't already have a flower.                                   */                                  public void pickUpFlower();                             For some methods Bug provides one deﬁnition and Termite provides another.                             In that case, the Termite method overrides the Bug method.                              For example, Bug.canMove returns true if there is a ﬂower in the next loca-                             tion, so Bugs can trample Flowers. Termite.canMove returns false if there                             is any object in the next location, so Termite behavior is diﬀerent.                              As another example, Termites have a version of turn that takes an integer                             number of degrees as a parameter. Finally, Termites have randomTurn, which                             turns left or right 45 degrees at random.                              Here is the code from TermiteRunner.java:","10.1. Termites                                                           127                      public class TermiteRunner                    {                         public static void main(String[] args)                         {                              ActorWorld world = new ActorWorld();                              makeFlowers(world, 20);                                Termite alice = new Termite();                              world.add(alice);                                Termite bob = new Termite();                              bob.setColor(Color.blue);                              world.add(bob);                                world.show();                         }                           public static void makeFlowers(ActorWorld world, int n) {                              for (int i = 0; i<n; i++) {                                   world.add(new EternalFlower());                              }                         }                    }                     Everything here should be familiar. TermiteRunner creates an ActorWorld                    with 20 EternalFlowers and two Termites.                     An EternalFlower is a Flower that overrides act so the ﬂowers don’t get                    darker.                     public class EternalFlower extends Flower {                         public void act() {}                    }                     If you run TermiteRunner.java you should see two termites moving at ran-                    dom among the ﬂowers.                     MyTermite.java demonstrates the methods that interact with ﬂowers. Here                    is the class deﬁnition:                     public class MyTermite extends Termite {","128                                    Chapter 10. GridWorld: Part 2                                      public void act() {                                       if (getGrid() == null)                                            return;                                         if (seeFlower()) {                                            pickUpFlower();                                       }                                       if (hasFlower()) {                                            dropFlower();                                       }                                         if (canMove()) {                                            move();                                       }                                       randomTurn();                                  }                             }                             MyTermite extends Termite and overrides act. If MyTermite sees a ﬂower,                             it picks it up. If it has a ﬂower, it drops it.                                 10.2       Langton’s Termite                              Langton’s Ant is a simple model of ant behavior that displays surprisingly                             complex behavior. The Ant lives on a grid like GridWorld where each cell is                             either white or black. The Ant moves according to these rules:                                  If the Ant is on a white cell, it turns to the right, makes the cell black,                                   and moves forward.                                  If the Ant is on a black cell, it turns to the left, makes the cell white,                                   and moves forward.                              Because the rules are simple, you might expect the Ant to do something                             simple like make a square or repeat a simple pattern. But starting on a grid                             with all white cells, the Ant makes more than 10,000 steps in a seemingly                             random pattern before it settles into a repeating loop of 104 steps.","10.3. Exercises                                                          129                      You can read more about Langton’s Ant at http://en.wikipedia.org/                    wiki/Langton_ant.                    It is not easy to implement Langton’s Ant in GridWorld because we can’t                    set the color of the cells. As an alternative, we can use Flowers to mark                    cells, but we can’t have an Ant and a Flower in the same cell, so we can’t                    implement the Ant rules exactly.                     Instead we’ll create what I’ll call a LangtonTermite, which uses seeFlower                    to check whether there is a ﬂower in the next cell, pickUpFlower to pick it                    up, and throwFlower to put a ﬂower in the next cell. You might want to                    read the code for these methods to be sure you know what they do.                        10.3       Exercises                      Exercise 10.1. Now you know enough to do the exercises in the Student                    Manual, Part 2. Go do them, and then come back for more fun.                     Exercise 10.2. The purpose of this exercise is to explore the behavior of                    Termites that interact with ﬂowers.                     Modify TermiteRunner.java to create MyTermites instead of Termites.                    Then run it again. MyTermites should move around at random, moving the                    ﬂowers around. The total number of ﬂowers should stay the same (including                    the ones MyTermites are holding).                     In Termites, Turtles and Traﬃc Jams, Mitchell Resnick describes a simple                    model of termite behavior:                          If you see a ﬂower, pick it up. Unless you already have a ﬂower; in that                          case, drop the one you have.                          Move forward, if you can.                         Turn left or right at random.                      Modify MyTermite.java to implement this model. What eﬀect do you think                    this change will have on the behavior of MyTermites?","130                                    Chapter 10. GridWorld: Part 2                               Try it out. Again, the total number of ﬂowers does not change, but over time                             the ﬂowers accumulate in a small number of piles, often just one.                             This behavior is an an emergent property, which you can read about                             at http://en.wikipedia.org/wiki/Emergence. MyTermites follow simple                             rules using only small-scale information, but the result is large-scale organi-                             zation.                              Experiment with diﬀerent rules and see what eﬀect they have on the system.                             Small changes can have unpredicable results!                              Exercise 10.3.      1. Make a copy of Termite.java called LangtonTermite                                   and a copy of TermiteRunner.java called LangtonRunner.java. Mod-                                   ify them so the class deﬁnitions have the same name as the ﬁles, and                                   so LangtonRunner creates a LangtonTermite.                                 2. If you create a ﬁle named LangtonTermite.gif, GridWorld uses                                   it to represent your Termite.      You can download excellent pic-                                   tures of insects from http://www.cksinfo.com/animals/insects/                                   realisticdrawings/index.html. To convert them to GIF format,                                   you can use an application like ImageMagick.                                 3. Modify act to implement rules similar to Langton’s Ant. Experiment                                   with diﬀerent rules, and with both 45 and 90 degree turns. Find rules                                   that run the maximum number of steps before the Termite starts to                                   loop.                                  4. To give your Termite enough room, you can make the grid bigger or                                   switch to an UnboundedGrid.                                 5. Create more than one LangtonTermite and see how they interact.","Chapter 11                         Create your own objects                            11.1       Class deﬁnitions and object types                      Way back in Section 1.5 when we deﬁned the class Hello, we also created an                    object type named Hello. We didn’t create any variables with type Hello,                    and we didn’t use new to create any Hello objects, but we could have!                     That example doesn’t make much sense, since there is no reason to create                    a Hello object, and it wouldn’t do much if we did. In this chapter, we will                    look at class deﬁnitions that create useful object types.                     Here are the most important ideas in this chapter:                          Deﬁning a new class also creates a new object type with the same name.                         A class deﬁnition is like a template for objects: it determines what                          instance variables the objects have and what methods can operate on                          them.                         Every object belongs to some object type; that is, it is an instance of                          some class.                         When you invoke new to create an object, Java invokes a special method                          called a constructor to initialize the instance variables. You provide                          one or more constructors as part of the class deﬁnition.","132                              Chapter 11. Create your own objects                                   The methods that operate on a type are deﬁned in the class deﬁnition                                   for that type.                               Here are some syntax issues about class deﬁnitions:                                   Class names (and hence object types) should begin with a capital letter,                                   which helps distinguish them from primitive types and variable names.                                   You usually put one class deﬁnition in each ﬁle, and the name of the                                   ﬁle must be the same as the name of the class, with the suﬃx .java.                                   For example, the Time class is deﬁned in the ﬁle named Time.java.                                   In any program, one class is designated as the startup class. The                                   startup class must contain a method named main, which is where the                                   execution of the program begins. Other classes may have a method                                   named main, but it will not be executed.                               With those issues out of the way, let’s look at an example of a user-deﬁned                             class, Time.                                 11.2       Time                               A common motivation for creating an object type is to encapsulate related                             data in an object that can be treated as a single unit. We have already seen                             two types like this, Point and Rectangle.                               Another example, which we will implement ourselves, is Time, which repre-                             sents the time of day. The data encapsulated in a Time object are an hour, a                             minute, and a number of seconds. Because every Time object contains these                             data, we need instance variables to hold them.                              The ﬁrst step is to decide what type each variable should be. It seems clear                             that hour and minute should be integers. Just to keep things interesting,                             let’s make second a double.                              Instance variables are declared at the beginning of the class deﬁnition, outside                             of any method deﬁnition, like this:","11.3. Constructors                                                       133                      class Time {                         int hour, minute;                         double second;                    }                     By itself, this code fragment is a legal class deﬁnition. The state diagram for                    a Time object looks like this:                          hour   0                        minute   0                       second   0.0                       After declaring the instance variables, the next step is to deﬁne a constructor                    for the new class.                        11.3       Constructors                       Constructors initialize instance variables. The syntax for constructors is                    similar to that of other methods, with three exceptions:                           The name of the constructor is the same as the name of the class.                         Constructors have no return type and no return value.                          The keyword static is omitted.                      Here is an example for the Time class:                         public Time() {                              this.hour = 0;                              this.minute = 0;                              this.second = 0.0;                         }","134                              Chapter 11. Create your own objects                               Where you would expect to see a return type, between public and Time,                             there is nothing. That’s how we (and the compiler) can tell that this is a                             constructor.                              This constructor does not take any arguments. Each line of the constructor                             initializes an instance variable to a default value (in this case, midnight).                             The name this is a special keyword that refers to the object we are creating.                             You can use this the same way you use the name of any other object. For                             example, you can read and write the instance variables of this, and you can                             pass this as an argument to other methods.                              But you do not declare this and you can’t make an assignment to it. this                             is created by the system; all you have to do is initialize its instance variables.                              A common error when writing constructors is to put a return statement at                             the end. Resist the temptation.                                11.4       More constructors                               Constructors can be overloaded, just like other methods, which means that                             you can provide multiple constructors with diﬀerent parameters. Java knows                             which constructor to invoke by matching the arguments of new with the                             parameters of the constructors.                             It is common to have one constructor that takes no arguments (shown above),                             and one constructor that takes a parameter list identical to the list of instance                             variables. For example:                                  public Time(int hour, int minute, double second) {                                       this.hour = hour;                                       this.minute = minute;                                       this.second = second;                                  }                             The names and types of the parameters are the same as the names and types                             of the instance variables. All the constructor does is copy the information                             from the parameters to the instance variables.                              If you look at the documentation for Points and Rectangles, you will see                             that both classes provide constructors like this. Overloading constructors","11.5. Creating a new object                                              135                      provides the ﬂexibility to create an object ﬁrst and then ﬁll in the blanks, or                    to collect all the information before creating the object.                    This might not seem very interesting, and in fact it is not. Writing construc-                    tors is a boring, mechanical process. Once you have written two, you will                    ﬁnd that you can write them quickly just by looking at the list of instance                    variables.                       11.5       Creating a new object                      Although constructors look like methods, you never invoke them directly.                    Instead, when you invoke new, the system allocates space for the new object                    and then invokes your constructor.                     The following program demonstrates two ways to create and initialize Time                    objects:                     class Time {                         int hour, minute;                         double second;                          public Time() {                              this.hour = 0;                              this.minute = 0;                              this.second = 0.0;                         }                           public Time(int hour, int minute, double second) {                              this.hour = hour;                              this.minute = minute;                              this.second = second;                         }                          public static void main(String[] args) {                                // one way to create and initialize a Time object                              Time t1 = new Time();                              t1.hour = 11;","136                              Chapter 11. Create your own objects                                         t1.minute = 8;                                       t1.second = 3.14159;                                       System.out.println(t1);                                        // another way to do the same thing                                       Time t2 = new Time(11, 8, 3.14159);                                       System.out.println(t2);                                  }                             }                              In main, the ﬁrst time we invoke new, we provide no arguments, so Java                             invokes the ﬁrst constructor. The next few lines assign values to the instance                             variables.                               The second time we invoke new, we provide arguments that match the param-                             eters of the second constructor. This way of initializing the instance variables                             is more concise and slightly more eﬃcient, but it can be harder to read, since                             it is not as clear which values are assigned to which instance variables.                                 11.6       Printing objects                               The output of this program is:                              Time@80cc7c0                             Time@80cc807                             When Java prints the value of a user-deﬁned object type, it prints the name                             of the type and a special hexadecimal (base 16) code that is unique for each                             object. This code is not meaningful in itself; in fact, it can vary from machine                             to machine and even from run to run. But it can be useful for debugging, in                             case you want to keep track of individual objects.                              To print objects in a way that is more meaningful to users (as opposed to                             programmers), you can write a method called something like printTime:                                  public static void printTime(Time t) {                                       System.out.println(t.hour + \":\" + t.minute + \":\" + t.second);                                  }                             Compare this method to the version of printTime in Section 3.10.","11.7. Operations on objects                                              137                      The output of this method, if we pass either t1 or t2 as an argument, is                    11:8:3.14159. Although this is recognizable as a time, it is not quite in the                    standard format. For example, if the number of minutes or seconds is less                    than 10, we expect a leading 0 as a place-keeper. Also, we might want to                    drop the decimal part of the seconds. In other words, we want something                    like 11:08:03.                    In most languages, there are simple ways to control the output format for                    numbers. In Java there are no simple ways.                     Java provides powerful tools for printing formatted things like times and                    dates, and also for interpreting formatted input. Unfortunately, these tools                    are not very easy to use, so I am going to leave them out of this book. If                    you want, you can take a look at the documentation for the Date class in the                    java.util package.                       11.7       Operations on objects                      In the next few sections, I demonstrate three kinds of methods that operate                    on objects:                    pure function: Takes objects as arguments but does not modify them. The                          return value is either a primitive or a new object created inside the                          method.                     modiﬁer: Takes objects as arguments and modiﬁes some or all of them.                          Often returns void.                     ﬁll-in method: One of the arguments is an “empty” object that gets ﬁlled                          in by the method. Technically, this is a type of modiﬁer.                     Often it is possible to write a given method as a pure function, a modiﬁer,                    or a ﬁll-in method. I will discuss the pros and cons of each.                       11.8       Pure functions                      A method is considered a pure function if the result depends only on the                    arguments, and it has no side eﬀects like modifying an argument or printing                    something. The only result of invoking a pure function is the return value.","138                              Chapter 11. Create your own objects                               One example is isAfter, which compares two Times and returns a boolean                             that indicates whether the ﬁrst operand comes after the second:                                  public static boolean isAfter(Time time1, Time time2) {                                       if (time1.hour > time2.hour) return true;                                       if (time1.hour < time2.hour) return false;                                        if (time1.minute > time2.minute) return true;                                       if (time1.minute < time2.minute) return false;                                         if (time1.second > time2.second) return true;                                       return false;                                  }                              What is the result of this method if the two times are equal? Does that                             seem like the appropriate result for this method? If you were writing the                             documentation for this method, would you mention that case speciﬁcally?                               A second example is addTime, which calculates the sum of two times. For                             example, if it is 9:14:30, and your breadmaker takes 3 hours and 35 minutes,                             you could use addTime to ﬁgure out when the bread will be done.                              Here is a rough draft of this method that is not quite right:                                   public static Time addTime(Time t1, Time t2) {                                       Time sum = new Time();                                       sum.hour = t1.hour + t2.hour;                                       sum.minute = t1.minute + t2.minute;                                       sum.second = t1.second + t2.second;                                       return sum;                                  }                             Although this method returns a Time object, it is not a constructor. You                             should go back and compare the syntax of a method like this with the syntax                             of a constructor, because it is easy to get confused.                              Here is an example of how to use this method. If currentTime contains the                             current time and breadTime contains the amount of time it takes for your                             breadmaker to make bread, then you could use addTime to ﬁgure out when                             the bread will be done.                                   Time currentTime = new Time(9, 14, 30.0);","11.8. Pure functions                                                     139                           Time breadTime = new Time(3, 35, 0.0);                         Time doneTime = addTime(currentTime, breadTime);                         printTime(doneTime);                    The output of this program is 12:49:30.0, which is correct. On the other                    hand, there are cases where the result is not correct. Can you think of one?                     The problem is that this method does not deal with cases where the number                    of seconds or minutes adds up to more than 60. In that case, we have to                    “carry” the extra seconds into the minutes column, or extra minutes into the                    hours column.                      Here’s a corrected version of the method.                         public static Time addTime(Time t1, Time t2) {                              Time sum = new Time();                              sum.hour = t1.hour + t2.hour;                              sum.minute = t1.minute + t2.minute;                              sum.second = t1.second + t2.second;                               if (sum.second >= 60.0) {                                   sum.second -= 60.0;                                   sum.minute += 1;                              }                              if (sum.minute >= 60) {                                   sum.minute -= 60;                                   sum.hour += 1;                              }                              return sum;                         }                    Although it’s correct, it’s starting to get big. Later I suggest much shorter                    alternative.                      This code demonstrates two operators we have not seen before, += and -=.                    These operators provide a concise way to increment and decrement variables.                    They are similar to ++ and --, except (1) they work on doubles as well as                    ints, and (2) the amount of the increment does not have to be 1. The state-                    ment sum.second -= 60.0; is equivalent to sum.second = sum.second -                    60;","140                              Chapter 11. Create your own objects                              11.9       Modiﬁers                               As an example of a modiﬁer, consider increment, which adds a given number                             of seconds to a Time object. Again, a rough draft of this method looks like:                                  public static void increment(Time time, double secs) {                                       time.second += secs;                                         if (time.second >= 60.0) {                                            time.second -= 60.0;                                            time.minute += 1;                                       }                                       if (time.minute >= 60) {                                            time.minute -= 60;                                            time.hour += 1;                                       }                                  }                             The ﬁrst line performs the basic operation; the remainder deals with the                             same cases we saw before.                             Is this method correct? What happens if the argument secs is much greater                             than 60? In that case, it is not enough to subtract 60 once; we have to                             keep doing it until second is below 60. We can do that by replacing the if                             statements with while statements:                                  public static void increment(Time time, double secs) {                                       time.second += secs;                                         while (time.second >= 60.0) {                                            time.second -= 60.0;                                            time.minute += 1;                                       }                                       while (time.minute >= 60) {                                            time.minute -= 60;                                            time.hour += 1;                                       }                                  }                              This solution is correct, but not very eﬃcient. Can you think of a solution                             that does not require iteration?","11.10. Fill-in methods                                                   141                     11.10       Fill-in methods                         Instead of creating a new object every time addTime is invoked, we could                    require the caller to provide an object where addTime stores the result. Com-                    pare this to the previous version:                          public static void addTimeFill(Time t1, Time t2, Time sum) {                              sum.hour = t1.hour + t2.hour;                              sum.minute = t1.minute + t2.minute;                              sum.second = t1.second + t2.second;                                if (sum.second >= 60.0) {                                   sum.second -= 60.0;                                   sum.minute += 1;                              }                              if (sum.minute >= 60) {                                   sum.minute -= 60;                                   sum.hour += 1;                              }                         }                      The result is stored in sum, so the return type is void.                      Modiﬁers and ﬁll-in methods are eﬃcient because they don’t have to create                    new objects. But they make it more diﬃcult to isolate parts of a program;                    in large projects they can cause errors that are hard to ﬁnd.                       Pure functions help manage the complexity of large projects, in part by                    making certain kinds of errors impossible. Also, they lend themselves to                    certain kids of composition and nesting. And because the result of a pure                    function depends only on the parameters, it is possible to speed them up by                    storing previously-computed results.                       I recommend that you write pure functions whenever it is reasonable, and                    resort to modiﬁers only if there is a compelling advantage.","142                              Chapter 11. Create your own objects                              11.11       Incremental development and planning                               In this chapter I demonstrated a program development process called rapid                                           1                             prototyping . For each method, I wrote a rough draft that performed the                             basic calculation, then tested it on a few cases, correcting ﬂaws as I found                             them.                               This approach can be eﬀective, but it can lead to code that is unnecessarily                             complicated—since it deals with many special cases—and unreliable—since                             it is hard to convince yourself that you have found all the errors.                              An alternative is to look for insight into the problem that can make the                             programming easier. In this case the insight is that a Time is really a three-                             digit number in base 60! The second is the “ones column,” the minute is                             the “60’s column”, and the hour is the “3600’s column.”                             When we wrote addTime and increment, we were eﬀectively doing addition                             in base 60, which is why we had to “carry” from one column to the next.                              Another approach to the whole problem is to convert Times into doubles                             and take advantage of the fact that the computer already knows how to                             do arithmetic with doubles. Here is a method that converts a Time into a                             double:                                       public static double convertToSeconds(Time t) {                                       int minutes = t.hour * 60 + t.minute;                                       double seconds = minutes * 60 + t.second;                                       return seconds;                                  }                              Now all we need is a way to convert from a double to a Time object. We                             could write a method to do it, but it might make more sense to write it as a                             third constructor:                                   public Time(double secs) {                                       this.hour =(int)(secs / 3600.0);                                       secs -= this.hour * 3600.0;                                       this.minute =(int)(secs / 60.0);                                1                                What I am calling rapid prototyping is similar to test-driven development (TDD); the                             diﬀerence is that TDD is usually based on automated testing. See http://en.wikipedia.                             org/wiki/Test-driven_development.","11.12. Generalization                                                    143                                secs -= this.minute * 60;                              this.second = secs;                         }                    This constructor is a little diﬀerent from the others; it involves some calcu-                    lation along with assignments to the instance variables.                     You might have to think to convince yourself that the technique I am using                    to convert from one base to another is correct. But once you’re convinced,                    we can use these methods to rewrite addTime:                         public static Time addTime(Time t1, Time t2) {                              double seconds = convertToSeconds(t1) + convertToSeconds(t2);                              return new Time(seconds);                         }                     This is shorter than the original version, and it is much easier to demonstrate                    that it is correct (assuming, as usual, that the methods it invokes are correct).                    As an exercise, rewrite increment the same way.                         11.12       Generalization                      In some ways converting from base 60 to base 10 and back is harder than                    just dealing with times. Base conversion is more abstract; our intuition for                    dealing with times is better.                     But if we have the insight to treat times as base 60 numbers, and make                    the investment of writing the conversion methods (convertToSeconds and                    the third constructor), we get a program that is shorter, easier to read and                    debug, and more reliable.                     It is also easier to add features later. Imagine subtracting two Times to                    ﬁnd the duration between them. The naive approach would be to implement                    subtraction complete with “borrowing.” Using the conversion methods would                    be much easier.                      Ironically, sometimes making a problem harder (more general) makes it easier                    (fewer special cases, fewer opportunities for error).","144                              Chapter 11. Create your own objects                              11.13       Algorithms                               When you write a general solution for a class of problems, as opposed to a                             speciﬁc solution to a single problem, you have written an algorithm. This                             word is not easy to deﬁne, so I will try a couple of approaches.                              First, consider some things that are not algorithms. When you learned to                             multiply single-digit numbers, you probably memorized the multiplication                             table. In eﬀect, you memorized 100 speciﬁc solutions, so that knowledge is                             not really algorithmic.                              But if you were “lazy,” you probably learned a few tricks. For example,                             to ﬁnd the product of n and 9, you can write n − 1 as the ﬁrst digit and                             10 − n as the second digit. This trick is a general solution for multiplying                             any single-digit number by 9. That’s an algorithm!                              Similarly, the techniques you learned for addition with carrying, subtraction                             with borrowing, and long division are all algorithms. One of the charac-                             teristics of algorithms is that they do not require any intelligence to carry                             out. They are mechanical processes in which each step follows from the last                             according to a simple set of rules.                              In my opinion, it is embarrassing that humans spend so much time in school                             learning to execute algorithms that, quite literally, require no intelligence.                             On the other hand, the process of designing algorithms is interesting, intel-                             lectually challenging, and a central part of what we call programming.                              Some of the things that people do naturally, without diﬃculty or conscious                             thought, are the most diﬃcult to express algorithmically. Understanding                             natural language is a good example. We all do it, but so far no one has been                             able to explain how we do it, at least not in the form of an algorithm.                             Soon you will have the opportunity to design simple algorithms for a variety                             of problems.                                 11.14       Glossary                              class: Previously, I deﬁned a class as a collection of related methods. In this                                   chapter we learned that a class deﬁnition is also a template for a new                                   type of object.","11.15. Exercises                                                         145                      instance: A member of a class. Every object is an instance of some class.                     constructor: A special method that initializes the instance variables of a                          newly-constructed object.                      startup class: The class that contains the main method where execution of                          the program begins.                     pure function: A method whose result depends only on its parameters, and                          that has no side-eﬀects other than returning a value.                     modiﬁer: A method that changes one or more of the objects it receives as                          parameters, and usually returns void.                     ﬁll-in method: A type of method that takes an “empty” object as a pa-                          rameter and ﬁlls in its instance variables instead of generating a return                          value.                     algorithm: A set of instructions for solving a class of problems by a me-                          chanical process.                        11.15       Exercises                                                                     2                    Exercise 11.1. In the board game Scrabble , each tile contains a letter,                    which is used to spell words, and a score, which is used to determine the                    value of words.                        1. Write a deﬁnition for a class named Tile that represents Scrabble tiles.                          The instance variables should be a character named letter and an                          integer named value.                        2. Write a constructor that takes parameters named letter and value                          and initializes the instance variables.                        3. Write a method named printTile that takes a Tile object as a pa-                          rameter and prints the instance variables in a reader-friendly format.                      2                       Scrabble is a registered trademark owned in the U.S.A and Canada by Hasbro Inc.,                    and in the rest of the world by J.W. Spear \& Sons Limited of Maidenhead, Berkshire,                    England, a subsidiary of Mattel Inc.","146                              Chapter 11. Create your own objects                                  4. Write a method named testTile that creates a Tile object with the                                   letter Z and the value 10, and then uses printTile to print the state                                   of the object.                               The point of this exercise is to practice the mechanical part of creating a new                             class deﬁnition and code that tests it.                              Exercise 11.2. Write a class deﬁnition for Date, an object type that con-                             tains three integers, year, month and day. This class should provide two                             constructors. The ﬁrst should take no parameters. The second should take                             parameters named year, month and day, and use them to initialize the in-                             stance variables.                              Write a main method that creates a new Date object named birthday. The                             new object should contain your birthdate. You can use either constructor.                              Exercise 11.3. A rational number is a number that can be represented as                             the ratio of two integers. For example, 2/3 is a rational number, and you                             can think of 7 as a rational number with an implicit 1 in the denominator.                             For this assignment, you are going to write a class deﬁnition for rational                             numbers.                                  1. Create a new program called Rational.java that deﬁnes a class named                                   Rational. A Rational object should have two integer instance vari-                                   ables to store the numerator and denominator.                                 2. Write a constructor that takes no arguments and that sets the numer-                                   ator to 0 and denominator to 1.                                 3. Write a method called printRational that takes a Rational object as                                   an argument and prints it in some reasonable format.                                 4. Write a main method that creates a new object with type Rational,                                   sets its instance variables to some values, and prints the object.                                 5. At this stage, you have a minimal testable program. Test it and, if                                   necessary, debug it.                                 6. Write a second constructor for your class that takes two arguments and                                   that uses them to initalize the instance variables.","11.15. Exercises                                                         147                         7. Write a method called negate that reverses the sign of a rational num-                          ber. This method should be a modiﬁer, so it should return void. Add                          lines to main to test the new method.                        8. Write a method called invert that inverts the number by swapping                          the numerator and denominator. Add lines to main to test the new                          method.                        9. Write a method called toDouble that converts the rational number to                          a double (ﬂoating-point number) and returns the result. This method                          is a pure function; it does not modify the object. As always, test the                          new method.                      10. Write a modiﬁer named reduce that reduces a rational number to                          its lowest terms by ﬁnding the greatest common divisor (GCD) of the                          numerator and denominator and dividing through. This method should                          be a pure function; it should not modify the instance variables of the                          object on which it is invoked. To ﬁnd the GCD, see Exercise 6.10).                      11. Write a method called add that takes two Rational numbers as argu-                          ments and returns a new Rational object. The return object should                          contain the sum of the arguments.                          There are several ways to add fractions. You can use any one you want,                          but you should make sure that the result of the operation is reduced so                          that the numerator and denominator have no common divisor (other                          than 1).                      The purpose of this exercise is to write a class deﬁnition that includes a                    variety of methods, including constructors, modiﬁers and pure functions.","148                              Chapter 11. Create your own objects","Chapter 12                         Arrays                           An array is a set of values where each value is identiﬁed by an index. You                    can make an array of ints, doubles, or any other type, but all the values in                    an array have to have the same type.                     Syntactically, array types look like other Java types except they are followed                    by []. For example, int[] is the type “array of integers” and double[] is                    the type “array of doubles.”                    You can declare variables with these types in the usual ways:                          int[] count;                         double[] values;                     Until you initialize these variables, they are set to null. To create the array                    itself, use new.                          count = new int[4];                         values = new double[size];                    The ﬁrst assignment makes count refer to an array of 4 integers; the second                    makes values refer to an array of doubles. The number of elements in                    values depends on size. You can use any integer expression as an array                    size.                     The following ﬁgure shows how arrays are represented in state diagrams:                     count              0    0     0    0                                      0    1     2    3","150                                                  Chapter 12. Arrays                               The large numbers inside the boxes are the elements of the array. The small                             numbers outside the boxes are the indices used to identify each box. When                             you allocate an array if ints, the elements are initialized to zero.                                 12.1       Accessing elements                               To store values in the array, use the [] operator. For example count[0]                             refers to the “zeroeth” element of the array, and count[1] refers to the                             “oneth” element. You can use the [] operator anywhere in an expression:                                   count[0] = 7;                                  count[1] = count[0] * 2;                                  count[2]++;                                  count[3] -= 60;                              These are all legal assignment statements. Here is the result of this code                             fragment:                               count              7   14     1 −60                                               0    1     2    3                              The elements of the array are numbered from 0 to 3, which means that there                             is no element with the index 4. This should sound familiar, since we saw the                             same thing with String indices. Nevertheless, it is a common error to go be-                             yond the bounds of an array, which throws an ArrayOutOfBoundsException.                                You can use any expression as an index, as long as it has type int. One                             of the most common ways to index an array is with a loop variable. For                             example:                                  int i = 0;                                  while (i < 4) {                                       System.out.println(count[i]);                                       i++;                                  }                             This is a standard while loop that counts from 0 up to 4, and when the loop                             variable i is 4, the condition fails and the loop terminates. Thus, the body                             of the loop is only executed when i is 0, 1, 2 and 3.","12.2. Copying arrays                                                     151                      Each time through the loop we use i as an index into the array, printing the                    ith element. This type of array traversal is very common.                       12.2       Copying arrays                      When you copy an array variable, remember that you are copying a reference                    to the array. For example:                          double[] a = new double [3];                         double[] b = a;                    This code creates one array of three doubles, and sets two diﬀerent variables                    to refer to it. This situation is a form of aliasing.                    a                                 0.0  0.0  0.0                    b                                  0    1    2                    Any changes in either array will be reﬂected in the other. This is not usually                    the behavior you want; more often you want to allocate a new array and                    copy elements from one to the other.                         double[] b = new double [3];                           int i = 0;                         while (i < 4) {                           b[i] = a[i];                           i++;                         }                       12.3       Arrays and objects                      In many ways, arrays behave like objects:                         When you declare an array variable, you get a reference to an array.                         You have to use new to create the array itself.                         When you pass an array as an argument, you pass a reference, which                          means that the invoked method can change the contents of the array.","152                                                  Chapter 12. Arrays                               Some of the objects we looked at, like Rectangles, are similar to arrays in                             the sense that they are collections of values. This raises the question, “How                             is an array of 4 integers diﬀerent from a Rectangle object?”                              If you go back to the deﬁnition of “array” at the beginning of the chapter,                             you see one diﬀerence: the elements of an array are identiﬁed by indices, and                             the elements of an object have names.                              Another diﬀerence is that the elements of an array have to be the same type.                             Objects can have instance variables with diﬀerent types.                                 12.4       for loops                               The loops we have written have a number of elements in common. All of them                             start by initializing a variable; they have a test, or condition, that depends                             on that variable; and inside the loop they do something to that variable, like                             increment it.                               This type of loop is so common that there is another loop statement, called                             for, that expresses it more concisely. The general syntax looks like this:                                   for (INITIALIZER; CONDITION; INCREMENTOR) {                                       BODY                                  }                              This statement is equivalent to                                  INITIALIZER;                                  while (CONDITION) {                                       BODY                                       INCREMENTOR                                  }                             except that it is more concise and, since it puts all the loop-related statements                             in one place, it is easier to read. For example:                                  for (int i = 0; i < 4; i++) {                                       System.out.println(count[i]);                                  }                             is equivalent to","12.5. Array length                                                       153                           int i = 0;                         while (i < 4) {                              System.out.println(count[i]);                              i++;                         }                       12.5       Array length                      All arrays have one named instance variable: length. Not surprisingly, it                    contains the length of the array (number of elements). It is a good idea to                    use this value as the upper bound of a loop, rather than a constant value.                    That way, if the size of the array changes, you won’t have to go through the                    program changing all the loops; they will work correctly for any size array.                         for (int i = 0; i < a.length; i++) {                              b[i] = a[i];                         }                    The last time the body of the loop gets executed, i is a.length - 1, which                    is the index of the last element. When i is equal to a.length, the condition                    fails and the body is not executed, which is a good thing, since it would                    throw an exception. This code assumes that the array b contains at least as                    many elements as a.                        12.6       Random numbers                      Most computer programs do the same thing every time they are executed,                    so they are said to be deterministic. Usually, determinism is a good thing,                    since we expect the same calculation to yield the same result. But for some                    applications we want the computer to be unpredictable. Games are an obvi-                    ous example, but there are more.                     Making a program truly nondeterministic turns out to be not so easy, but                    there are ways to make it at least seem nondeterministic. One of them is                    to generate random numbers and use them to determine the outcome of the                    program. Java provides a method that generates pseudorandom numbers,                    which may not be truly random, but for our purposes, they will do.","154                                                  Chapter 12. Arrays                               Check out the documentation of the random method in the Math class. The                             return value is a double between 0.0 and 1.0. To be precise, it is greater                             than or equal to 0.0 and strictly less than 1.0. Each time you invoke random                             you get the next number in a pseudorandom sequence. To see a sample, run                             this loop:                                  for (int i = 0; i < 10; i++) {                                       double x = Math.random();                                       System.out.println(x);                                  }                             To generate a random double between 0.0 and an upper bound like high,                             you can multiply x by high.                                 12.7       Array of random numbers                               How would you generate a random integer between low and high? If your                             implementation of randomInt is correct, then every value in the range from                             low to high-1 should have the same probability. If you generate a long                             series of numbers, every value should appear, at least approximately, the                             same number of times.                              One way to test your method is to generate a large number of random values,                             store them in an array, and count the number of times each value occurs.                               The following method takes a single argument, the size of the array. It                             allocates a new array of integers, ﬁlls it with random values, and returns a                             reference to the new array.                                public static int[] randomArray(int n) {                                    int[] a = new int[n];                                    for (int i = 0; i<a.length; i++) {                                         a[i] = randomInt(0, 100);                                    }                                    return a;                               }                             The return type is int[], which means that this method returns an array of                             integers. To test this method, it is convenient to have a method that prints                             the contents of an array.","12.8. Counting                                                           155                        public static void printArray(int[] a) {                           for (int i = 0; i<a.length; i++) {                                System.out.println(a[i]);                           }                      }                     The following code generates an array and prints it:                         int numValues = 8;                         int[] array = randomArray(numValues);                         printArray(array);                    On my machine the output is                     27                    6                    54                    62                    54                    2                    44                    81                    which is pretty random-looking. Your results may diﬀer.                     If these were exam scores (and they would be pretty bad exam scores) the                    teacher might present the results to the class in the form of a histogram,                    which is a set of counters that keeps track of the number of times each value                    appears.                      For exam scores, we might have ten counters to keep track of how many                    students scored in the 90s, the 80s, etc. The next few sections develop code                    to generate a histogram.                        12.8       Counting                      A good approach to problems like this is to think of simple methods that                    are easy to write, then combine them into a solution.        This process is                    called bottom-up development. See http://en.wikipedia.org/wiki/                    Top-down_and_bottom-up_design.","156                                                  Chapter 12. Arrays                               It is not always obvious where to start, but a good approach is to look for                             subproblems that ﬁt a pattern you have seen before.                              In Section 8.7 we saw a loop that traversed a string and counted the number                             of times a given letter appeared. You can think of this program as an example                             of a pattern called “traverse and count.” The elements of this pattern are:                                   A set or container that can be traversed, like an array or a string.                                   A test that you can apply to each element in the container.                                  A counter that keeps track of how many elements pass the test.                                In this case, the container is an array of integers. The test is whether or not                             a given score falls in a given range of values.                              Here is a method called inRange that counts the number of elements in                             an array that fall in a given range. The parameters are the array and two                             integers that specify the lower and upper bounds of the range.                              public static int inRange(int[] a, int low, int high) {                                  int count = 0;                                  for (int i = 0; i < a.length; i++) {                                       if (a[i] >= low \&\& a[i] < high) count++;                                  }                                  return count;                             }                             I wasn’t speciﬁc about whether something equal to low or high falls in the                             range, but you can see from the code that low is in and high is out. That                             keeps us from counting any elements twice.                              Now we can count the number of scores in the ranges we are interested in:                             int[] scores = randomArray(30);                             int a = inRange(scores, 90, 100);                             int b = inRange(scores, 80, 90);                             int c = inRange(scores, 70, 80);                             int d = inRange(scores, 60, 70);                             int f = inRange(scores, 0, 60);","12.9. The histogram                                                      157                     12.9       The histogram                      This code is repetitious, but it is acceptable as long as the number of ranges                    is small. But imagine that we want to keep track of the number of times                    each score appears, all 100 possible values. Would you want to write this?                    int count0 = inRange(scores, 0, 1);                    int count1 = inRange(scores, 1, 2);                    int count2 = inRange(scores, 2, 3);                    ...                    int count3 = inRange(scores, 99, 100);                    I don’t think so. What we really want is a way to store 100 integers, prefer-                    ably so we can use an index to access each one. Hint: array.                     The counting pattern is the same whether we use a single counter or an array                    of counters. In this case, we initialize the array outside the loop; then, inside                    the loop, we invoke inRange and store the result:                         int[] counts = new int[100];                           for (int i = 0; i < counts.length; i++) {                              counts[i] = inRange(scores, i, i+1);                         }                     The only tricky thing here is that we are using the loop variable in two roles:                    as in index into the array, and as the parameter to inRange.                        12.10       A single-pass solution                      This code works, but it is not as eﬃcient as it could be. Every time it invokes                    inRange, it traverses the entire array. As the number of ranges increases,                    that gets to be a lot of traversals.                     It would be better to make a single pass through the array, and for each value,                    compute which range it falls in. Then we could increment the appropriate                    counter. In this example, that computation is trivial, because we can use the                    value itself as an index into the array of counters.                    Here is code that traverses an array of scores once and generates a histogram.","158                                                  Chapter 12. Arrays                                    int[] counts = new int[100];                                    for (int i = 0; i < scores.length; i++) {                                       int index = scores[i];                                       counts[index]++;                                  }                                12.11       Glossary                              array: A collection of values, where all the values have the same type, and                                   each value is identiﬁed by an index.                              element: One of the values in an array. The [] operator selects elements.                              index: An integer variable or value used to indicate an element of an array.                              deterministic: A program that does the same thing every time it is invoked.                              pseudorandom: A sequence of numbers that appear to be random, but                                   which are actually the product of a deterministic computation.                              histogram: An array of integers where each integer counts the number of                                   values that fall into a certain range.                                 12.12       Exercises                              Exercise 12.1. Write a method called cloneArray that takes an array of                             integers as a parameter, creates a new array that is the same size, copies the                             elements from the ﬁrst array into the new one, and then returns a reference                             to the new array.                              Exercise 12.2. Write a method called randomDouble that takes two dou-                             bles, low and high, and that returns a random double x so that low ≤ x <                             high.                             Exercise 12.3. Write a method called randomInt that takes two arguments,                             low and high, and that returns a random integer between low and high, not                             including high.","12.12. Exercises                                                         159                      Exercise 12.4. Encapsulate the code in Section 12.10 in a method called                    makeHist that takes an array of scores and returns a histogram of the values                    in the array.                      Exercise 12.5. Write a method named areFactors that takes an integer n                    and an array of integers, and that returns true if the numbers in the array                    are all factors of n (which is to say that n is divisible by all of them). HINT:                    See Exercise 6.1.                      Exercise 12.6. Write a method that takes an array of integers and an integer                    named target as arguments, and that returns the ﬁrst index where target                    appears in the array, if it does, and -1 otherwise.                     Exercise 12.7. Some programmers disagree with the general rule that vari-                    ables and methods should be given meaningful names. Instead, they think                    variables and methods should be named after fruit.                     For each of the following methods, write one sentence that describes ab-                    stractly what the method does. For each variable, identify the role it plays.                     public static int banana(int[] a) {                         int grape = 0;                         int i = 0;                         while (i < a.length) {                              grape = grape + a[i];                              i++;                         }                         return grape;                    }                      public static int apple(int[] a, int p) {                         int i = 0;                         int pear = 0;                         while (i < a.length) {                              if (a[i] == p) pear++;                              i++;                         }                         return pear;                    }","160                                                  Chapter 12. Arrays                                 public static int grapefruit(int[] a, int p) {                                  for (int i = 0; i<a.length; i++) {                                       if (a[i] == p) return i;                                  }                                  return -1;                             }                             The purpose of this exercise is to practice reading code and recognizing the                             computation patterns we have seen.                              Exercise 12.8.      1. What is the output of the following program?                                 2. Draw a stack diagram that shows the state of the program just before                                   mus returns.                                  3. Describe in a few words what mus does.                             public static int[] make(int n) {                                  int[] a = new int[n];                                    for (int i = 0; i < n; i++) {                                       a[i] = i+1;                                  }                                  return a;                             }                              public static void dub(int[] jub) {                                  for (int i = 0; i < jub.length; i++) {                                       jub[i] *= 2;                                  }                             }                               public static int mus(int[] zoo) {                                  int fus = 0;                                  for (int i = 0; i < zoo.length; i++) {                                       fus = fus + zoo[i];                                  }                                  return fus;                             }","12.12. Exercises                                                         161                        public static void main(String[] args) {                         int[] bob = make(5);                         dub(bob);                           System.out.println(mus(bob));                    }                    Exercise 12.9. Many of the patterns we have seen for traversing arrays can                    also be written recursively. It is not common to do so, but it is a useful                    exercise.                        1. Write a method called maxInRange that takes an array of integers                          and a range of indices (lowIndex and highIndex), and that ﬁnds the                          maximum value in the array, considering only the elements between                          lowIndex and highIndex, including both ends.                          This method should be recursive. If the length of the range is 1, that is,                          if lowIndex == highIndex, we know immediately that the sole element                          in the range must be the maximum. So that’s the base case.                          If there is more than one element in the range, we can break the array                          into two pieces, ﬁnd the maximum in each of the pieces, and then ﬁnd                          the maximum of the maxima.                        2. Methods like maxInRange can be awkward to use. To ﬁnd the largest                          element in an array, we have to provide a range that includes the entire                          array.                                double max = maxInRange(array, 0, a.length-1);                          Write a method called max that takes an array as a parameter and that                          uses maxInRange to ﬁnd and return the largest value. Methods like                          max are sometimes called wrapper methods because they provide a                          layer of abstraction around an awkward method and make it easier to                          use. The method that actually performs the computation is called the                          helper method.                        3. Write a recursive version of find using the wrapper-helper pattern.                          find should take an array of integers and a target integer. It should                          return the index of the ﬁrst location where the target integer appears                          in the array, or -1 if it does not appear.","162                                                  Chapter 12. Arrays                               Exercise 12.10. One not-very-eﬃcient way to sort the elements of an array                             is to ﬁnd the largest element and swap it with the ﬁrst element, then ﬁnd                             the second-largest element and swap it with the second, and so on. This                             method is called a selection sort (see http://en.wikipedia.org/wiki/                             Selection_sort).                                  1. Write a method called indexOfMaxInRange that takes an array of inte-                                   gers, ﬁnds the largest element in the given range, and returns its index.                                   You can modify your recursive version of maxInRange or you can write                                   an iterative version from scratch.                                 2. Write a method called swapElement that takes an array of integers and                                   two indices, and that swaps the elements at the given indices.                                 3. Write a method called selectionSort that takes an array of integers                                   and that uses indexOfMaxInRange and swapElement to sort the array                                   from largest to smallest.                              Exercise 12.11. Write a method called letterHist that takes a String as                             a parameter and that returns a histogram of the letters in the String. The                             zeroeth element of the histogram should contain the number of a’s in the                             String (upper and lower case); the 25th element should contain the number                             of z’s. Your solution should only traverse the String once.                              Exercise 12.12. A word is said to be a “doubloon” if every letter that                             appears in the word appears exactly twice. For example, the following are                             all the doubloons I found in my dictionary.                                     Abba, Anna, appall, appearer, appeases, arraigning, beriberi,                                   bilabial, boob, Caucasus, coco, Dada, deed, Emmett, Hannah,                                   horseshoer, intestines, Isis, mama, Mimi, murmur, noon, Otto,                                   papa, peep, reappear, redder, sees, Shanghaiings, Toto                               Write a method called isDoubloon that returns true if the given word is a                             doubloon and false otherwise.                              Exercise 12.13. Two words are anagrams if they contain the same letters                             (and the same number of each letter). For example, “stop” is an anagram of                             “pots” and “allen downey” is an anagram of “well annoyed.”","12.12. Exercises                                                         163                      Write a method that takes two Strings and returns true if the Strings are                    anagrams of each other.                    Optional challenge: read the letters of the Strings only once.                      Exercise 12.14. In Scrabble each player has a set of tiles with letters on                    them, and the object of the game is to use those letters to spell words. The                    scoring system is complicated, but longer words are usually worth more than                    shorter words.                     Imagine you are given your set of tiles as a String, like \"quijibo\" and you                    are given another String to test, like \"jib\". Write a method called canSpell                    that takes two Strings and returns true if the set of tiles can be used to spell                    the word. You might have more than one tile with the same letter, but you                    can only use each tile once.                     Optional challenge: read the letters of the Strings only once.                     Exercise 12.15. In real Scrabble, there are some blank tiles that can be                    used as wild cards; that is, a blank tile can be used to represent any letter.                     Think of an algorithm for canSpell that deals with wild cards. Don’t get                    bogged down in details of implementation like how to represent wild cards.                    Just describe the algorithm, using English, pseudocode, or Java.","164                                                  Chapter 12. Arrays","Chapter 13                         Arrays of Objects                           13.1       The Road Ahead                      In the next three chapters we will develop programs to work with playing                    cards and decks of cards. Before we dive in, here is an outline of the steps:                        1. In this chapter we’ll deﬁne a Card class and write methods that work                          with Cards and arrays of Cards.                        2. In Chapter 14 we will create a Deck class and write methods that                          operate on Decks.                        3. In Chapter 15 I will present object-oriented programming (OOP) and                          we will transform the Card and Deck classes into a more OOP style.                    I think that way of proceeding makes the road smoother; the drawback is                    that we will see several versions of the same code, which can be confusing.                    If it helps, you can download the code for each chapter as you go along. The                    code for this chapter is here: http://thinkapjava.com/code/Card1.java.                       13.2       Card objects                      If you are not familiar with common playing cards, now would be a good                    time to get a deck, or else this chapter might not make much sense. Or read                    http://en.wikipedia.org/wiki/Playing_card.","166                                      Chapter 13. Arrays of Objects                               There are 52 cards in a deck; each belongs to one of four suits and one of                             13 ranks. The suits are Spades, Hearts, Diamonds and Clubs (in descending                             order in Bridge). The ranks are Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen and                             King. Depending on what game you are playing, the Ace may be considered                             higher than King or lower than 2.                              If we want to deﬁne a new object to represent a playing card, it is pretty                             obvious what the instance variables should be: rank and suit. It is not                             as obvious what type the instance variables should be. One possibility is                             Strings, containing things like \"Spade\" for suits and \"Queen\" for ranks. One                             problem with this implementation is that it would not be easy to compare                             cards to see which had higher rank or suit.                              An alternative is to use integers to encode the ranks and suits. By “encode”                             I do not mean what some people think, which is to encrypt or translate into                             a secret code. What a computer scientist means by “encode” is something                             like “deﬁne a mapping between a sequence of numbers and the things I want                             to represent.” For example,                               Spades       7→ 3                              Hearts       7→ 2                              Diamonds 7→ 1                              Clubs        7→ 0                             The obvious feature of this mapping is that the suits map to integers in order,                             so we can compare suits by comparing integers. The mapping for ranks is                             fairly obvious; each of the numerical ranks maps to the corresponding integer,                             and for face cards:                              Jack     7→ 11                              Queen 7→ 12                              King     7→ 13                              The reason I am using mathematical notation for these mappings is that they                             are not part of the program. They are part of the program design, but they                             never appear explicitly in the code. The class deﬁnition for the Card type                             looks like this:                              class Card                             {                                  int suit, rank;","13.3. The printCard method                                               167                             public Card() {                              this.suit = 0;     this.rank = 0;                         }                           public Card(int suit, int rank) {                              this.suit = suit;      this.rank = rank;                         }                    }                     As usual, I provide two constructors: one takes a parameter for each instance                    variable; the other takes no parameters.                     To create an object that represents the 3 of Clubs, we invoke new:                         Card threeOfClubs = new Card(0, 3);                    The ﬁrst argument, 0 represents the suit Clubs.                        13.3       The printCard method                      When you create a new class, the ﬁrst step is to declare the instance variables                    and write constructors. The second step is to write the standard methods                    that every object should have, including one that prints the object, and one                    or two that compare objects. Let’s start with printCard.                     To print Card objects in a way that humans can read easily, we want to map                    the integer codes onto words. A natural way to do that is with an array of                    Strings. You can create an array of Strings the same way you create an                    array of primitive types:                         String[] suits = new String[4];                    Then we can set the values of the elements of the array.                          suits[0] = \"Clubs\";                         suits[1] = \"Diamonds\";                         suits[2] = \"Hearts\";                         suits[3] = \"Spades\";                     Creating an array and initializing the elements is such a common operation                    that Java provides a special syntax for it:","168                                      Chapter 13. Arrays of Objects                                    String[] suits = { \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\" };                             This statement is equivalent to the separate declaration, allocation, and as-                             signment. The state diagram of this array looks like:                               suits                 \"Clubs\"                                                   \"Diamonds\"                                                   \"Hearts\"                                                   \"Spades\"                               The elements of the array are references to the Strings, rather than Strings                             themselves.                              Now we need another array of Strings to decode the ranks:                                   String[] ranks = { \"narf\", \"Ace\", \"2\", \"3\", \"4\", \"5\", \"6\",                                               \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\" };                              The reason for the \"narf\" is to act as a place-keeper for the zeroeth element                             of the array, which is never used (or shouldn’t be). The only valid ranks                             are 1–13. To avoid this wasted element, we could have started at 0, but the                             mapping is more natural if we encode 2 as 2, and 3 as 3, etc.                              Using these arrays, we can select the appropriate Strings by using the suit                             and rank as indices. In the method printCard,                             public static void printCard(Card c) {                                  String[] suits = { \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\" };                                  String[] ranks = { \"narf\", \"Ace\", \"2\", \"3\", \"4\", \"5\", \"6\",                                               \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\" };                                   System.out.println(ranks[c.rank] + \" of \" + suits[c.suit]);                             }                              the expression suits[c.suit] means “use the instance variable suit from                             the object c as an index into the array named suits, and select the appro-                             priate string.” The output of this code                                  Card card = new Card(1, 11);                                  printCard(card);                             is Jack of Diamonds.","13.4. The sameCard method                                                169                     13.4       The sameCard method                      The word “same” is one of those things that occur in natural language that                    seem perfectly clear until you give it some thought, and then you realize                    there is more to it than you expected.                     For example, if I say “Chris and I have the same car,” I mean that his car and                    mine are the same make and model, but they are two diﬀerent cars. If I say                    “Chris and I have the same mother,” I mean that his mother and mine are                    one person. So the idea of “sameness” is diﬀerent depending on the context.                     When you talk about objects, there is a similar ambiguity. For example, if                    two Cards are the same, does that mean they contain the same data (rank                    and suit), or they are actually the same Card object?                    To see if two references refer to the same object, we use the == operator. For                    example:                          Card card1 = new Card(1, 11);                         Card card2 = card1;                           if (card1 == card2) {                              System.out.println(\"card1 and card2 are identical.\");                         }                    References to the same object are identical. References to objects with same                    data are equivalent.                     To check equivalence, it is common to write a method with a name like                    sameCard.                         public static boolean sameCard(Card c1, Card c2) {                              return(c1.suit == c2.suit \&\& c1.rank == c2.rank);                         }                    Here is an example that creates two objects with the same data, and uses                    sameCard to see if they are equivalent:                         Card card1 = new Card(1, 11);                         Card card2 = new Card(1, 11);                           if (sameCard(card1, card2)) {                              System.out.println(\"card1 and card2 are equivalent.\");","170                                      Chapter 13. Arrays of Objects                                    }                             If references are identical, they are also equivalent, but if they are equivalent,                             they are not necessarily identical.                              In this case, card1 and card2 are equivalent but not identical, so the state                             diagram looks like this:                                                 suit   1                     suit  1                             card1                        card2                                            rank  11                     rank  11                                What does it look like when card1 and card2 are identical?                              In Section 8.10 I said that you should not use the == operator on Strings                             because it does not do what you expect. Instead of comparing the contents                             of the String (equivalence), it checks whether the two Strings are the same                             object (identity).                                13.5       The compareCard method                               For primitive types, the conditional operators compare values and determine                             when one is greater or less than another. These operators (< and > and the                             others) don’t work for object types. For Strings Java provides a compareTo                             method. For Cards we have to write our own, which we will call compareCard.                             Later, we will use this method to sort a deck of cards.                              Some sets are completely ordered, which means that you can compare any                             two elements and tell which is bigger. Integers and ﬂoating-point numbers                             are totally ordered. Some sets are unordered, which means that there is no                             meaningful way to say that one element is bigger than another. Fruits are                             unordered, which is why we cannot compare apples and oranges. In Java, the                             boolean type is unordered; we cannot say that true is greater than false.                              The set of playing cards is partially ordered, which means that sometimes                             we can compare cards and sometimes not. For example, I know that the 3                             of Clubs is higher than the 2 of Clubs, and the 3 of Diamonds is higher than","13.6. Arrays of cards                                                    171                      the 3 of Clubs. But which is better, the 3 of Clubs or the 2 of Diamonds?                    One has a higher rank, but the other has a higher suit.                    To make cards comparable, we have to decide which is more important, rank                    or suit. The choice is arbitrary, but when you buy a new deck of cards, it                    comes sorted with all the Clubs together, followed by all the Diamonds, and                    so on. So let’s say that suit is more important.                     With that decided, we can write compareCard. It takes two Cards as param-                    eters and returns 1 if the ﬁrst card wins, -1 if the second card wins, and 0 if                    they are equivalent.                     First we compare suits:                          if (c1.suit > c2.suit) return 1;                         if (c1.suit < c2.suit) return -1;                    If neither statement is true, the suits must be equal, and we have to compare                    ranks:                         if (c1.rank > c2.rank) return 1;                         if (c1.rank < c2.rank) return -1;                    If neither of these is true, the ranks must be equal, so we return 0.                        13.6       Arrays of cards                      By now we have seen several examples of composition (the ability to combine                    language features in a variety of arrangements). One of the ﬁrst examples                    we saw was using a method invocation as part of an expression. Another                    example is the nested structure of statements: you can put an if statement                    within a while loop, or within another if statement, etc.                    Having seen this pattern, and having learned about arrays and objects, you                    should not be surprised to learn that you can make arrays of objects. And                    you can deﬁne objects with arrays as instance variables; you can make arrays                    that contain arrays; you can deﬁne objects that contain objects, and so on.                    In the next two chapters we will see examples of these combinations using                    Card objects.                    This example creates an array of 52 cards:","172                                      Chapter 13. Arrays of Objects                                    Card[] cards = new Card[52];                             Here is the state diagram for this object:                                              0  1 2 3                               51                              cards                               The array contains references to objects; it does not contain the Card objects                             themselves. The elements are initialized to null. You can access the elements                             of the array in the usual way:                                  if (cards[0] == null) {                                       System.out.println(\"No cards yet!\");                                  }                             But if you try to access the instance variables of the non-existent Cards, you                             get a NullPointerException.                                   cards[0].rank;                   // NullPointerException                             But that is the correct syntax for accessing the rank of the “zeroeth” card                             in the deck. This is another example of composition, combining the syntax                             for accessing an element of an array and an instance variable of an object.                              The easiest way to populate the deck with Card objects is to write nested                             for loops (i.e., one loop inside the body of another):                                  int index = 0;                                  for (int suit = 0; suit <= 3; suit++) {                                       for (int rank = 1; rank <= 13; rank++) {                                            cards[index] = new Card(suit, rank);                                            index++;                                       }                                  }                             The outer loop enumerates the suits from 0 to 3. For each suit, the inner                             loop enumerates the ranks from 1 to 13. Since the outer loop runs 4 times,                             and the inner loop runs 13 times, the body is executed is 52 times.                              I used index to keep track of where in the deck the next card should go.                             The following state diagram shows what the deck looks like after the ﬁrst                             two cards have been allocated:","13.7. The printDeck method                                               173                                     0  1 2 3                               51                     cards                             suit   0        suit  0                           rank    1       rank   2                          13.7       The printDeck method                      When you work with arrays, it is convenient to have a method that prints                    the contents. We have seen the pattern for traversing an array several times,                    so the following method should be familiar:                          public static void printDeck(Card[] cards) {                              for (int i = 0; i < cards.length; i++) {                                   printCard(cards[i]);                              }                         }                     Since cards has type Card[], an element of cards has type Card. So                    cards[i] is a legal argument for printCard.                        13.8       Searching                      The next method I’ll write is findCard, which searches an array of Cards to                    see whether it contains a certain card. This method gives me a chance to                    demonstrate two algorithms: linear search and bisection search.                     Linear search is pretty obvious; we traverse the deck and compare each card                    to the one we are looking for. If we ﬁnd it we return the index where the                    card appears. If it is not in the deck, we return -1.                     public static int findCard(Card[] cards, Card card) {                         for (int i = 0; i< cards.length; i++) {","174                                      Chapter 13. Arrays of Objects                                         if (sameCard(cards[i], card)) {                                            return i;                                       }                                  }                                  return -1;                             }                             The arguments of findCard are card and cards. It might seem odd to have                             a variable with the same name as a type (the card variable has type Card).                             We can tell the diﬀerence because the variable begins with a lower-case letter.                             The method returns as soon as it discovers the card, which means that we                             do not have to traverse the entire deck if we ﬁnd the card we are looking for.                             If we get to the end of the loop, we know the card is not in the deck.                              If the cards in the deck are not in order, there is no way to search faster than                             this. We have to look at every card because otherwise we can’t be certain                             the card we want is not there.                              But when you look for a word in a dictionary, you don’t search linearly                             through every word, because the words are in alphabetical order. As a result,                             you probably use an algorithm similar to a bisection search:                                 1. Start in the middle somewhere.                                 2. Choose a word on the page and compare it to the word you are looking                                   for.                                 3. If you ﬁnd the word you are looking for, stop.                                 4. If the word you are looking for comes after the word on the page, ﬂip                                   to somewhere later in the dictionary and go to step 2.                                 5. If the word you are looking for comes before the word on the page, ﬂip                                   to somewhere earlier in the dictionary and go to step 2.                              If you ever get to the point where there are two adjacent words on the page                             and your word comes between them, you can conclude that your word is not                             in the dictionary.                              Getting back to the deck of cards, if we know the cards are in order, we can                             write a faster version of findCard. The best way to write a bisection search                             is with a recursive method, because bisection is naturally recursive.","13.8. Searching                                                          175                      The trick is to write a method called findBisect that takes two indices as                    parameters, low and high, indicating the segment of the array that should                    be searched (including both low and high).                         1. To search the array, choose an index between low and high (call it mid)                          and compare it to the card you are looking for.                        2. If you found it, stop.                        3. If the card at mid is higher than your card, search the range from low                          to mid-1.                        4. If the card at mid is lower than your card, search the range from mid+1                          to high.                      Steps 3 and 4 look suspiciously like recursive invocations. Here’s what this                    looks like translated into Java code:                    public static int findBisect(Card[] cards, Card card, int low, int high) {                         // TODO: need a base case                         int mid = (high + low) / 2;                         int comp = compareCard(cards[mid], card);                          if (comp == 0) {                              return mid;                         } else if (comp > 0) {                              return findBisect(cards, card, low, mid-1);                         } else {                              return findBisect(cards, card, mid+1, high);                         }                    }                    This code contains the kernel of a bisection search, but it is still missing an                    important piece, which is why I added a TODO comment. As written, the                    method recurses forever if the card is not in the deck. We need a base case                    to handle this condition.                     If high is less than low, there are no cards between them, see we conclude                    that the card is not in the deck. If we handle that case, the method works                    correctly:","176                                      Chapter 13. Arrays of Objects                               public static int findBisect(Card[] cards, Card card, int low, int high) {                                  System.out.println(low + \", \" + high);                                   if (high < low) return -1;                                    int mid = (high + low) / 2;                                  int comp = compareCard(cards[mid], card);                                   if (comp == 0) {                                       return mid;                                  } else if (comp > 0) {                                       return findBisect(cards, card, low, mid-1);                                  } else {                                       return findBisect(cards, card, mid+1, high);                                  }                             }                              I added a print statement so I can follow the sequence of recursive invocations.                             I tried out the following code:                                   Card card1 = new Card(1, 11);                                  System.out.println(findBisect(cards, card1, 0, 51));                             And got the following output:                             0, 51                             0, 24                             13, 24                             19, 24                             22, 24                             23                             Then I made up a card that is not in the deck (the 15 of Diamonds), and                             tried to ﬁnd it. I got the following:                              0, 51                             0, 24                             13, 24                             13, 17                             13, 14                             13, 12                             -1","13.9. Decks and subdecks                                                 177                      These tests don’t prove that this program is correct. In fact, no amount of                    testing can prove that a program is correct. On the other hand, by looking at                    a few cases and examining the code, you might be able to convince yourself.                       The number of recursive invocations is typically 6 or 7, so we only invoke                    compareCard 6 or 7 times, compared to up to 52 times if we did a linear                    search. In general, bisection is much faster than a linear search, and even                    more so for large arrays.                     Two common errors in recursive programs are forgetting to include                    a base case and writing the recursive call so that the base case is                    never reached.    Either error causes inﬁnite recursion, which throws a                    StackOverflowException. (Think of a stack diagram for a recursive method                    that never ends.)                        13.9       Decks and subdecks                      Here is the prototype (see Section 8.5) of findBisect:                    public static int findBisect(Card[] deck, Card card, int low, int high)                    We can think of cards, low, and high as a single parameter that speciﬁes                    a subdeck. This way of thinking is common, and is sometimes referred to                    as an abstract parameter. What I mean by “abstract” is something that                    is not literally part of the program text, but which describes the function of                    the program at a higher level.                    For example, when you invoke a method and pass an array and the bounds                    low and high, there is nothing that prevents the invoked method from ac-                    cessing parts of the array that are out of bounds. So you are not literally                    sending a subset of the deck; you are really sending the whole deck. But as                    long as the recipient plays by the rules, it makes sense to think of it abstractly                    as a subdeck.                     This kind of thinking, in which a program takes on meaning beyond what is                    literally encoded, is an important part of thinking like a computer scientist.                    The word “abstract” gets used so often and in so many contexts that it comes                    to lose its meaning. Nevertheless, abstraction is a central idea in computer                    science (and many other ﬁelds).","178                                      Chapter 13. Arrays of Objects                               A more general deﬁnition of “abstraction” is “The process of modeling a                             complex system with a simpliﬁed description to suppress unnecessary details                             while capturing relevant behavior.”                                 13.10       Glossary                              encode: To represent one set of values using another set of values, by con-                                   structing a mapping between them.                              identity: Equality of references. Two references that point to the same                                   object in memory.                              equivalence: Equality of values. Two references that point to objects that                                   contain the same data.                              abstract parameter: A set of parameters that act together as a single pa-                                   rameter.                               abstraction: The process of interpreting a program (or anything else) at a                                   higher level than what is literally represented by the code.                                 13.11       Exercises                               Exercise 13.1. Encapsulate the code in Section 13.5 in a method. Then                             modify it so that aces are ranked higher than Kings.                              Exercise 13.2. Encapsulate the deck-building code of Section 13.6 in a                             method called makeDeck that takes no parameters and returns a fully-                             populated array of Cards.                              Exercise 13.3. In Blackjack the object of the game is to get a collection of                             cards with a score of 21. The score for a hand is the sum of scores for all                             cards. The score for an aces is 1, for all face cards is ten, and for all other                             cards the score is the same as the rank. Example: the hand (Ace, 10, Jack,                             3) has a total score of 1 + 10 + 10 + 3 = 24.                              Write a method called handScore that takes an array of cards as an argument                             and that returns the total score.","13.11. Exercises                                                         179                      Exercise 13.4. In Poker a “ﬂush” is a hand that contains ﬁve or more cards                    of the same suit. A hand can contain any number of cards.                        1. Write a method called suitHist that takes an array of Cards as a                          parameter and that returns a histogram of the suits in the hand. Your                          solution should only traverse the array once.                        2. Write a method called hasFlush that takes an array of Cards as a                          parameter and that returns true if the hand contains a ﬂush, and                          false otherwise.                     Exercise 13.5. Working with cards is more interesting if you can display                    them on the screen. If you haven’t played with the graphics examples in                    Appendix A, you might want to do that now.                     First  download    http://thinkapjava.com/code/CardTable.java             and                    http://thinkapjava.com/code/cardset.zip into the same folder. Then                    unzip cardset.zip, which contains a cardset-oxymoron subfolder with                    all the card images. (Note the variable cardset in CardTable.main is the                    name of this folder.) Run CardTable.java and you should see images of a                    pack of cards laid out on a green table.                      You can use this class as a starting place to implement your own card games.","180                                      Chapter 13. Arrays of Objects","Chapter 14                         Objects of Arrays                           WARNING: In this chapter, we take another step toward object-oriented                    programming, but we are not there yet. So many of the examples are non-                    idiomatic; that is, they are not good Java. This transitional form will help                    you learn (I hope), but don’t write code like this.                     You can download the code in this chapter from http://thinkapjava.com/                    code/Card2.java.                       14.1       The Deck class                      In the previous chapter, we worked with an array of objects, but I also                    mentioned that it is possible to have an object that contains an array as an                    instance variable. In this chapter we create a Deck object that contains an                    array of Cards.                     The class deﬁnition looks like this:                     class Deck {                         Card[] cards;                           public Deck(int n) {                              this.cards = new Card[n];                         }                    }","182                                      Chapter 14. Objects of Arrays                               The constructor initializes the instance variable with an array of cards, but                             it doesn’t create any cards. Here is a state diagram showing what a Deck                             looks like with no cards:                               deck          cards                                Here is a no-argument constructor that makes a 52-card deck and populates                             it with Cards:                                  public Deck() {                                       this.cards = new Card[52];                                       int index = 0;                                       for (int suit = 0; suit <= 3; suit++) {                                            for (int rank = 1; rank <= 13; rank++) {                                                cards[index] = new Card(suit, rank);                                                index++;                                            }                                       }                                  }                             This method is similar to makeDeck; we just changed the syntax to make it                             a constructor. To invoke it, we use new:                                   Deck deck = new Deck();                             Now it makes sense to put the methods that pertain to Decks in the Deck                             class deﬁnition. Looking at the methods we have written so far, one obvious                             candidate is printDeck (Section 13.7). Here’s how it looks, rewritten to work                             with a Deck:                                   public static void printDeck(Deck deck) {                                       for (int i = 0; i < deck.cards.length; i++) {                                            Card.printCard(deck.cards[i]);                                       }                                  }                             One change is the type of the parameter, from Card[] to Deck.                              The second change is that we can no longer use deck.length to get the length                             of the array, because deck is a Deck object now, not an array. It contains                             an array, but it is not an array. So we have to write deck.cards.length to                             extract the array from the Deck object and get the length of the array.","14.2. Shuﬄing                                                            183                      For the same reason, we have to use deck.cards[i] to access an element of                    the array, rather than just deck[i].                    The last change is that the invocation of printCard has to say explicitly that                    printCard is deﬁned in the Card class.                       14.2       Shuﬄing                      For most card games you need to be able to shuﬄe the deck; that is, put the                    cards in a random order. In Section 12.6 we saw how to generate random                    numbers, but it is not obvious how to use them to shuﬄe a deck.                    One possibility is to model the way humans shuﬄe, which is usually by                    dividing the deck in two and then choosing alternately from each deck. Since                    humans usually don’t shuﬄe perfectly, after about 7 iterations the order of                    the deck is pretty well randomized. But a computer program would have                    the annoying property of doing a perfect shuﬄe every time, which is not                    really very random. In fact, after 8 perfect shuﬄes, you would ﬁnd the                    deck back in the order you started in. For more information, see http:                    //en.wikipedia.org/wiki/Faro_shuffle.                     A better shuﬄing algorithm is to traverse the deck one card at a time, and                    at each iteration choose two cards and swap them.                     Here is an outline of how this algorithm works. To sketch the program, I am                    using a combination of Java statements and English words that is sometimes                    called pseudocode:                         for (int i = 0; i < deck.cards.length; i++) {                              // choose a number between i and deck.cards.length-1                              // swap the ith card and the randomly-chosen card                         }                    The nice thing about pseudocode is that it often makes it clear what methods                    you are going to need. In this case, we need something like randomInt, which                    chooses a random integer between low and high, and swapCards which takes                    two indices and switches the cards at the indicated positions.                     This process—writing pseudocode ﬁrst and then writing methods to make it                    work—is called top-down development (see http://en.wikipedia.org/                    wiki/Top-down_and_bottom-up_design).","184                                      Chapter 14. Objects of Arrays                              14.3       Sorting                               Now that we have messed up the deck, we need a way to put it back in order.                             There is an algorithm for sorting that is ironically similar to the algorithm                             for shuﬄing. It’s called selection sort because it works by traversing the                             array repeatedly and selecting the lowest remaining card each time.                              During the ﬁrst iteration we ﬁnd the lowest card and swap it with the card                             in the 0th position. During the ith, we ﬁnd the lowest card to the right of i                             and swap it with the ith card.                              Here is pseudocode for selection sort:                                   for (int i = 0; i < deck.cards.length; i++) {                                       // find the lowest card at or to the right of i                                       // swap the ith card and the lowest card                                  }                             Again, the pseudocode helps with the design of the helper methods. In                             this case we can use swapCards again, so we only need one new one, called                             indexLowestCard, that takes an array of cards and an index where it should                             start looking.                                 14.4       Subdecks                              How should we represent a hand or some other subset of a full deck? One                             possibility is to create a new class called Hand, which might extend Deck.                             Another possibility, the one I will demonstrate, is to represent a hand with                             a Deck object with fewer than 52 cards.                              We might want a method, subdeck, that takes a Deck and a range of indices,                             and that returns a new Deck that contains the speciﬁed subset of the cards:                              public static Deck subdeck(Deck deck, int low, int high) {                                  Deck sub = new Deck(high-low+1);                                   for (int i = 0; i<sub.cards.length; i++) {                                       sub.cards[i] = deck.cards[low+i];                                  }                                  return sub;                             }","14.5. Shuﬄing and dealing                                                185                      The length of the subdeck is high-low+1 because both the low card and high                    card are included. This sort of computation can be confusing, and lead to                    “oﬀ-by-one” errors. Drawing a picture is usually the best way to avoid them.                     Because we provide an argument with new, the contructor that gets invoked                    will be the ﬁrst one, which only allocates the array and doesn’t allocate any                    cards. Inside the for loop, the subdeck gets populated with copies of the                    references from the deck.                     The following is a state diagram of a subdeck being created with the param-                    eters low=3 and high=7. The result is a hand with 5 cards that are shared                    with the original deck; i.e. they are aliased.                       deck          cards                               sub          cards                       Aliasing is usually not generally a good idea, because changes in one subdeck                    are reﬂected in others, which is not the behavior you would expect from real                    cards and decks. But if the cards are immutable, aliasing is less dangerous.                    In this case, there is probably no reason ever to change the rank or suit of a                    card. Instead we can create each card once and then treat it as an immutable                    object. So for Cards aliasing is a reasonable choice.                        14.5       Shuﬄing and dealing                      In Section 14.2 I wrote pseudocode for a shuﬄing algorithm. Assuming that                    we have a method called shuffleDeck that takes a deck as an argument and                    shuﬄes it, we can use it to deal hands:                          Deck deck = new Deck();                         shuffleDeck(deck);","186                                      Chapter 14. Objects of Arrays                                      Deck hand1 = subdeck(deck, 0, 4);                                  Deck hand2 = subdeck(deck, 5, 9);                                  Deck pack = subdeck(deck, 10, 51);                              This code puts the ﬁrst 5 cards in one hand, the next 5 cards in the other,                             and the rest into the pack.                              When you thought about dealing, did you think we should give one card                             to each player in the round-robin style that is common in real card games?                             I thought about it, but then realized that it is unnecessary for a computer                             program. The round-robin convention is intended to mitigate imperfect shuf-                             ﬂing and make it more diﬃcult for the dealer to cheat. Neither of these is                             an issue for a computer.                              This example is a useful reminder of one of the dangers of engineering                             metaphors: sometimes we impose restrictions on computers that are un-                             necessary, or expect capabilities that are lacking, because we unthinkingly                             extend a metaphor past its breaking point.                                14.6       Mergesort                               In Section 14.3, we saw a simple sorting algorithm that turns out not to be                             very eﬃcient. To sort n items, it has to traverse the array n times, and each                             traversal takes an amount of time that is proportional to n. The total time,                                                           2                             therefore, is proportional to n .                             In this section I sketch a more eﬃcient algorithm called mergesort. To sort                             n items, mergesort takes time proportional to n log n. That may not seem                                                                                      2                             impressive, but as n gets big, the diﬀerence between n and n log n can be                             enormous. Try out a few values of n and see.                              The basic idea behind mergesort is this: if you have two subdecks, each of                             which has been sorted, it is easy (and fast) to merge them into a single,                             sorted deck. Try this out with a deck of cards:                                  1. Form two subdecks with about 10 cards each and sort them so that                                   when they are face up the lowest cards are on top. Place both decks                                   face up in front of you.","14.6. Mergesort                                                          187                         2. Compare the top card from each deck and choose the lower one. Flip                          it over and add it to the merged deck.                        3. Repeat step two until one of the decks is empty. Then take the remain-                          ing cards and add them to the merged deck.                      The result should be a single sorted deck. Here’s what this looks like in                    pseudocode:                     public static Deck merge(Deck d1, Deck d2) {                         // create a new deck big enough for all the cards                         Deck result = new Deck(d1.cards.length + d2.cards.length);                           // use the index i to keep track of where we are in                         // the first deck, and the index j for the second deck                         int i = 0;                         int j = 0;                          // the index k traverses the result deck                         for (int k = 0; k < result.cards.length; k++) {                                // if d1 is empty, d2 wins; if d2 is empty, d1 wins;                              // otherwise, compare the two cards                               // add the winner to the new deck                         }                         return result;                    }                    The best way to test merge is to build and shuﬄe a deck, use subdeck to form                    two (small) hands, and then use the sort routine from the previous chapter                    to sort the two halves. Then you can pass the two halves to merge to see if                    it works.                     If you can get that working, try a simple implementation of mergeSort:                    public static Deck mergeSort(Deck deck) {                         // find the midpoint of the deck                         // divide the deck into two subdecks                         // sort the subdecks using sortDeck","188                                      Chapter 14. Objects of Arrays                                    // merge the two halves and return the result                             }                              Then, if you get that working, the real fun begins! The magical thing about                             mergesort is that it is recursive. At the point where you sort the subdecks,                             why should you invoke the old, slow version of sort? Why not invoke the                             spiﬀy new mergeSort you are in the process of writing?                               Not only is that a good idea, it is necessary to achieve the performance ad-                             vantage I promised. But to make it work you have to have a base case;                             otherwise it recurses forever. A simple base case is a subdeck with 0 or 1                             cards. If mergesort receives such a small subdeck, it can return it unmodi-                             ﬁed, since it is already sorted.                               The recursive version of mergesort should look something like this:                             public static Deck mergeSort(Deck deck) {                                  // if the deck is 0 or 1 cards, return it                                    // find the midpoint of the deck                                  // divide the deck into two subdecks                                  // sort the subdecks using mergesort                                  // merge the two halves and return the result                             }                              As usual, there are two ways to think about recursive programs: you can                             think through the entire ﬂow of execution, or you can make the “leap of                             faith” (see Section 6.9). I have constructed this example to encourage you                             to make the leap of faith.                               When you use sortDeck to sort the subdecks, you don’t feel compelled to                             follow the ﬂow of execution, right? You just assume it works because you                             already debugged it. Well, all you did to make mergeSort recursive was                             replace one sorting algorithm with another. There is no reason to read the                             program diﬀerently.                               Actually, you have to give some thought to getting the base case right and                             making sure that you reach it eventually, but other than that, writing the                             recursive version should be no problem. Good luck!","14.7. Class variables                                                    189                     14.7       Class variables                      So far we have seen local variables, which are declared inside a method, and                    instance variables, which are declared in a class deﬁnition, usually before the                    method deﬁnitions.                     Local variables are created when a method is invoked and destroyed when                    the method ends. Instance variables are created when you create an object                    and destroyed when the object is garbage collected.                    Now it’s time to learn about class variables. Like instance variables, class                    variables are deﬁned in a class deﬁnition before the method deﬁnitions, but                    they are identiﬁed by the keyword static. They are created when the pro-                    gram starts and survive until the program ends.                    You can refer to a class variable from anywhere inside the class deﬁnition.                    Class variables are often used to store constant values that are needed in                    several places.                     As an example, here is a version of Card where suits and ranks are class                    variables:                    class Card {                         int suit, rank;                           static String[] suits = { \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\" };                         static String[] ranks = { \"narf\", \"Ace\", \"2\", \"3\", \"4\", \"5\", \"6\",                                               \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\" };                           public static void printCard(Card c) {                              System.out.println(ranks[c.rank] + \" of \" + suits[c.suit]);                         }                    }                    Inside printCard we can refer to suits and ranks as if they were local                    variables.                        14.8       Glossary                     pseudocode: A way of designing programs by writing rough drafts in a                          combination of English and Java.","190                                      Chapter 14. Objects of Arrays                               helper method: Often a small method that does not do anything enor-                                   mously useful by itself, but which helps another, more useful method.                             class variable: A variable declared within a class as static; there is always                                   exactly one copy of this variable in existence.                                 14.9       Exercises                              Exercise 14.1. The goal of this exercise is to implement the shuﬄing and                             sorting algorithms from this chapter.                                 1. Download the code from this chapter from http://thinkapjava.com/                                   code/Card2.java and import it into your development environment. I                                   have provided outlines for the methods you will write, so the program                                   should compile. But when it runs it prints messages indicating that                                   the empty methods are not working. When you ﬁll them in correctly,                                   the messages should go away.                                 2. If you did Exercise 12.3, you already wrote randomInt. Otherwise,                                   write it now and add code to test it.                                  3. Write a method called swapCards that takes a deck (array of cards)                                   and two indices, and that switches the cards at those two locations.                                    HINT: it should switch references, not the contents of the objects. This                                   is faster; also, it correctly handles the case where cards are aliased.                                4. Write a method called shuffleDeck that uses the algorithm in Sec-                                   tion 14.2. You might want to use the randomInt method from Exer-                                   cise 12.3.                                 5. Write a method called indexLowestCard that uses the compareCard                                   method to ﬁnd the lowest card in a given range of the deck (from                                   lowIndex to highIndex, including both).                                 6. Write a method called sortDeck that arranges a deck of cards from                                   lowest to highest.                                 7. Using the pseudocode in Section 14.6, write the method called merge.                                   Be sure to test it before trying to use it as part of a mergeSort.","14.9. Exercises                                                          191                         8. Write the simple version of mergeSort, the one that divides the deck                          in half, uses sortDeck to sort the two halves, and uses merge to create                          a new, fully-sorted deck.                        9. Write the fully recursive version of mergeSort.        Remember that                          sortDeck is a modiﬁer and mergeSort is a function, which means that                          they get invoked diﬀerently:                           sortDeck(deck);                    // modifies existing deck                          deck = mergeSort(deck);            // replaces old deck with new","192                                      Chapter 14. Objects of Arrays","Chapter 15                         Object-oriented programming                            15.1       Programming languages and styles                      There are many programming languages and almost as many programming                    styles (sometimes called paradigms). The programs we have written so far                    are procedural, because the emphasis has been on specifying computational                    procedures.                      Most Java programs are object-oriented, which means that the focus is                    on objects and their interactions. Here are some of the characteristics of                    object-oriented programming:                          Objects often represent entities in the real world. In the previous chap-                          ter, creating the Deck class was a step toward object-oriented program-                          ming.                         The majority of methods are object methods (like the methods you                          invoke on Strings) rather than class methods (like the Math methods).                          The methods we have written so far have been class methods. In this                          chapter we write some object methods.                         Objects are isolated from each other by limiting the ways they interact,                          especially by preventing them from accessing instance variables without                          invoking methods.","194                       Chapter 15. Object-oriented programming                                   Classes are organized in family trees where new classes extend existing                                   classes, adding new methods and replacing others.                              In this chapter I translate the Card program from the previous chapter from                             procedural to object-oriented style. You can download the code from this                             chapter from http://thinkapjava.com/code/Card3.java.                                 15.2       Object methods and class methods                               There are two types of methods in Java, called class methods and ob-                             ject methods. Class methods are identiﬁed by the keyword static in the                             ﬁrst line. Any method that does not have the keyword static is an object                             method.                              Although we have not written object methods, we have invoked some. When-                             ever you invoke a method “on” an object, it’s an object method. For example,                             charAt and the other methods we invoked on String objects are all object                             methods.                              Anything that can be written as a class method can also be written as an                             object method, and vice versa. But sometimes it is more natural to use one                             or the other.                             For example, here is printCard as a class method:                                   public static void printCard(Card c) {                                       System.out.println(ranks[c.rank] + \" of \" + suits[c.suit]);                                  }                             Here it is re-written as an object method:                                  public void print() {                                       System.out.println(ranks[rank] + \" of \" + suits[suit]);                                  }                             Here are the changes:                                 1. I removed static.                                  2. I changed the name of the method to be more idiomatic.                                3. I removed the parameter.","15.3. The toString method                                                195                         4. Inside an object method you can refer to instance variables as if they                          were local variables, so I changed c.rank to rank, and likewise for                          suit.                       Here’s how this method is invoked:                          Card card = new Card(1, 1);                         card.print();                     When you invoke a method on an object, that object becomes the current                    object, also known as this. Inside print, the keyword this refers to the                    card the method was invoked on.                         15.3       The toString method                      Every object type has a method called toString that returns a string repre-                    sentation of the object. When you print an object using print or println,                    Java invokes the object’s toString method.                      The default version of toString returns a string that contains the type of                    the object and a unique identiﬁer (see Section 11.6). When you deﬁne a                    new object type, you can override the default behavior by providing a new                    method with the behavior you want.                     For example, here is a toString method for Card:                     public String toString() {                         return ranks[rank] + \" of \" + suits[suit];                    }                     The return type is String, naturally, and it takes no parameters. You can                    invoke toString in the usual way:                          Card card = new Card(1, 1);                         String s = card.toString();                     or you can invoke it indirectly through println:                          System.out.println(card);","196                       Chapter 15. Object-oriented programming                              15.4       The equals method                                In Section 13.4 we talked about two notions of equality: identity, which                             means that two variables refer to the same object, and equivalence, which                             means that they have the same value.                              The == operator tests identity, but there is no operator that tests equiva-                             lence, because what “equivalence” means depends on the type of the objects.                             Instead, objects provide a method named equals that deﬁnes equivalence.                               Java classes provide equals methods that do the right thing. But for user                             deﬁned types the default behavior is the same as identity, which is usually                             not what you want.                               For Cards we already have a method that checks equivalence:                                  public static boolean sameCard(Card c1, Card c2) {                                       return (c1.suit == c2.suit \&\& c1.rank == c2.rank);                                  }                              So all we have to do is rewrite is as an object method:                                   public boolean equals(Card c2) {                                       return (suit == c2.suit \&\& rank == c2.rank);                                  }                              Again, I removed static and the ﬁrst parameter, c1. Here’s how it’s invoked:                                   Card card = new Card(1, 1);                                  Card card2 = new Card(1, 1);                                  System.out.println(card.equals(card2));                              Inside equals, card is the current object and card2 is the parameter, c2.                             For methods that operate on two objects of the same type, I sometimes use                             this explicitly and call the parameter that:                                   public boolean equals(Card that) {                                       return (this.suit == that.suit \&\& this.rank == that.rank);                                  }                              I think it improves readability.","15.5. Oddities and errors                                                197                     15.5       Oddities and errors                      If you have object methods and class methods in the same class, it is easy to                    get confused. A common way to organize a class deﬁnition is to put all the                    constructors at the beginning, followed by all the object methods and then                    all the class methods.                     You can have an object method and a class method with the same name, as                    long as they do not have the same number and types of parameters. As with                    other kinds of overloading, Java decides which version to invoke by looking                    at the arguments you provide.                    Now that we know what the keyword static means, you have probably                    ﬁgured out that main is a class method, which means that there is no “current                    object” when it is invoked.      Since there is no current object in a class                    method, it is an error to use the keyword this. If you try, you get an error                    message like: “Undeﬁned variable: this.”                    Also, you cannot refer to instance variables without using dot notation and                    providing an object name. If you try, you get a message like “non-static vari-                    able... cannot be referenced from a static context.” By “non-static variable”                    it means “instance variable.”                       15.6       Inheritance                      The language feature most often associated with object-oriented program-                    ming is inheritance. Inheritance is the ability to deﬁne a new class that is                    a modiﬁed version of an existing class. Extending the metaphor, the existing                    class is sometimes called the parent class and the new class is called the                    child.                     The primary advantage of this feature is that you can add methods and                    instance variables without modifying the parent. This is particularly useful                    for Java classes, since you can’t modify them even if you want to.                    If you did the GridWorld exercises (Chapters 5 and 10) you have seen exam-                    ples of inheritance:                     public class BoxBug extends Bug {                         private int steps;","198                       Chapter 15. Object-oriented programming                                    private int sideLength;                                    public BoxBug(int length) {                                       steps = 0;                                       sideLength = length;                                  }                             }                             BoxBug extends Bug means that BoxBug is a new kind of Bug that inherits                             the methods and instance variables of Bug. In addition:                                  The child class can have additional instance variables; in this example,                                   BoxBugs have steps and sideLength.                                  The child can have additional methods; in this example, BoxBugs have                                   an additional constructor that takes an integer parameter.                                  The child can override a method from the parent; in this example, the                                   child provides act (not shown here), which overrides the act method                                   from the parent.                              If you did the Graphics exercises in Appendix A, you saw another example:                             public class MyCanvas extends Canvas {                                    public void paint(Graphics g) {                                       g.fillOval(100, 100, 200, 200);                                  }                             }                             MyCanvas is a new kind of Canvas with no new methods or instance variables,                             but it overrides paint.                              If you didn’t do either of those exercises, now is a good time!                                15.7       The class hierarchy                               In Java, all classes extend some other class. The most basic class is called                             Object. It contains no instance variables, but it provides the methods equals                             and toString, among others.","15.8. Object-oriented design                                             199                      Many classes extend Object, including almost all of the classes we have                    written and many Java classes, like java.awt.Rectangle. Any class that                    does not explicitly name a parent inherits from Object by default.                     Some inheritance chains are much longer, though.               For example,                    javax.swing.JFrame extends java.awt.Frame, which extends Window,                    which extends Container, which extends Component, which extends Object.                    No matter how long the chain, Object is the common ancestor of all classes.                     The “family tree” of classes is called the class hierarchy. Object usually                    appears at the top, with all the “child” classes below. If you look at the                    documentation of JFrame, for example, you see the part of the hierarchy                    that makes up JFrame’s pedigree.                       15.8       Object-oriented design                     Inheritance is a powerful feature. Some programs that would be complicated                    without it can be written concisely and simply with it. Also, inheritance can                    facilitate code reuse, since you can customize the behavior of existing classes                    without having to modify them.                    On the other hand, inheritance can make programs hard to read. When you                    see a method invocation, it can be hard to ﬁgure out which method gets                    invoked.                     Also, many of the things that can be done with inheritance can be done                    as well or better without it. A common alternative is composition, where                    new objects are composed of existing objects, adding new capability without                    inheritance.                     Designing objects and the relationships among them is the topic of object-                    oriented design, which is beyond the scope of this book. But if you are                    interested, I recommend Head First Design Patterns, published by O’Reilly                    Media.                        15.9       Glossary                     object method: A method that is invoked on an object, and that operates                          on that object. Object methods do not have the keyword static.","200                       Chapter 15. Object-oriented programming                               class method: A method with the keyword static. Class methods are not                                   invoked on objects and they do not have a current object.                             current object: The object on which an object method is invoked. Inside                                   the method, the current object is referred to by this.                              implicit: Anything that is left unsaid or implied. Within an object method,                                   you can refer to the instance variables implicitly (i.e., without naming                                   the object).                              explicit: Anything that is spelled out completely. Within a class method,                                   all references to the instance variables have to be explicit.                                 15.10       Exercises                              Exercise    15.1. Download http://thinkapjava.com/code/CardSoln2.                             java and http://thinkapjava.com/code/CardSoln3.java.                              CardSoln2.java contains solutions to the exercises in the previous chapter.                             It uses only class methods (except the constructors).                              CardSoln3.java contains the same program, but most of the methods are                             object methods. I left merge unchanged because I think it is more readable                             as a class method.                              Transform merge into an object method, and change mergeSort accordingly.                             Which version of merge do you prefer?                             Exercise 15.2. Transform the following class method into an object method.                              public static double abs(Complex c) {                                  return Math.sqrt(c.real * c.real + c.imag * c.imag);                             }                             Exercise 15.3. Transform the following object method into a class method.                             public boolean equals(Complex b) {                                  return(real == b.real \&\& imag == b.imag);                             }                             Exercise 15.4. This exercise is a continuation of Exercise 11.3. The purpose                             is to practice the syntax of object methods and get familiar with the relevant                             error messages.","15.10. Exercises                                                         201                         1. Transform the methods in the Rational class from class methods to                          object methods, and make the necessary changes in main.                        2. Make a few mistakes. Try invoking class methods as if they were object                          methods and vice-versa. Try to get a sense for what is legal and what                          is not, and for the error messages that you get when you mess up.                        3. Think about the pros and cons of class and object methods. Which                          is more concise (usually)? Which is a more natural way to express                          computation (or, maybe more fairly, what kind of computations can be                          expressed most naturally using each style)?                     Exercise 15.5. The goal of this exercise is to write a program that gener-                    ates random poker hands and classiﬁes them, so that we can estimate the                    probability of the various poker hands. If you don’t play poker, you can read                    about it here http://en.wikipedia.org/wiki/List_of_poker_hands.                         1. Start with http://thinkapjava.com/code/CardSoln3.java and                          make sure you can compile and run it.                        2. Write a deﬁnition for a class named PokerHand that extends Deck.                         3. Write a Deck method named deal that creates a PokerHand, transfers                          cards from the deck to the hand, and returns the hand.                        4. In main use shuffle and deal to generate and print four PokerHands                          with ﬁve cards each. Did you get anything good?                        5. Write a PokerHand method called hasFlush returns a boolean indicat-                          ing whether the hand contains a ﬂush.                         6. Write a method called hasThreeKind that indicates whether the hand                          contains Three of a Kind.                        7. Write a loop that generates a few thousand hands and checks whether                          they contain a ﬂush or three of a kind. Estimate the probability of                          getting one of those hands. Compare your results to the probabilities                          at http://en.wikipedia.org/wiki/List_of_poker_hands.","202                       Chapter 15. Object-oriented programming                                  8. Write methods that test for the other poker hands. Some are easier                                   than others. You might ﬁnd it useful to write some general-purpose                                   helper methods that can be used for more than one test.                                 9. In some poker games, players get seven cards each, and they form a                                   hand with the best ﬁve of the seven. Modify your program to generate                                   seven-card hands and recompute the probabilities.","Chapter 16                         GridWorld: Part 3                           If you haven’t done the exercises in Chapters 5 and 10, you should do them be-                    fore reading this chapter. As a reminder, you can ﬁnd the documentation for                    the GridWorld classes at http://www.greenteapress.com/thinkapjava/                    javadoc/gridworld/.                     Part 3 of the GridWorld Student Manual presents the classes that make up                    GridWorld and the interactions among them. It is an example of object-                    oriented design and an opportunity to discuss OO design issues.                     But before you read the Student Manual, there are a few more things you                    need to know.                        16.1       ArrayList                      GridWorld uses java.util.ArrayList, which is an object similar to an ar-                    ray. It is a collection, which means that it’s an object that contains other                    objects. Java provides other collections with diﬀerent capabilities, but to use                    GridWorld we only need ArrayLists.                     To see an example, download http://thinkapjava.com/code/BlueBug.                    java and http://thinkapjava.com/code/BlueBugRunner.java.                    A                    BlueBug is a bug that moves at random and looks for rocks. If it ﬁnds a                    rock, it makes it blue.","204                                    Chapter 16. GridWorld: Part 3                               Here’s how it works. When act is invoked, BlueBug gets its location and a                             reference to the grid:                                  Location loc = getLocation();                                  Grid<Actor> grid = getGrid();                             The type in angle-brackets (<>) is a type parameter that speciﬁes the                             contents of grid. In other words, grid is not just a Grid, it’s a Grid that                             contains Actors.                             The next step is to get the neighbors of the current location. Grid provides                             a method that does just that:                                   ArrayList<Actor> neighbors = grid.getNeighbors(loc);                             The return value from getNeighbors is an ArrayList of Actors. The size                             method returns the length of the ArrayList, and get selects an element. So                             we can print the neighbors like this.                                        for (int i = 0; i < neighbors.size(); i++) {                                            Actor actor = neighbors.get(i);                                            System.out.println(actor);                                       }                              Traversing an ArrayList is such a common operation there’s a special syntax                             for it: the for-each loop. So we could write:                                        for (Actor actor : neighbors) {                                            System.out.println(actor);                                       }                             We know that the neighbors are Actors, but we don’t know what kind:                             they could be Bugs, Rocks, etc. To ﬁnd the Rocks, we use the instanceof                             operator, which checks whether an object is an instance of a class.                                        for (Actor actor : neighbors) {                                            if (actor instanceof Rock) {                                                actor.setColor(Color.blue);                                            }                                       }                             To make all this work, we need to import the classes we use:                              import info.gridworld.actor.Actor;                             import info.gridworld.actor.Bug;                             import info.gridworld.actor.Rock;","16.2. Interfaces                                                         205                      import info.gridworld.grid.Grid;                    import info.gridworld.grid.Location;                     import java.awt.Color;                    import java.util.ArrayList;                       16.2       Interfaces                      GridWorld also uses Java interfaces, so I want to explain what they are.                    “Interface” means diﬀerent things in diﬀerent contexts, but in Java it refers                    to a speciﬁc language feature: an interface is a class deﬁnition where the                    methods have no bodies.                     In a normal class deﬁnition, each method has a prototype and a body (see                    Section 8.5). A prototype is also called a speciﬁcation because it speciﬁes                    the name, parameters, and return type of the method. The body is called                    the implementation because it implements the speciﬁcation.                     In a Java interface the methods have no bodies, so it speciﬁes the methods                    without implementing them.                    For example, java.awt.Shape is an interface with prototypes for contains,                    intersects, and several other methods. java.awt.Rectangle provides im-                    plementations for those methods, so we say that “Rectangle implements                    Shape.” In fact, the ﬁrst line of the Rectangle class deﬁnition is:                    public class Rectangle extends Rectangle2D implements Shape, Serializable                    Rectangle inherits methods from Rectangle2D and provides implementations                    for the methods in Shape and Serializable.                     In GridWorld the Location class implements the java.lang.Comparable in-                    terface by providing compareTo, which is similar to compareCards in Sec-                    tion 13.5.  GridWorld also deﬁnes a new interface, Grid, that speciﬁes                    the methods a Grid should provide. And it includes two implementations,                    BoundedGrid and UnboundedGrid.                     The Student Manual uses the abbreviation API, which stands for “ap-                    plication programming interface.”     The API is the set of methods that                    are available for you, the application programmer, to use.         See http:                    //en.wikipedia.org/wiki/Application_programming_interface.","206                                    Chapter 16. GridWorld: Part 3                              16.3       public and private                               Remember in Chapter 1 I said I would explain why the main method has the                             keyword public? Finally, the time has come.                              public means that the method can be invoked from other classes. The                             alternative is private, which means the method can only be invoked inside                             the class where it is deﬁned.                              Instance variables can also be public or private, with the same result: a                             private instance variable can be accessed only inside the class where it is                             deﬁned.                             The primary reason to make methods and instance variables private is to                             limit interactions between classes in order to manage complexity.                              For example, the Location class keeps its instance variables private. It has                             accessor methods getRow and getCol, but it provides no methods that mod-                             ify the instance variables. In eﬀect, Location objects are immutable, which                             means that they can be shared without worrying about unexpected behavior                             due to aliasing.                              Making methods private helps keep the API simple. Classes often include                             helper methods that are used to implement other methods, but making those                             methods part of the public API might be unnecessary and error-prone.                              Private methods and instance variables are language features that help pro-                             grammers ensure data encapsulation, which means that objects in one                             class are isolated from other classes.                                 16.4       Game of Life                               The mathematician John Conway invented the “Game of Life,” which he                             called a “zero-player game” because no players are needed to choose strategies                             or make decisions. After you set up the initial conditions, you watch the game                             play itself. But that turns out to be more interesting than it sounds; you can                             read about it at http://en.wikipedia.org/wiki/Conways_Game_of_Life.                              The goal of this exercises is to implement the Game of Life in GridWorld.                             The game board is the grid, and the pieces are Rocks.","16.5. LifeRunner                                                         207                      The game proceeds in turns, or time steps. At the beginning of the time                    step, each Rock is either “alive” or “dead”. On the screen, the color of the                    Rock indicates its status. The status of each Rock depends on the status of                    its neighbors. Each Rock has 8 neighbors, except the Rocks along the edge                    of the Grid. Here are the rules:                         If a dead Rock has exactly three neighbors, it comes to life! Otherwise                          it stays dead.                         If a live Rock has 2 or 3 neighbors, it survives. Otherwise it dies.                     Some consequences of these rules: If all Rocks are dead, no Rocks come to                    life. If you start with a single live Rock, it dies. But if you have 4 Rocks in                    a square, they keep each other alive, so that’s a stable conﬁguration.                     Most simple starting conﬁgurations either die out quickly or reach a stable                    conﬁguration. But there are a few starting conditions that display remarkable                    complexity. One of those is the r-pentomino: it starts with only 5 Rocks,                    runs for 1103 timesteps and ends in a stable conﬁguration with 116 live Rocks                    (see http://www.conwaylife.com/wiki/R-pentomino).                     The following sections are suggestions for implementing Game of Life in Grid-                    World. You can download my solution at http://thinkapjava.com/code/                    LifeRunner.java and http://thinkapjava.com/code/LifeRock.java.                        16.5       LifeRunner                      Make a copy of BugRunner.java named LifeRunner.java and add methods                    with the following prototypes:                          /**                          * Makes a Game of Life grid with an r-pentomino.                          */                         public static void makeLifeWorld(int rows, int cols)                           /**                          * Fills the grid with LifeRocks.                          */                         public static void makeRocks(ActorWorld world)","208                                    Chapter 16. GridWorld: Part 3                               makeLifeWorld should create a Grid of Actors and an ActorWorld, then                             invoke makeRocks, which should put a LifeRock at every location in the                             Grid.                                  16.6       LifeRock                               Make a copy of BoxBug.java named LifeRock.java. LifeRock should ex-                             tend Rock. Add an act method that does nothing. At this point you should                             be able to run the code and see a Grid full of Rocks.                              To keep track of the status of the Rocks, you can add a new instance variable,                             or you can use the Color of the Rock to indicate status. Either way, write                             methods with these prototypes:                                  /**                                   * Returns true if the Rock is alive.                                   */                                  public boolean isAlive()                                    /**                                   * Makes the Rock alive.                                   */                                  public void setAlive()                                    /**                                   * Makes the Rock dead.                                   */                                  public void setDead()                              Write a constructor that invokes setDead and conﬁrm that all Rocks are                             dead.                                  16.7       Simultaneous updates                               In the Game of Life, all Rocks are updated simultaneously; that is, each                             rock checks the status of its neighbors before any Rocks change their status.","16.7. Simultaneous updates                                               209                      Otherwise the behavior of the system would depend on the order of the                    updates.                     In order to implement simultaneous updates, I suggest that you write an act                    method that has two phases: during the ﬁrst phase, all Rocks count their                    neighbors and record the results; during the second phase, all Rocks update                    their status.                     Here’s what my act method looks like:                         /**                          * Check what phase we're in and calls the appropriate method.                          * Moves to the next phase.                          */                         public void act() {                              if (phase == 1) {                                   numNeighbors = countLiveNeighbors();                                   phase = 2;                              } else {                                   updateStatus();                                   phase = 1;                              }                         }                     phase and numNeighbors are instance variables. And here are the prototypes                    for countLiveNeighbors and updateStatus:                         /**                          * Counts the number of live neighbors.                          */                         public int countLiveNeighbors()                          /**                          * Updates the status of the Rock (live or dead) based on                          * the number of neighbors.                          */                         public void updateStatus()                     Start with a simple version of updateStatus that changes live rocks to dead                    and vice versa. Now run the program and conﬁrm that the Rocks change                    color. Every two steps in the World correspond to one timestep in the Game","210                                    Chapter 16. GridWorld: Part 3                               of Life.                              Now ﬁll in the bodies of countLiveNeighbors and updateStatus according                             to the rules and see if the system behaves as expected.                                  16.8       Initial conditions                               To change the initial conditions, you can use the GridWorld pop-up menus to                             set the status of the Rocks by invoking setAlive. Or you can write methods                             to automate the process.                              In LifeRunner, add a method called makeRow that creates an initial conﬁg-                             uration with n live Rocks in a row in the middle of the grid. What happens                             for diﬀerent values of n?                              Add a method called makePentomino that creates an r-pentomino in the                             middle of the Grid. The initial conﬁguration should look like this:                                                  If you run this conﬁguration for more than a few steps, it reaches the end                             of the Grid. The boundaries of the Grid change the behavior of the system;                             in order to see the full evolution of the r-pentomino, the Grid has to be big                             enough. You might have to experiment to ﬁnd the right size, and depending                             on the speed of your computer, it might take a while.                              The Game of Life web page describes other initial conditions that yield in-                             teresting results (http://www.conwaylife.com/). Choose one you like and                             implement it.","16.9. Exercises                                                          211                      There are also variations of the Game of Life based on diﬀerent rules. Try                    one out and see if you ﬁnd anything interesting.                       16.9       Exercises                      Exercise 16.1. Starting with a copy of BlueBug.java, write a class deﬁni-                    tion for a new kind of Bug that ﬁnds and eats ﬂowers. You can “eat” a ﬂower                    by invoking removeSelfFromGrid on it.                     Exercise 16.2. Now you know what you need to know to read Part 3 of the                    GridWorld Student Manual and do the exercises.                     Exercise 16.3. If you implemented the Game of Life, you are well prepared                    for Part 4 of the GridWorld Student Manual. Read it and do the exercises.                       Congratulations, you’re done!","212                                    Chapter 16. GridWorld: Part 3","Appendix A                         Graphics                            A.1       Java 2D Graphics                      This appendix provides examples and exercises that demonstrate Java graph-                    ics. There are several ways to create graphics in Java; the simplest is to use                    java.awt.Graphics. Here is a complete example:                    import java.awt.Canvas;                    import java.awt.Graphics;                    import javax.swing.JFrame;                     public class MyCanvas extends Canvas {                           public static void main(String[] args) {                              // make the frame                              JFrame frame = new JFrame();                              frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);                               // add the canvas                              Canvas canvas = new MyCanvas();                              canvas.setSize(400, 400);                              frame.getContentPane().add(canvas);                                // show the frame","214                                               Appendix A. Graphics                                         frame.pack();                                       frame.setVisible(true);                                  }                                   public void paint(Graphics g) {                                       // draw a circle                                       g.fillOval(100, 100, 200, 200);                                  }                             }                              You can download this code from http://thinkapjava.com/code/                             MyCanvas.java.                             The ﬁrst lines import the classes we need from java.awt and javax.swing.                              MyCanvas extends Canvas, which means that a MyCanvas object is a kind of                             Canvas that provides methods for drawing graphical objects.                              In main we                                 1. Create a JFrame, which is a window that can contain the canvas, but-                                   tons, menus, and other window components;                                 2. Create MyCanvas, set its width and height, and add it to the frame;                                   and                                 3. Display the frame on the screen.                              paint is a special method that gets invoked when MyCanvas needs to be                             drawn. If you run this code, you should see a black circle on a gray back-                             ground.                                A.2       Graphics methods                               To draw on the Canvas, you invoke methods on the Graphics object. The pre-                             vious example uses fillOval. Other methods include drawLine, drawRect                             and more. You can read the documentation of these methods at http:                             //download.oracle.com/javase/6/docs/api/java/awt/Graphics.html.                             Here is the prototype for fillOval:","A.3. Coordinates                                                         215                      public void fillOval(int x, int y, int width, int height)                    The parameters specify a bounding box, which is the rectangle in which                    the oval is drawn (as shown in the ﬁgure). The bounding box itself is not                    drawn.                    bounding box                                inscribed oval                         x and y specify the the location of the upper-left corner of the bounding box                    in the Graphics coordinate system.                        A.3       Coordinates                     You are probably familiar with Cartesian coordinates in two dimensions,                    where each location is identiﬁed by an x-coordinate (distance along the x-                    axis) and a y-coordinate. By convention, Cartesian coordinates increase to                    the right and up, as shown in the ﬁgure.                        Cartesian coordinates                Java graphical coordinates                                 positive y                                                                                    positive x                                         origin (0, 0)                                                                   origin (0, 0)                    negative x                positive x                                                                     positive y                                negative y                     By convention, computer graphics systems to use a coordinate system where                    the origin is in the upper-left corner, and the direction of the positive y-axis                    is down. Java follows this convention.","216                                               Appendix A. Graphics                               Coordinates are measured in pixels; each pixel corresponds to a dot on the                             screen. A typical screen is about 1000 pixels wide. Coordinates are always                             integers. If you want to use a ﬂoating-point value as a coordinate, you have                             to round it oﬀ (see Section 3.2).                                 A.4       Color                               To choose the color of a shape, invoke setColor on the Graphics object:                                  g.setColor(Color.red);                              setColor changes the current color; everything that gets drawn is the current                             color.                              Color.red is a value provided by the Color class; to use it you have to                             import java.awt.Color. Other colors include:                              black       blue      cyan     darkGray     gray     lightGray                             magenta     orange    pink     red          white    yellow                             You can create other colors by specifying red, green and blue (RGB) compo-                             nents. See http://download.oracle.com/javase/6/docs/api/java/awt/                             Color.html.                              You can control the background color of the Canvas by invoking                             Canvas.setBackground.                                 A.5       Mickey Mouse                              Let’s say we want to draw a picture of Mickey Mouse. We can use the oval we                             just drew as the face, and then add ears. To make the code more readable,                             let’s use Rectangles to represent bounding boxes.                              Here’s a method that takes a Rectangle and invokes fillOval.                                  public void boxOval(Graphics g, Rectangle bb) {                                       g.fillOval(bb.x, bb.y, bb.width, bb.height);                                  }                             And here’s a method that draws Mickey:","A.6. Glossary                                                            217                           public void mickey(Graphics g, Rectangle bb) {                              boxOval(g, bb);                               int dx = bb.width/2;                              int dy = bb.height/2;                              Rectangle half = new Rectangle(bb.x, bb.y, dx, dy);                                half.translate(-dx/2, -dy/2);                              boxOval(g, half);                                half.translate(dx*2, 0);                              boxOval(g, half);                         }                    The ﬁrst line draws the face. The next three lines create a smaller rectangle                    for the ears. We translate the rectangle up and left for the ﬁrst ear, then                    right for the second ear.                     The result looks like this:                                         You can download this code from http://thinkapjava.com/code/Mickey.                    java.                        A.6       Glossary                      coordinate: A variable or value that speciﬁes a location in a two-                          dimensional graphical window.","218                                               Appendix A. Graphics                               pixel: The unit in which coordinates are measured.                              bounding box: A common way to specify the coordinates of a rectangular                                   area.                                 A.7       Exercises                               Exercise A.1. Draw the ﬂag of Japan, a red circle on white background                             that is wider than it is tall.                              Exercise A.2. Modify Mickey.java to draw ears on the ears, and ears on                             those ears, and more ears all the way down until the smallest ears are only 3                             pixels wide.                              The result should look like Mickey Moose:                                                 Hint: you should only have to add or modify a few lines of code.                              You can download a solution from http://thinkapjava.com/code/                             MickeySoln.java.                              Exercise A.3.      1. Download      http://thinkapjava.com/code/Moire.                                   java and import it into your development environment.                                 2. Read the paint method and draw a sketch of what you expect it to                                   do. Now run it. Did you get what you expected? For an explana-                                   tion of what is going on, see http://en.wikipedia.org/wiki/Moire_                                   pattern.","A.7. Exercises                                                           219                         3. Modify the program so that the space between the circles is larger or                          smaller. See what happens to the image.                        4. Modify the program so that the circles are drawn in the center of the                          screen and concentric, as in the following ﬁgure (left). The distance                                                                                    e                          between the circles should be small enough that the Moir´ interference                          is apparent.                          concentric circles      radial Moire pattern                                     5. Write a method named radial that draws a radial set of line segments                          as shown in the ﬁgure (right), but they should be close enough together                                          e                          to create a Moir´ pattern.                       6. Just about any kind of graphical pattern can generate Moir´e-like inter-                          ference patterns. Play around and see what you can create.","220                                               Appendix A. Graphics","Appendix B                         Input and Output in Java                            B.1      System objects                     The System class provides methods and objects that get input from the                    keyboard, print text on the screen, and do ﬁle input and output (I/O).                    System.out is the object that displays on the screen. When you invoke                    print and println, you invoke them on System.out.                    You can even use System.out to print System.out:                     System.out.println(System.out);                    The result is:                    java.io.PrintStream@80cc0e5                    When Java prints an object, it prints the type of the object (PrintStream),                    the package where the type is deﬁned (java.io), and a unique identiﬁer for                    the object. On my machine the identiﬁer is 80cc0e5, but if you run the same                    code you will probably get something diﬀerent.                     There is also an object named System.in that makes it possible to get input                    from the keyboard. Unfortunately, it does not make it easy to get input from                    the keyboard.                       B.2      Keyboard input                     First, you have to use System.in to create a new InputStreamReader.","222                           Appendix B. Input and Output in Java                                    InputStreamReader in = new InputStreamReader(System.in);                             Then you use in to create a new BufferedReader:                                   BufferedReader keyboard = new BufferedReader(in);                             Finally you can invoke readLine on keyboard, to take input from the key-                             board and convert it to a String.                                  String s = keyboard.readLine();                                  System.out.println(s);                              There is only one problem. There are things that can go wrong when you                             invoke readLine, and they might throw an IOException. A method that                             throws an exception has to include it in the prototype, like this:                              public static void main(String[] args) throws IOException {                                  // body of main                             }                                 B.3      File input                               Here’s a program that reads lines from a ﬁle and prints them:                             import java.io.*;                               public class Words {                                   public static void main(String[] args)                                       throws FileNotFoundException, IOException {                                         processFile(\"words.txt\");                                  }                                    public static void processFile(String filename)                                       throws FileNotFoundException, IOException {                                         FileReader fileReader = new FileReader(filename);                                       BufferedReader in = new BufferedReader(fileReader);                                         while (true) {","B.4. Catching exceptions                                                 223                                     String s = in.readLine();                                   if (s == null) break;                                   System.out.println(s);                              }                         }                    }                    This ﬁrst line imports java.io, the package that contains FileReader,                    BufferedReader, and the rest of the elaborate class hierarchy Java uses to                    do common, simple things. The * means it imports all classes in the package.                       Here’s what the same program looks like in Python:                    for word in open('words.txt'):                         print word                     I’m not kidding. That’s the whole program, and it does the same thing.                        B.4      Catching exceptions                      In the previous example, processFile can throw FileNotFoundException                    and IOException. And since main calls processFile, it has to declare the                    same exceptions. In a larger program, main might declare every exception                    there is.                     The alternative is to catch the exception with a try statement. Here’s an                    example:                         public static void main(String[] args) {                              try {                                   processFile(\"words.txt\");                              } catch (Exception ex) {                                   System.out.println(\"That didn't work.           Here's why:\");                                   ex.printStackTrace();                              }                         }                     The structure is similar to an if statement. If the ﬁrst “branch” runs without                    causing an Exception, the second branch is skipped.","224                           Appendix B. Input and Output in Java                               If the ﬁrst branch causes an Exception, the ﬂow of execution jumps to the                             second branch, which tries to deal with the exceptional condition (by saying                             “error” in a polite way). In this case it prints an error message and the stack                             trace.                              You can download this code from http://thinkapjava.com/code/Words.                             java and the word list from http://thinkapjava.com/code/words.txt.                             Make sure both ﬁles are in the same folder. (If you are using an IDE like                             NetBeans or Eclipse, make sure the words.txt ﬁle is in your project directory.)                              Now go do Exercises 8.9, 8.10, and 8.11.","Appendix C                         Program development                           C.1      Strategies                      I present diﬀerent program development strategies throughout the book, so                    I wanted to pull them together here. The foundation of all strategies is                    incremental development, which goes like this:                        1. Start with a working program that does something visible, like printing                          something.                        2. Add a small number of lines of code at a time, and test the program                          after every change.                        3. Repeat until the program does what it is supposed to do.                    After every change, the program should produce some visible eﬀect that tests                    the new code. This approach to programming can save a lot of time.                     Because you only add a few lines of code at a time, it is easy to ﬁnd syntax                    errors. And because each version of the program produces a visible result,                    you are constantly testing your mental model of how the program works. If                    your mental model is wrong, you are confronted with the conﬂict (and have                    a chance to correct it) before you write a lot of bad code.                     The challenge of incremental development is that is it not easy to ﬁgure out                    a path from the starting place to a complete and correct program. To help                    with that, there are several strategies to choose from:","226                                Appendix C. Program development                               Encapsulation and generalization: If you don’t know yet how to divide                                   the computation into methods, start writing code in main, then look                                   for coherent chunks to encapsulate in a method, and generalize them                                   appropriately.                              Rapid prototyping: If you know what method to write, but not how to                                   write it, start with a rough draft that handles the simplest case, then                                   test it with other cases, extending and correcting as you go.                              Bottom-up: Start by writing simple methods, then assemble them into a                                   solution.                              Top-down: Use pseudocode to design the structure of the computation and                                   identify the methods you’ll need. Then write the methods and replace                                   the pseudocode with real code.                               Along the way, you might need some scaﬀolding. For example, each class                             should have a toString method that lets you print the state of an object in                             human-readable form. This method is useful for debugging, but usually not                             part of a ﬁnished program.                                 C.2      Failure modes                               If you are spending a lot of time debugging, it is probably because you are                             using an ineﬀective development strategy. Here are the failure modes I see                             most often (and occasionally fall into):                               Non-incremental developement: If you write more than a few lines of                                   code without compiling and testing, you are asking for trouble. One                                   time when I asked a student how the homework was coming along, he                                   said, “Great! I have it all written. Now I just have to debug it.”                               Attachment to bad code: If you write more than a few lines of code with-                                   out compiling and testing, you may not be able to debug it. Ever.                                   Sometimes the only strategy is (gasp!) to delete the bad code and start                                   over (using an incremental strategy). But beginners are often emotion-                                   ally attached to their code, even if it doesn’t work. The only way out                                   of this trap is to be ruthless.","C.2. Failure modes                                                       227                      Random-walk programming: I sometimes work with students who seem                          to be programming at random. They make a change, run the program,                          get an error, make a change, run the program, etc. The problem is that                          there is no apparent connection between the outcome of the program                          and the change. If you get an error message, take the time to read it.                          More generally, take time to think.                     Compiler submission: Error messages are useful, but they are not always                          right. For example, if the message says, “Semi-colon expected on line                          13,” that means there is a syntax error near line 13. But putting a                          semi-colon on line 13 is not always the solution. Don’t submit to the                          will of the compiler.                      The next chapter makes more suggestions for eﬀective debugging.","228                                Appendix C. Program development","Appendix D                         Debugging                           The best debugging strategy depends on what kind of error you have:                          Syntax errors are produced by the compiler and indicate that there is                          something wrong with the syntax of the program. Example: omitting                          the semi-colon at the end of a statement.                         Exceptions are produced if something goes wrong while the pro-                          gram is running. Example: an inﬁnite recursion eventually causes a                          StackOverflowException.                         Logic errors cause the program to do the wrong thing. Example: an                          expression may not be evaluated in the order you expect, yielding an                          unexpected result.                      The following sections are organized by error type; some techniques are useful                    for more than one type.                       D.1       Syntax errors                      The best kind of debugging is the kind you don’t have to do because you                    avoid making errors in the ﬁrst place. In the previous section, I suggested                    development strategies that minimize errors and makes it easy to ﬁnd them                    when you do. The key is to start with a working program and add small","230                                             Appendix D. Debugging                               amounts of code at a time. When there is an error, you will have a pretty                             good idea where it is.                             Nevertheless, you might ﬁnd yourself in one of the following situations. For                             each situation, I make some suggestions about how to proceed.                                The compiler is spewing error messages.                              If the compiler reports 100 error messages, that doesn’t mean there are 100                             errors in your program. When the compiler encounters an error, it often gets                             thrown oﬀ track for a while. It tries to recover and pick up again after the                             ﬁrst error, but sometimes it reports spurious errors.                              Only the ﬁrst error message is truly reliable. I suggest that you only ﬁx one                             error at a time, and then recompile the program. You may ﬁnd that one                             semi-colon “ﬁxes” 100 errors.                                 I’m getting a weird compiler message and it won’t go                             away.                              First of all, read the error message carefully. It is written in terse jargon, but                             often there is a carefully hidden kernel of information.                              If nothing else, the message will tell you where in the program the problem                             occurred. Actually, it tells you where the compiler was when it noticed a                             problem, which is not necessarily where the error is. Use the information                             the compiler gives you as a guideline, but if you don’t see an error where the                             compiler is pointing, broaden the search.                              Generally the error will be prior to the location of the error message, but                             there are cases where it will be somewhere else entirely. For example, if you                             get an error message at a method invocation, the actual error may be in the                             method deﬁnition.                              If you don’t ﬁnd the error quickly, take a breath and look more broadly at                             the entire program. Make sure the program is indented properly; that makes                             it easier to spot syntax errors.                             Now, start looking for common errors:","D.1. Syntax errors                                                       231                         1. Check that all parentheses and brackets are balanced and properly                          nested. All method deﬁnitions should be nested within a class deﬁni-                          tion. All program statements should be within a method deﬁnition.                         2. Remember that upper case letters are not the same as lower case letters.                         3. Check for semi-colons at the end of statements (and no semi-colons                          after squiggly-braces).                         4. Make sure that any strings in the code have matching quotation marks.                          Make sure that you use double-quotes for Strings and single quotes for                          characters.                         5. For each assignment statement, make sure that the type on the left is                          the same as the type on the right. Make sure that the expression on                          the left is a variable name or something else that you can assign a value                          to (like an element of an array).                         6. For each method invocation, make sure that the arguments you provide                          are in the right order, and have right type, and that the object you are                          invoking the method on is the right type.                         7. If you are invoking a value method, make sure you are doing something                          with the result. If you are invoking a void method, make sure you are                          not trying to do something with the result.                         8. If you are invoking an object method, make sure you are invoking it on                          an object with the right type. If you are invoking a class method from                          outside the class where it is deﬁned, make sure you specify the class                          name.                         9. Inside an object method you can refer to the instance variables without                          specifying an object. If you try that in a class method, you get a                          message like, “Static reference to non-static variable.”                      If nothing works, move on to the next section...","232                                             Appendix D. Debugging                               I can’t get my program to compile no matter what I do.                              If the compiler says there is an error and you don’t see it, that might be                             because you and the compiler are not looking at the same code. Check your                             development environment to make sure the program you are editing is the                             program the compiler is compiling. If you are not sure, try putting an obvious                             and deliberate syntax error right at the beginning of the program. Now                             compile again. If the compiler doesn’t ﬁnd the new error, there is probably                             something wrong with the way you set up the development environment.                              If you have examined the code thoroughly, and you’re sure the compiler is                             compiling the right code, it is time for desperate measures: debugging by                             bisection.                                   Make a copy of the ﬁle you are working on. If you are working on                                   Bob.java, make a copy called Bob.java.old.                                  Delete about half the code from Bob.java. Try compiling again.                                      – If the program compiles now, you know the error is in the other                                        half. Bring back about half of the code you deleted and repeat.                                      – If the program still doesn’t compile, the error must be in this half.                                        Delete about half of the code and repeat.                                  Once you have found and ﬁxed the error, start bringing back the code                                   you deleted, a little bit at a time.                              This process is ugly, but it goes faster than you might think, and it is very                             reliable.                                 I did what the compiler told me to do, but it still doesn’t                             work.                              Some compiler messages come with tidbits of advice, like “class Golfer must                             be declared abstract. It does not deﬁne int compareTo(java.lang.Object)                             from interface java.lang.Comparable.” It sounds like the compiler is telling                             you to declare Golfer as an abstract class, and if you are reading this book,                             you probably don’t know what that is or how to do it.","D.2. Run-time errors                                                     233                      Fortunately, the compiler is wrong. The solution in this case is to make sure                    Golfer has a method called compareTo that takes an Object as a parameter.                    Don’t let the compiler lead you by the nose. Error messages give you evidence                    that something is wrong, but the remedies they suggest are unreliable.                        D.2       Run-time errors                      My program hangs.                     If a program stops and seems to be doing nothing, we say it is hanging.                    Often that means that it is caught in an inﬁnite loop or an inﬁnite recursion.                          If there is a particular loop that you suspect is the problem, add a print                          statement immediately before the loop that says “entering the loop”                          and another immediately after that says “exiting the loop.”                           Run the program. If you get the ﬁrst message and not the second,                          you’ve got an inﬁnite loop. Go to the section titled “Inﬁnite loop.”                          Most of the time an inﬁnite recursion will cause the program to run for                          a while and then produce a StackOverﬂowException. If that happens,                          go to the section titled “Inﬁnite recursion.”                           If you are not getting a StackOverﬂowException, but you suspect there                          is a problem with a recursive method, you can still use the techniques                          in the inﬁnite recursion section.                         If neither of those suggestions helps, you might not understand the                          ﬂow of execution in your program. Go to the section titled “Flow of                          execution.”                       Inﬁnite loop                     If you think you have an inﬁnite loop and you know which loop it is, add a                    print statement at the end of the loop that prints the values of the variables                    in the condition, and the value of the condition.                    For example,","234                                             Appendix D. Debugging                                    while (x > 0 \&\& y < 0) {                                       // do something to x                                       // do something to y                                        System.out.println(\"x: \" + x);                                       System.out.println(\"y: \" + y);                                       System.out.println(\"condition: \" + (x > 0 \&\& y < 0));                                  }                             Now when you run the program you see three lines of output for each time                             through the loop. The last time through the loop, the condition should be                             false. If the loop keeps going, you will see the values of x and y and you                             might ﬁgure out why they are not updated correctly.                                Inﬁnite recursion                              Most of the time an inﬁnite recursion will cause the program to throw a                             StackOverflowException. But if the program is slow it may take a long                             time to ﬁll the stack.                              If you know which method is causing an inﬁnite recursion, check that there                             is a base case. There should be some condition that makes the method                             return without making a recursive invocation. If not, you need to rethink                             the algorithm and identify a base case.                              If there is a base case, but the program doesn’t seem to be reaching it, add a                             print statement at the beginning of the method that prints the parameters.                             Now when you run the program you see a few lines of output every time                             the method is invoked, and you see the values of the parameters. If the                             parameters are not moving toward the base case, you might see why not.                                Flow of execution                              If you are not sure how the ﬂow of execution is moving through your program,                             add print statements to the beginning of each method with a message like                             “entering method foo,” where foo is the name of the method.                              Now when you run the program it prints a trace of each method as it is                             invoked.","D.2. Run-time errors                                                     235                      You can also print the arguments each method receives. When you run the                    program, check whether the values are reasonable, and check for one of the                    most common errors—providing arguments in the wrong order.                       When I run the program I get an Exception.                      When an exception occurs, Java prints a message that includes the name                    of the exception, the line of the program where the problem occurred, and                    a stack trace. The stack trace includes the method that was running, the                    method that invoked it, the method that invoked that, and so on.                     The ﬁrst step is to examine the place in the program where the error occurred                    and see if you can ﬁgure out what happened.                     NullPointerException: You tried to access an instance variable or invoke                          a method on an object that is currently null. You should ﬁgure out                          which variable is null and then ﬁgure out how it got to be that way.                          Remember that when you declare a variable with an object type, it is                          initially null until you assign a value to it. For example, this code                          causes a NullPointerException:                          Point blank;                          System.out.println(blank.x);                    ArrayIndexOutOfBoundsException: The index you are using to access                          an array is either negative or greater than array.length-1. If you can                          ﬁnd the site where the problem is, add a print statement immediately                          before it to print the value of the index and the length of the array. Is                          the array the right size? Is the index the right value?                           Now work your way backwards through the program and see where the                          array and the index come from. Find the nearest assignment statement                          and see if it is doing the right thing.                           If either one is a parameter, go to the place where the method is invoked                          and see where the values are coming from.                     StackOverFlowException: See “Inﬁnite recursion.”                     FileNotFoundException: This means Java didn’t ﬁnd the ﬁle it was look-                          ing for. If you are using a project-based development environment like","236                                             Appendix D. Debugging                                     Eclipse, you might have to import the ﬁle into the project. Otherwise                                   make sure the ﬁle exists and that the path is correct. This problem                                   depends on your ﬁle system, so it can be hard to track down.                               ArithmeticException: Occurs when something goes wrong during an                                   arithmetic operation, most often division by zero.                                 I added so many print statements I get inundated with                              output.                              One of the problems with using print statements for debugging is that you                             can end up buried in output. There are two ways to proceed: either simplify                             the output or simplify the program.                              To simplify the output, you can remove or comment out print statements                             that aren’t helping, or combine them, or format the output so it is easier to                             understand. As you develop a program, you should write code to generate                             concise, informative visualizations of what the program is doing.                              To simplify the program, scale down the problem the program is working on.                             For example, if you are sorting an array, sort a small array. If the program                             takes input from the user, give it the simplest input that causes the error.                               Also, clean up the code. Remove dead code and reorganize the program to                             make it easier to read. For example, if you suspect that the error is in a                             deeply-nested part of the program, rewrite that part with simpler structure.                             If you suspect a large method, split it into smaller methods and test them                             separately.                              The process of ﬁnding the minimal test case often leads you to the bug.                             For example, if you ﬁnd that a program works when the array has an even                             number of elements, but not when it has an odd number, that gives you a                             clue about what is going on.                              Reorganizing the program can help you ﬁnd subtle bugs. If you make a                             change that you think doesn’t aﬀect the program, and it does, that can tip                             you oﬀ.","D.3. Logic errors                                                        237                     D.3       Logic errors                      My program doesn’t work.                     Logic errors are hard to ﬁnd because the compiler and the run-time sys-                    tem provide no information about what is wrong. Only you know what the                    program is supposed to do, and only you know that it isn’t doing it.                     The ﬁrst step is to make a connection between the code and the behavior                    you get. You need a hypothesis about what the program is actually doing.                    Here are some questions to ask yourself:                          Is there something the program was supposed to do, but doesn’t seem                          to be happening? Find the section of the code that performs that                          function and make sure it is executing when you think it should. See                          “Flow of execution” above.                         Is something happening that shouldn’t? Find code in your program                          that performs that function and see if it is executing when it shouldn’t.                         Is a section of code producing an unexpected eﬀect? Make sure you                          understand the code, especially if it invokes Java methods. Read the                          documentation for those methods, and try them out with simple test                          cases. They might not do what you think they do.                      To program, you need a mental model what your code does. If it doesn’t do                    what you expect, the problem might not be the program; it might be in your                    head.                    The best way to correct your mental model is to break the program into                    components (usually the classes and methods) and test them independently.                    Once you ﬁnd the discrepancy between your model and reality, you can solve                    the problem.                    Here are some common logic errors to check for:                          Remember that integer division always rounds down. If you want frac-                          tions, use doubles.                         Floating-point numbers are only approximate, so don’t rely on perfect                          accuracy.","238                                             Appendix D. Debugging                                   More generally, use integers for countable things and ﬂoating-point                                   numbers for measurable things.                                  If you use the assignment operator (=) instead of the equality operator                                   (==) in the condition of an if, while, or for statement, you might get                                   an expression that is syntactically legal and semantically wrong.                                   When you apply the equality operator (==) to an object, it checks                                   identity. If you meant to check equivalence, you should use the equals                                   method.                                   For user deﬁned types, equals checks identity. If you want a diﬀerent                                   notion of equivalence, you have to override it.                                   Inheritance can lead to subtle logic errors, because you can run inher-                                   ited code without realizing it. See “Flow of Execution” above.                                I’ve got a big hairy expression and it doesn’t do what I                              expect.                              Writing complex expressions is ﬁne as long as they are readable, but they                             can be hard to debug. It is often a good idea to break a complex expression                             into a series of assignments to temporary variables.                              For example:                             rect.setLocation(rect.getLocation().translate(                                                -rect.getWidth(), -rect.getHeight()));                              Can be rewritten as                             int dx = -rect.getWidth();                             int dy = -rect.getHeight();                             Point location = rect.getLocation();                             Point newLocation = location.translate(dx, dy);                             rect.setLocation(newLocation);                              The explicit version is easier to read, because the variable names provide                             additional documentation, and easier to debug, because you can check the                             types of the temporary variables and display their values.","D.3. Logic errors                                                        239                      Another problem that can occur with big expressions is that the order of                    evaluation may not be what you expect. For example, to evaluate        x  , you                                                                                          2π                    might write                    double y = x / 2 * Math.PI;                    That is not correct, because multiplication and division have the same prece-                    dence, and they are evaluated from left to right. This expression computes                    xπ/2.                     If you are not sure of the order of operations, use parentheses to make it                    explicit.                     double y = x / (2 * Math.PI);                    This version is correct, and more readable for other people who haven’t                    memorized the order of operations.                       My method doesn’t return what I expect.                      If you have a return statement with a complex expression, you don’t have a                    chance to print the value before returning. Again, you can use a temporary                    variable. For example, instead of                     public Rectangle intersection(Rectangle a, Rectangle b) {                         return new Rectangle(                              Math.min(a.x, b.x),                              Math.min(a.y, b.y),                              Math.max(a.x+a.width, b.x+b.width)-Math.min(a.x, b.x)                              Math.max(a.y+a.height, b.y+b.height)-Math.min(a.y, b.y) );                    }                    You could write                     public Rectangle intersection(Rectangle a, Rectangle b) {                         int x1 = Math.min(a.x, b.x);                         int y2 = Math.min(a.y, b.y);                         int x2 = Math.max(a.x+a.width, b.x+b.width);                         int y2 = Math.max(a.y+a.height, b.y+b.height);                         Rectangle rect = new Rectangle(x1, y1, x2-x1, y2-y1);                         return rect;                    }","240                                             Appendix D. Debugging                               Now you have the opportunity to display any of the intermediate variables                             before returning. And by reusing x1 and y1, you made the code smaller, too.                                My print statement isn’t doing anything                              If you use the println method, the output is displayed immediately, but if                             you use print (at least in some environments) the output gets stored without                             being displayed until the next newline. If the program terminates without                             printing a newline, you may never see the stored output.                              If you suspect that this is happening to, change some or all of the print                             statements to println.                                 I’m really, really stuck and I need help                              First, get away from the computer for a few minutes. Computers emit waves                             that aﬀect the brain, causing the following symptoms:                                  Frustration and rage.                                  Superstitious beliefs (“the computer hates me”) and magical thinking                                   (“the program only works when I wear my hat backwards”).                                  Sour grapes (“this program is lame anyway”).                               If you suﬀer from any of these symptoms, get up and go for a walk. When                             you are calm, think about the program. What is it doing? What are possible                             causes of that behavior? When was the last time you had a working program,                             and what did you do next?                              Sometimes it just takes time to ﬁnd a bug. I often ﬁnd bugs when I let my                             mind wander. Good places to ﬁnd bugs are trains, showers, and bed.                                No, I really need help.                               It happens. Even the best programmers get stuck. Sometimes you need a                             fresh pair of eyes.","D.3. Logic errors                                                        241                      Before you bring someone else in, make sure you have tried the techniques                    described above. Your program should be as simple as possible, and you                    should be working on the smallest input that causes the error. You should                    have print statements in the appropriate places (and the output they produce                    should be comprehensible). You should understand the problem well enough                    to describe it concisely.                     When you bring someone in to help, give them the information they need.                          What kind of bug is it? Syntax, run-time, or logic?                         What was the last thing you did before this error occurred? What were                          the last lines of code that you wrote, or what is the new test case that                          fails?                         If the bug occurs at compile-time or run-time, what is the error message,                          and what part of the program does it indicate?                          What have you tried, and what have you learned?                      By the time you explain the problem to someone, you might see the answer.                    This phenomenon is so common that some people recommend a debugging                    technique called “rubber ducking.” Here’s how it works:                         1. Buy a standard-issue rubber duck.                         2. When you are really stuck on a problem, put the rubber duck on the                          desk in front of you and say, “Rubber duck, I am stuck on a problem.                          Here’s what’s happening...”                         3. Explain the problem to the rubber duck.                        4. See the solution.                         5. Thank the rubber duck.                      I am not kidding.     See http://en.wikipedia.org/wiki/Rubber_duck_                    debugging.","242                                             Appendix D. Debugging                               I found the bug!                              When you ﬁnd the bug, it is usually obvious how to ﬁx it. But not always.                             Sometimes what seems to be a bug is really an indication that you don’t                             understand the program, or there is an error in your algorithm. In these                             cases, you might have to rethink the algorithm, or adjust your mental model.                             Take some time away from the computer to think, work through test cases                             by hand, or draw diagrams to represent the computation.                              After you ﬁx the bug, don’t just start in making new errors. Take a minute                             to think about what kind of bug it was, why you made the error, how the                             error manifested itself, and what you could have done to ﬁnd it faster. Next                             time you see something similar, you will be able to ﬁnd the bug more quickly.","Index                         abstract parameter, 177, 178            bug, 4                    Abstract Window Toolkit, see AWT                                                            Card, 165                    abstraction, 177, 178                                                            Cartesian coordinate, 215                    algorithm, 144, 145                                                            char, 91                    aliasing, 112, 116, 170, 185                                                            charAt, 91                    ambiguity, 7, 169                                                            Church, Alonzo, 64                    argument, 27, 33, 37                                                            class, 31, 37, 145                    arithmetic                                                                Card, 165                        ﬂoating-point, 26, 142                                                                Date, 137                        integer, 19                                                                Frame, 213                    array, 149, 158                                                                Graphics, 213                        compared to object, 151                                                                Math, 27                        copying, 151                                                                name, 9                        element, 150                                                                parent, 198                        length, 153                                                                Point, 108                        of Cards, 181                                                                Rectangle, 110                        of object, 171                                                                String, 91, 98                        of String, 167                                                                Time, 35, 132                        traverse, 155                                                            class deﬁnition, 8, 131                    assignment, 15, 22, 75                                                            class hierarchy, 198                    AWT, 107, 116                                                            class method, 194, 200                    base case, 47                           class variables, 189, 190                    bisection                               collection, 152                        debugging by, 232                   comment, 9, 11                    bisection search, 173, 174              comparable, 171                    body                                    compareCard, 170                        loop, 77                            compareTo, 98                    boolean, 61, 63, 68                     comparison                    bounding box, 215, 218                      operator, 40                    braces, squiggly, 9                         String, 98","244                                                                    Index                               compile, 2, 11                          Doyle, Arthur Conan, 6                             compiler, 230                           drawOval, 214                             complete ordering, 170                             composition, 20, 22, 28, 59, 165, 171,  eﬃciency, 186                                     172                             element, 150, 158                             concatenate, 20, 22                     encapsulation, 81–83, 86, 100, 112                             conditional, 39, 47                     encode, 166, 178                                 alternative, 40                     encrypt, 166                                 chained, 41, 47                     equals, 98, 196                                 nested, 42, 47                      equivalence, 178                             conditional operator, 170               equivalent, 169                             constructor, 133, 145, 167, 182, 185    error, 11                             coordinate, 215, 218                        logic, 5, 229                             correctness, 177                            run-time, 5, 93, 229                             counter, 97, 100, 155                       syntax, 4, 229                             current object, 195, 197, 200           error messages, 230                                                                     Exception, 235                             Date, 137                               exception, 5, 11, 99, 229                             dead code, 56, 68                           ArrayOutOfBounds, 150                             dealing, 185                                NullPointer, 114, 172                             debugging, 4, 11, 229                       StackOverﬂow, 177                             debugging by bisection, 232                 StringIndexOutOfBounds, 93                             deck, 171, 177, 181                     explicit, 200                             declaration, 15, 108                    expression, 18, 20, 22, 27, 28, 150                             decrement, 97, 100, 139                     big and hairy, 238                             deﬁnition                                   boolean, 61                                 class, 8                             deterministic, 153, 158                 factorial, 64                             diagram                                 ﬁbonacci, 67                                 stack, 34, 46, 66                   ﬁle input, 222                                 state, 46, 66                       ﬁll-in method, 141                             division                                ﬁndBisect, 174                                 ﬂoating-point, 78                   ﬁndCard, 173                                 integer, 19                         ﬂoating-point, 25, 37                             documentation, 91, 95                   ﬂow of execution, 234                             dot notation, 109                       for, 152                             double(ﬂoating-point), 25               formal language, 6, 11                             double-quote, 92                        Frame, 213","Index                                                                    245                      function, 137                           interpret, 2, 11                    functional programming, 193             iteration, 76, 86                    garbage collection, 114, 116            keyboard, 221                    generalization, 81, 83, 84, 86, 100, keyword, 18, 22                            112, 143                    Graphics, 213                           language                                                                complete, 64                    graphics coordinate, 215                                                                formal, 6                    Greenﬁeld, Larry, 6                                                                high-level, 2                    hanging, 233                                low-level, 2                    hello world, 8                              natural, 6, 169                    helper method, 184, 190                     programming, 1, 193                    high-level language, 2, 11                  safe, 5                    histogram, 155, 157                     leap of faith, 66, 188                    Holmes, Sherlock, 6                     length                                                                array, 153                    identical, 169                                                                String, 92                    identity, 178                                                            library, 9                    immutable, 98                                                            linear search, 173                    implicit, 200                                                            Linux, 6                    import, 107                                                            literalness, 7                    import statement, 223                                                            local variable, 83, 86                    increment, 97, 100, 139                 logarithm, 78                    incremental development, 57, 142                                                            logic error, 5, 229                    index, 93, 100, 150, 158, 172                                                            logical operator, 62                    indexOf, 95                                                            loop, 77, 86, 150                    inﬁnite loop, 77, 86, 233                                                                body, 77                    inﬁnite recursion, 177, 233                                                                counting, 96                    inheritance, 197                                                                for, 152                    initialization, 25, 36, 62                                                                inﬁnite, 77, 86                    input                                                                nested, 172                        ﬁle, 222                                search, 173                        keyboard, 221                                                            loop variable, 81, 84, 93, 150                    instance, 116, 145                                                            looping and counting, 155                    instance variable, 109, 116, 132, 181,                                                            low-level language, 2, 11                            197                    integer division, 19                    main, 29                    interface, 205                          map to, 166","246                                                                    Index                               Math class, 27                              array of, 171                             mental model, 237                           as parameter, 110                             mergesort, 186                              as return type, 111                             method, 9, 31, 37, 82                       compared to array, 151                                 boolean, 63                             current, 195                                 class, 194, 197                         mutable, 111                                 constructor, 133                        printing, 136                                 deﬁnition, 29                           System, 221                                 equals, 196                         object method, 91, 194, 200                                 ﬁll-in, 141                         object type, 115, 131                                 Graphics, 214                       object-oriented design, 199                                 helper, 184, 190                    object-oriented programming, 193                                 main, 29                            operand, 19, 22                                 modiﬁer, 140                        operator, 18, 22                                 multiple parameter, 35                  comparison, 40                                 object, 91, 194, 197                    conditional, 68, 170                                 pure function, 137                      decrement, 97, 139                                 string, 91                              increment, 97, 139                                 toString, 195                           logical, 62, 68                                 value, 36, 55                           modulus, 39                                 void, 55                                object, 137                             Mickey Mouse, 216                           relational, 40, 62                             model                                       string, 20                                 mental, 237                         order of evaluation, 238                             modiﬁer, 140, 145                       order of operations, 19                             modulus, 39, 47                         ordering, 170                             multiple assignment, 75                 overloading, 60, 68, 134, 185, 197                             mutable, 111                                                                     package, 107, 116                             natural language, 6, 11, 169            parameter, 33, 37, 110                             nested structure, 42, 63, 165               abstract, 177                             new, 108, 135, 182                          multiple, 35                             newline, 13, 45                         parent class, 198                             nondeterministic, 153                   parse, 7, 11                             null, 114, 149, 172                     partial ordering, 170                                                                     pixel, 215, 218                             Object, 198                             poetry, 7                             object, 100, 107, 137                   Point, 108","Index                                                                    247                      portable, 2                             reference, 108, 112, 116, 168, 183, 185                    precedence, 19, 238                     relational operator, 40, 62                    primitive type, 115                     return, 43, 55, 111                    print, 9, 13, 136                           inside loop, 174                        array of Cards, 173                 return statement, 239                        Card, 167                           return type, 68                    print statement, 236, 240               return value, 55, 68                    printDeck, 173, 182                     rounding, 26                    problem-solving, 11                     run-time error, 5, 93, 99, 114, 150,                    procedural programming, 193                     172, 229                    program development, 57, 83, 86,                            155, 183                        safe language, 5                        incremental, 142                    sameCard, 169                        planning, 142                       scaﬀolding, 58, 68                    programming                             searching, 173                        functional, 193                     selection sort, 184                        object-oriented, 193                semantics, 5, 11, 62                        procedural, 193                     setColor, 214                    programming language, 1, 193            shuﬄing, 183, 185                    programming style, 193                  sorting, 184, 186                    prose, 7                                squiggly braces, 9                    prototype, 177                          stack, 46, 66                    prototyping, 142                        stack diagram, 34                    pseudocode, 183, 190                    startup class, 145                    pseudorandom, 158                       state, 108, 116                    public, 9                               state diagram, 108, 116, 149, 168,                    pure function, 137, 141, 145                    172, 182                                                            statement, 3, 11                    quote, 92                                   assignment, 15, 75                                                                comment, 9                    random number, 153, 183                     conditional, 39                    range, 157                                  declaration, 15, 108                    rank, 166                                   for, 152                    Rectangle, 110                              import, 107, 223                    recursion, 44, 47, 64, 175, 188             initialization, 62                        inﬁnite, 177                            new, 108, 135, 182                    recursive, 45                               print, 9, 13, 136, 236, 240                    redundancy, 7                               return, 43, 55, 111, 174, 239","248                                                                    Index                                   try, 223                                primitive, 115                                 while, 76                               String, 13, 107                             static, 9, 56, 133, 194, 197                user-deﬁned, 131                             String, 13, 98, 107                     typecast, 47                                 array of, 167                       typecasting, 26, 43                                 length, 92                                                                     user-deﬁned type, 131                                 reference to, 168                             String method, 91                                                                     value, 15, 22                             string operator, 20                                                                         char, 92                             subdeck, 177, 184                       value method, 36, 55                             suit, 166                                                                     variable, 15, 22                             swapCards, 183                              instance, 109, 132, 181, 197                             syntax, 4, 11, 230                                                                         local, 83, 86                             syntax error, 4, 229                        loop, 81, 84, 93, 150                             System object, 221                          temporary, 56, 238                                                                      void, 55, 68, 137                             table, 78                                 two-dimensional, 80                 while statement, 76                             temporary variable, 56, 238                             testing, 177, 187                             this, 134, 195, 197, 200                             Time, 132                             toLowerCase, 98                             Torvalds, Linux, 6                             toString, 195                             toUpperCase, 98                             traverse, 93, 100, 173                                 array, 155                                 counting, 96                             try statement, 223                             Turing, Alan, 64, 98                             type, 22                                 array, 149                                 char, 91                                 conversion, 43                                 double, 25                                 int, 19                                 object, 115, 131"];