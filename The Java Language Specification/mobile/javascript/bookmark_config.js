var ols=[{caption:"The Java® Language Specification",page:"1",url:"",level:"1",children:[]},{caption:"Table of Contents",page:"5",url:"",level:"1",children:[]},{caption:"Preface to the Java SE 8 Edition",page:"19",url:"",level:"1",children:[]},{caption:"1. Introduction",page:"21",url:"",level:"1",children:[{caption:"1.1. Organization of the Specification",page:"22",url:"",level:"2",children:[]},{caption:"1.2. Example Programs",page:"26",url:"",level:"2",children:[]},{caption:"1.3. Notation",page:"26",url:"",level:"2",children:[]},{caption:"1.4. Relationship to Predefined Classes and Interfaces",page:"27",url:"",level:"2",children:[]},{caption:"1.5. Feedback",page:"27",url:"",level:"2",children:[]},{caption:"1.6. References",page:"27",url:"",level:"2",children:[{caption:"Bibliography",page:"27",url:"",level:"3",children:[]}]}]},{caption:"2. Grammars",page:"29",url:"",level:"1",children:[{caption:"2.1. Context-Free Grammars",page:"29",url:"",level:"2",children:[]},{caption:"2.2. The Lexical Grammar",page:"29",url:"",level:"2",children:[]},{caption:"2.3. The Syntactic Grammar",page:"30",url:"",level:"2",children:[]},{caption:"2.4. Grammar Notation",page:"30",url:"",level:"2",children:[]}]},{caption:"3. Lexical Structure",page:"35",url:"",level:"1",children:[{caption:"3.1. Unicode",page:"35",url:"",level:"2",children:[]},{caption:"3.2. Lexical Translations",page:"36",url:"",level:"2",children:[]},{caption:"3.3. Unicode Escapes",page:"37",url:"",level:"2",children:[]},{caption:"3.4. Line Terminators",page:"39",url:"",level:"2",children:[]},{caption:"3.5. Input Elements and Tokens",page:"39",url:"",level:"2",children:[]},{caption:"3.6. White Space",page:"40",url:"",level:"2",children:[]},{caption:"3.7. Comments",page:"41",url:"",level:"2",children:[]},{caption:"3.8. Identifiers",page:"42",url:"",level:"2",children:[]},{caption:"3.9. Keywords",page:"44",url:"",level:"2",children:[]},{caption:"3.10. Literals",page:"44",url:"",level:"2",children:[{caption:"3.10.1. Integer Literals",page:"45",url:"",level:"3",children:[]},{caption:"3.10.2. Floating-Point Literals",page:"51",url:"",level:"3",children:[]},{caption:"3.10.3. Boolean Literals",page:"54",url:"",level:"3",children:[]},{caption:"3.10.4. Character Literals",page:"54",url:"",level:"3",children:[]},{caption:"3.10.5. String Literals",page:"55",url:"",level:"3",children:[]},{caption:"3.10.6. Escape Sequences for Character and String Literals",page:"57",url:"",level:"3",children:[]},{caption:"3.10.7. The Null Literal",page:"58",url:"",level:"3",children:[]}]},{caption:"3.11. Separators",page:"59",url:"",level:"2",children:[]},{caption:"3.12. Operators",page:"59",url:"",level:"2",children:[]}]},{caption:"4. Types, Values, and Variables",page:"61",url:"",level:"1",children:[{caption:"4.1. The Kinds of Types and Values",page:"61",url:"",level:"2",children:[]},{caption:"4.2. Primitive Types and Values",page:"62",url:"",level:"2",children:[{caption:"4.2.1. Integral Types and Values",page:"63",url:"",level:"3",children:[]},{caption:"4.2.2. Integer Operations",page:"63",url:"",level:"3",children:[]},{caption:"4.2.3. Floating-Point Types, Formats, and Values",page:"65",url:"",level:"3",children:[]},{caption:"4.2.4. Floating-Point Operations",page:"68",url:"",level:"3",children:[]},{caption:"4.2.5. The boolean Type and boolean Values",page:"71",url:"",level:"3",children:[]}]},{caption:"4.3. Reference Types and Values",page:"72",url:"",level:"2",children:[{caption:"4.3.1. Objects",page:"73",url:"",level:"3",children:[]},{caption:"4.3.2. The Class Object",page:"76",url:"",level:"3",children:[]},{caption:"4.3.3. The Class String",page:"76",url:"",level:"3",children:[]},{caption:"4.3.4. When Reference Types Are the Same",page:"77",url:"",level:"3",children:[]}]},{caption:"4.4. Type Variables",page:"77",url:"",level:"2",children:[]},{caption:"4.5. Parameterized Types",page:"79",url:"",level:"2",children:[{caption:"4.5.1. Type Arguments of Parameterized Types",page:"80",url:"",level:"3",children:[]},{caption:"4.5.2. Members and Constructors of Parameterized Types",page:"83",url:"",level:"3",children:[]}]},{caption:"4.6. Type Erasure",page:"84",url:"",level:"2",children:[]},{caption:"4.7. Reifiable Types",page:"85",url:"",level:"2",children:[]},{caption:"4.8. Raw Types",page:"86",url:"",level:"2",children:[]},{caption:"4.9. Intersection Types",page:"90",url:"",level:"2",children:[]},{caption:"4.10. Subtyping",page:"91",url:"",level:"2",children:[{caption:"4.10.1. Subtyping among Primitive Types",page:"91",url:"",level:"3",children:[]},{caption:"4.10.2. Subtyping among Class and Interface Types",page:"92",url:"",level:"3",children:[]},{caption:"4.10.3. Subtyping among Array Types",page:"93",url:"",level:"3",children:[]},{caption:"4.10.4. Least Upper Bound",page:"93",url:"",level:"3",children:[]}]},{caption:"4.11. Where Types Are Used",page:"96",url:"",level:"2",children:[]},{caption:"4.12. Variables",page:"100",url:"",level:"2",children:[{caption:"4.12.1. Variables of Primitive Type",page:"101",url:"",level:"3",children:[]},{caption:"4.12.2. Variables of Reference Type",page:"101",url:"",level:"3",children:[]},{caption:"4.12.3. Kinds of Variables",page:"103",url:"",level:"3",children:[]},{caption:"4.12.4. final Variables",page:"105",url:"",level:"3",children:[]},{caption:"4.12.5. Initial Values of Variables",page:"107",url:"",level:"3",children:[]},{caption:"4.12.6. Types, Classes, and Interfaces",page:"108",url:"",level:"3",children:[]}]}]},{caption:"5. Conversions and Contexts",page:"113",url:"",level:"1",children:[{caption:"5.1. Kinds of Conversion",page:"116",url:"",level:"2",children:[{caption:"5.1.1. Identity Conversion",page:"116",url:"",level:"3",children:[]},{caption:"5.1.2. Widening Primitive Conversion",page:"116",url:"",level:"3",children:[]},{caption:"5.1.3. Narrowing Primitive Conversion",page:"118",url:"",level:"3",children:[]},{caption:"5.1.4. Widening and Narrowing Primitive Conversion",page:"121",url:"",level:"3",children:[]},{caption:"5.1.5. Widening Reference Conversion",page:"121",url:"",level:"3",children:[]},{caption:"5.1.6. Narrowing Reference Conversion",page:"121",url:"",level:"3",children:[]},{caption:"5.1.7. Boxing Conversion",page:"122",url:"",level:"3",children:[]},{caption:"5.1.8. Unboxing Conversion",page:"124",url:"",level:"3",children:[]},{caption:"5.1.9. Unchecked Conversion",page:"125",url:"",level:"3",children:[]},{caption:"5.1.10. Capture Conversion",page:"125",url:"",level:"3",children:[]},{caption:"5.1.11. String Conversion",page:"127",url:"",level:"3",children:[]},{caption:"5.1.12. Forbidden Conversions",page:"128",url:"",level:"3",children:[]},{caption:"5.1.13. Value Set Conversion",page:"128",url:"",level:"3",children:[]}]},{caption:"5.2. Assignment Contexts",page:"129",url:"",level:"2",children:[]},{caption:"5.3. Invocation Contexts",page:"134",url:"",level:"2",children:[]},{caption:"5.4. String Contexts",page:"136",url:"",level:"2",children:[]},{caption:"5.5. Casting Contexts",page:"136",url:"",level:"2",children:[{caption:"5.5.1. Reference Type Casting",page:"140",url:"",level:"3",children:[]},{caption:"5.5.2. Checked Casts and Unchecked Casts",page:"144",url:"",level:"3",children:[]},{caption:"5.5.3. Checked Casts at Run Time",page:"145",url:"",level:"3",children:[]}]},{caption:"5.6. Numeric Contexts",page:"147",url:"",level:"2",children:[{caption:"5.6.1. Unary Numeric Promotion",page:"147",url:"",level:"3",children:[]},{caption:"5.6.2. Binary Numeric Promotion",page:"148",url:"",level:"3",children:[]}]}]},{caption:"6. Names",page:"151",url:"",level:"1",children:[{caption:"6.1. Declarations",page:"152",url:"",level:"2",children:[]},{caption:"6.2. Names and Identifiers",page:"159",url:"",level:"2",children:[]},{caption:"6.3. Scope of a Declaration",page:"161",url:"",level:"2",children:[]},{caption:"6.4. Shadowing and Obscuring",page:"164",url:"",level:"2",children:[{caption:"6.4.1. Shadowing",page:"166",url:"",level:"3",children:[]},{caption:"6.4.2. Obscuring",page:"169",url:"",level:"3",children:[]}]},{caption:"6.5. Determining the Meaning of a Name",page:"170",url:"",level:"2",children:[{caption:"6.5.1. Syntactic Classification of a Name According to Context",page:"171",url:"",level:"3",children:[]},{caption:"6.5.2. Reclassification of Contextually Ambiguous Names",page:"174",url:"",level:"3",children:[]},{caption:"6.5.3. Meaning of Package Names",page:"176",url:"",level:"3",children:[{caption:"6.5.3.1. Simple Package Names",page:"177",url:"",level:"4",children:[]},{caption:"6.5.3.2. Qualified Package Names",page:"177",url:"",level:"4",children:[]}]},{caption:"6.5.4. Meaning of PackageOrTypeNames",page:"177",url:"",level:"3",children:[{caption:"6.5.4.1. Simple PackageOrTypeNames",page:"177",url:"",level:"4",children:[]},{caption:"6.5.4.2. Qualified PackageOrTypeNames",page:"177",url:"",level:"4",children:[]}]},{caption:"6.5.5. Meaning of Type Names",page:"177",url:"",level:"3",children:[{caption:"6.5.5.1. Simple Type Names",page:"178",url:"",level:"4",children:[]},{caption:"6.5.5.2. Qualified Type Names",page:"178",url:"",level:"4",children:[]}]},{caption:"6.5.6. Meaning of Expression Names",page:"178",url:"",level:"3",children:[{caption:"6.5.6.1. Simple Expression Names",page:"178",url:"",level:"4",children:[]},{caption:"6.5.6.2. Qualified Expression Names",page:"179",url:"",level:"4",children:[]}]},{caption:"6.5.7. Meaning of Method Names",page:"182",url:"",level:"3",children:[{caption:"6.5.7.1. Simple Method Names",page:"182",url:"",level:"4",children:[]}]}]},{caption:"6.6. Access Control",page:"183",url:"",level:"2",children:[{caption:"6.6.1. Determining Accessibility",page:"184",url:"",level:"3",children:[]},{caption:"6.6.2. Details on protected Access",page:"188",url:"",level:"3",children:[{caption:"6.6.2.1. Access to a protected Member",page:"189",url:"",level:"4",children:[]},{caption:"6.6.2.2. Qualified Access to a protected Constructor",page:"189",url:"",level:"4",children:[]}]}]},{caption:"6.7. Fully Qualified Names and Canonical Names",page:"191",url:"",level:"2",children:[]}]},{caption:"7. Packages",page:"195",url:"",level:"1",children:[{caption:"7.1. Package Members",page:"195",url:"",level:"2",children:[]},{caption:"7.2. Host Support for Packages",page:"197",url:"",level:"2",children:[]},{caption:"7.3. Compilation Units",page:"199",url:"",level:"2",children:[]},{caption:"7.4. Package Declarations",page:"200",url:"",level:"2",children:[{caption:"7.4.1. Named Packages",page:"200",url:"",level:"3",children:[]},{caption:"7.4.2. Unnamed Packages",page:"201",url:"",level:"3",children:[]},{caption:"7.4.3. Observability of a Package",page:"201",url:"",level:"3",children:[]}]},{caption:"7.5. Import Declarations",page:"202",url:"",level:"2",children:[{caption:"7.5.1. Single-Type-Import Declarations",page:"202",url:"",level:"3",children:[]},{caption:"7.5.2. Type-Import-on-Demand Declarations",page:"205",url:"",level:"3",children:[]},{caption:"7.5.3. Single-Static-Import Declarations",page:"206",url:"",level:"3",children:[]},{caption:"7.5.4. Static-Import-on-Demand Declarations",page:"206",url:"",level:"3",children:[]}]},{caption:"7.6. Top Level Type Declarations",page:"207",url:"",level:"2",children:[]}]},{caption:"8. Classes",page:"211",url:"",level:"1",children:[{caption:"8.1. Class Declarations",page:"213",url:"",level:"2",children:[{caption:"8.1.1. Class Modifiers",page:"213",url:"",level:"3",children:[{caption:"8.1.1.1. abstract Classes",page:"214",url:"",level:"4",children:[]},{caption:"8.1.1.2. final Classes",page:"216",url:"",level:"4",children:[]},{caption:"8.1.1.3. strictfp Classes",page:"216",url:"",level:"4",children:[]}]},{caption:"8.1.2. Generic Classes and Type Parameters",page:"216",url:"",level:"3",children:[]},{caption:"8.1.3. Inner Classes and Enclosing Instances",page:"219",url:"",level:"3",children:[]},{caption:"8.1.4. Superclasses and Subclasses",page:"222",url:"",level:"3",children:[]},{caption:"8.1.5. Superinterfaces",page:"224",url:"",level:"3",children:[]},{caption:"8.1.6. Class Body and Member Declarations",page:"227",url:"",level:"3",children:[]}]},{caption:"8.2. Class Members",page:"228",url:"",level:"2",children:[]},{caption:"8.3. Field Declarations",page:"233",url:"",level:"2",children:[{caption:"8.3.1. Field Modifiers",page:"237",url:"",level:"3",children:[{caption:"8.3.1.1. static Fields",page:"238",url:"",level:"4",children:[]},{caption:"8.3.1.2. final Fields",page:"241",url:"",level:"4",children:[]},{caption:"8.3.1.3. transient Fields",page:"241",url:"",level:"4",children:[]},{caption:"8.3.1.4. volatile Fields",page:"242",url:"",level:"4",children:[]}]},{caption:"8.3.2. Field Initialization",page:"243",url:"",level:"3",children:[]},{caption:"8.3.3. Forward References During Field Initialization",page:"244",url:"",level:"3",children:[]}]},{caption:"8.4. Method Declarations",page:"247",url:"",level:"2",children:[{caption:"8.4.1. Formal Parameters",page:"248",url:"",level:"3",children:[]},{caption:"8.4.2. Method Signature",page:"252",url:"",level:"3",children:[]},{caption:"8.4.3. Method Modifiers",page:"253",url:"",level:"3",children:[{caption:"8.4.3.1. abstract Methods",page:"254",url:"",level:"4",children:[]},{caption:"8.4.3.2. static Methods",page:"256",url:"",level:"4",children:[]},{caption:"8.4.3.3. final Methods",page:"256",url:"",level:"4",children:[]},{caption:"8.4.3.4. native Methods",page:"257",url:"",level:"4",children:[]},{caption:"8.4.3.5. strictfp Methods",page:"257",url:"",level:"4",children:[]},{caption:"8.4.3.6. synchronized Methods",page:"258",url:"",level:"4",children:[]}]},{caption:"8.4.4. Generic Methods",page:"259",url:"",level:"3",children:[]},{caption:"8.4.5. Method Result",page:"260",url:"",level:"3",children:[]},{caption:"8.4.6. Method Throws",page:"260",url:"",level:"3",children:[]},{caption:"8.4.7. Method Body",page:"262",url:"",level:"3",children:[]},{caption:"8.4.8. Inheritance, Overriding, and Hiding",page:"263",url:"",level:"3",children:[{caption:"8.4.8.1. Overriding (by Instance Methods)",page:"263",url:"",level:"4",children:[]},{caption:"8.4.8.2. Hiding (by Class Methods)",page:"267",url:"",level:"4",children:[]},{caption:"8.4.8.3. Requirements in Overriding and Hiding",page:"268",url:"",level:"4",children:[]},{caption:"8.4.8.4. Inheriting Methods with Override-Equivalent Signatures",page:"272",url:"",level:"4",children:[]}]},{caption:"8.4.9. Overloading",page:"273",url:"",level:"3",children:[]}]},{caption:"8.5. Member Type Declarations",page:"276",url:"",level:"2",children:[{caption:"8.5.1. Static Member Type Declarations",page:"277",url:"",level:"3",children:[]}]},{caption:"8.6. Instance Initializers",page:"277",url:"",level:"2",children:[]},{caption:"8.7. Static Initializers",page:"278",url:"",level:"2",children:[]},{caption:"8.8. Constructor Declarations",page:"278",url:"",level:"2",children:[{caption:"8.8.1. Formal Parameters",page:"279",url:"",level:"3",children:[]},{caption:"8.8.2. Constructor Signature",page:"280",url:"",level:"3",children:[]},{caption:"8.8.3. Constructor Modifiers",page:"280",url:"",level:"3",children:[]},{caption:"8.8.4. Generic Constructors",page:"281",url:"",level:"3",children:[]},{caption:"8.8.5. Constructor Throws",page:"282",url:"",level:"3",children:[]},{caption:"8.8.6. The Type of a Constructor",page:"282",url:"",level:"3",children:[]},{caption:"8.8.7. Constructor Body",page:"282",url:"",level:"3",children:[{caption:"8.8.7.1. Explicit Constructor Invocations",page:"283",url:"",level:"4",children:[]}]},{caption:"8.8.8. Constructor Overloading",page:"287",url:"",level:"3",children:[]},{caption:"8.8.9. Default Constructor",page:"287",url:"",level:"3",children:[]},{caption:"8.8.10. Preventing Instantiation of a Class",page:"288",url:"",level:"3",children:[]}]},{caption:"8.9. Enum Types",page:"289",url:"",level:"2",children:[{caption:"8.9.1. Enum Constants",page:"290",url:"",level:"3",children:[]},{caption:"8.9.2. Enum Body Declarations",page:"291",url:"",level:"3",children:[]},{caption:"8.9.3. Enum Members",page:"293",url:"",level:"3",children:[]}]}]},{caption:"9. Interfaces",page:"299",url:"",level:"1",children:[{caption:"9.1. Interface Declarations",page:"300",url:"",level:"2",children:[{caption:"9.1.1. Interface Modifiers",page:"300",url:"",level:"3",children:[{caption:"9.1.1.1. abstract Interfaces",page:"301",url:"",level:"4",children:[]},{caption:"9.1.1.2. strictfp Interfaces",page:"301",url:"",level:"4",children:[]}]},{caption:"9.1.2. Generic Interfaces and Type Parameters",page:"301",url:"",level:"3",children:[]},{caption:"9.1.3. Superinterfaces and Subinterfaces",page:"302",url:"",level:"3",children:[]},{caption:"9.1.4. Interface Body and Member Declarations",page:"304",url:"",level:"3",children:[]}]},{caption:"9.2. Interface Members",page:"304",url:"",level:"2",children:[]},{caption:"9.3. Field (Constant) Declarations",page:"305",url:"",level:"2",children:[{caption:"9.3.1. Initialization of Fields in Interfaces",page:"307",url:"",level:"3",children:[]}]},{caption:"9.4. Method Declarations",page:"308",url:"",level:"2",children:[{caption:"9.4.1. Inheritance and Overriding",page:"309",url:"",level:"3",children:[{caption:"9.4.1.1. Overriding (by Instance Methods)",page:"310",url:"",level:"4",children:[]},{caption:"9.4.1.2. Requirements in Overriding",page:"311",url:"",level:"4",children:[]},{caption:"9.4.1.3. Inheriting Methods with Override-Equivalent Signatures",page:"311",url:"",level:"4",children:[]}]},{caption:"9.4.2. Overloading",page:"312",url:"",level:"3",children:[]},{caption:"9.4.3. Interface Method Body",page:"313",url:"",level:"3",children:[]}]},{caption:"9.5. Member Type Declarations",page:"313",url:"",level:"2",children:[]},{caption:"9.6. Annotation Types",page:"314",url:"",level:"2",children:[{caption:"9.6.1. Annotation Type Elements",page:"315",url:"",level:"3",children:[]},{caption:"9.6.2. Defaults for Annotation Type Elements",page:"319",url:"",level:"3",children:[]},{caption:"9.6.3. Repeatable Annotation Types",page:"320",url:"",level:"3",children:[]},{caption:"9.6.4. Predefined Annotation Types",page:"324",url:"",level:"3",children:[{caption:"9.6.4.1. @Target",page:"324",url:"",level:"4",children:[]},{caption:"9.6.4.2. @Retention",page:"325",url:"",level:"4",children:[]},{caption:"9.6.4.3. @Inherited",page:"326",url:"",level:"4",children:[]},{caption:"9.6.4.4. @Override",page:"326",url:"",level:"4",children:[]},{caption:"9.6.4.5. @SuppressWarnings",page:"327",url:"",level:"4",children:[]},{caption:"9.6.4.6. @Deprecated",page:"328",url:"",level:"4",children:[]},{caption:"9.6.4.7. @SafeVarargs",page:"329",url:"",level:"4",children:[]},{caption:"9.6.4.8. @Repeatable",page:"330",url:"",level:"4",children:[]},{caption:"9.6.4.9. @FunctionalInterface",page:"330",url:"",level:"4",children:[]}]}]},{caption:"9.7. Annotations",page:"330",url:"",level:"2",children:[{caption:"9.7.1. Normal Annotations",page:"331",url:"",level:"3",children:[]},{caption:"9.7.2. Marker Annotations",page:"333",url:"",level:"3",children:[]},{caption:"9.7.3. Single-Element Annotations",page:"334",url:"",level:"3",children:[]},{caption:"9.7.4. Where Annotations May Appear",page:"335",url:"",level:"3",children:[]},{caption:"9.7.5. Multiple Annotations of the Same Type",page:"340",url:"",level:"3",children:[]}]},{caption:"9.8. Functional Interfaces",page:"341",url:"",level:"2",children:[]},{caption:"9.9. Function Types",page:"345",url:"",level:"2",children:[]}]},{caption:"10. Arrays",page:"351",url:"",level:"1",children:[{caption:"10.1. Array Types",page:"352",url:"",level:"2",children:[]},{caption:"10.2. Array Variables",page:"352",url:"",level:"2",children:[]},{caption:"10.3. Array Creation",page:"355",url:"",level:"2",children:[]},{caption:"10.4. Array Access",page:"355",url:"",level:"2",children:[]},{caption:"10.5. Array Store Exception",page:"356",url:"",level:"2",children:[]},{caption:"10.6. Array Initializers",page:"357",url:"",level:"2",children:[]},{caption:"10.7. Array Members",page:"359",url:"",level:"2",children:[]},{caption:"10.8. Class Objects for Arrays",page:"360",url:"",level:"2",children:[]},{caption:"10.9. An Array of Characters Is Not a String",page:"362",url:"",level:"2",children:[]}]},{caption:"11. Exceptions",page:"363",url:"",level:"1",children:[{caption:"11.1. The Kinds and Causes of Exceptions",page:"364",url:"",level:"2",children:[{caption:"11.1.1. The Kinds of Exceptions",page:"364",url:"",level:"3",children:[]},{caption:"11.1.2. The Causes of Exceptions",page:"365",url:"",level:"3",children:[]},{caption:"11.1.3. Asynchronous Exceptions",page:"366",url:"",level:"3",children:[]}]},{caption:"11.2. Compile-Time Checking of Exceptions",page:"367",url:"",level:"2",children:[{caption:"11.2.1. Exception Analysis of Expressions",page:"368",url:"",level:"3",children:[]},{caption:"11.2.2. Exception Analysis of Statements",page:"369",url:"",level:"3",children:[]},{caption:"11.2.3. Exception Checking",page:"370",url:"",level:"3",children:[]}]},{caption:"11.3. Run-Time Handling of an Exception",page:"372",url:"",level:"2",children:[]}]},{caption:"12. Execution",page:"377",url:"",level:"1",children:[{caption:"12.1. Java Virtual Machine Startup",page:"377",url:"",level:"2",children:[{caption:"12.1.1. Load the Class Test",page:"378",url:"",level:"3",children:[]},{caption:"12.1.2. Link Test: Verify, Prepare, (Optionally) Resolve",page:"378",url:"",level:"3",children:[]},{caption:"12.1.3. Initialize Test: Execute Initializers",page:"379",url:"",level:"3",children:[]},{caption:"12.1.4. Invoke Test.main",page:"380",url:"",level:"3",children:[]}]},{caption:"12.2. Loading of Classes and Interfaces",page:"380",url:"",level:"2",children:[{caption:"12.2.1. The Loading Process",page:"381",url:"",level:"3",children:[]}]},{caption:"12.3. Linking of Classes and Interfaces",page:"382",url:"",level:"2",children:[{caption:"12.3.1. Verification of the Binary Representation",page:"382",url:"",level:"3",children:[]},{caption:"12.3.2. Preparation of a Class or Interface Type",page:"383",url:"",level:"3",children:[]},{caption:"12.3.3. Resolution of Symbolic References",page:"383",url:"",level:"3",children:[]}]},{caption:"12.4. Initialization of Classes and Interfaces",page:"384",url:"",level:"2",children:[{caption:"12.4.1. When Initialization Occurs",page:"385",url:"",level:"3",children:[]},{caption:"12.4.2. Detailed Initialization Procedure",page:"387",url:"",level:"3",children:[]}]},{caption:"12.5. Creation of New Class Instances",page:"390",url:"",level:"2",children:[]},{caption:"12.6. Finalization of Class Instances",page:"393",url:"",level:"2",children:[{caption:"12.6.1. Implementing Finalization",page:"395",url:"",level:"3",children:[]},{caption:"12.6.2. Interaction with the Memory Model",page:"396",url:"",level:"3",children:[]}]},{caption:"12.7. Unloading of Classes and Interfaces",page:"398",url:"",level:"2",children:[]},{caption:"12.8. Program Exit",page:"399",url:"",level:"2",children:[]}]},{caption:"13. Binary Compatibility",page:"401",url:"",level:"1",children:[{caption:"13.1. The Form of a Binary",page:"402",url:"",level:"2",children:[]},{caption:"13.2. What Binary Compatibility Is and Is Not",page:"408",url:"",level:"2",children:[]},{caption:"13.3. Evolution of Packages",page:"409",url:"",level:"2",children:[]},{caption:"13.4. Evolution of Classes",page:"409",url:"",level:"2",children:[{caption:"13.4.1. abstract Classes",page:"409",url:"",level:"3",children:[]},{caption:"13.4.2. final Classes",page:"409",url:"",level:"3",children:[]},{caption:"13.4.3. public Classes",page:"410",url:"",level:"3",children:[]},{caption:"13.4.4. Superclasses and Superinterfaces",page:"410",url:"",level:"3",children:[]},{caption:"13.4.5. Class Type Parameters",page:"411",url:"",level:"3",children:[]},{caption:"13.4.6. Class Body and Member Declarations",page:"412",url:"",level:"3",children:[]},{caption:"13.4.7. Access to Members and Constructors",page:"413",url:"",level:"3",children:[]},{caption:"13.4.8. Field Declarations",page:"414",url:"",level:"3",children:[]},{caption:"13.4.9. final Fields and static Constant Variables",page:"417",url:"",level:"3",children:[]},{caption:"13.4.10. static Fields",page:"419",url:"",level:"3",children:[]},{caption:"13.4.11. transient Fields",page:"419",url:"",level:"3",children:[]},{caption:"13.4.12. Method and Constructor Declarations",page:"420",url:"",level:"3",children:[]},{caption:"13.4.13. Method and Constructor Type Parameters",page:"420",url:"",level:"3",children:[]},{caption:"13.4.14. Method and Constructor Formal Parameters",page:"421",url:"",level:"3",children:[]},{caption:"13.4.15. Method Result Type",page:"422",url:"",level:"3",children:[]},{caption:"13.4.16. abstract Methods",page:"422",url:"",level:"3",children:[]},{caption:"13.4.17. final Methods",page:"423",url:"",level:"3",children:[]},{caption:"13.4.18. native Methods",page:"423",url:"",level:"3",children:[]},{caption:"13.4.19. static Methods",page:"424",url:"",level:"3",children:[]},{caption:"13.4.20. synchronized Methods",page:"424",url:"",level:"3",children:[]},{caption:"13.4.21. Method and Constructor Throws",page:"424",url:"",level:"3",children:[]},{caption:"13.4.22. Method and Constructor Body",page:"424",url:"",level:"3",children:[]},{caption:"13.4.23. Method and Constructor Overloading",page:"425",url:"",level:"3",children:[]},{caption:"13.4.24. Method Overriding",page:"426",url:"",level:"3",children:[]},{caption:"13.4.25. Static Initializers",page:"426",url:"",level:"3",children:[]},{caption:"13.4.26. Evolution of Enums",page:"426",url:"",level:"3",children:[]}]},{caption:"13.5. Evolution of Interfaces",page:"426",url:"",level:"2",children:[{caption:"13.5.1. public Interfaces",page:"426",url:"",level:"3",children:[]},{caption:"13.5.2. Superinterfaces",page:"427",url:"",level:"3",children:[]},{caption:"13.5.3. Interface Members",page:"427",url:"",level:"3",children:[]},{caption:"13.5.4. Interface Type Parameters",page:"427",url:"",level:"3",children:[]},{caption:"13.5.5. Field Declarations",page:"428",url:"",level:"3",children:[]},{caption:"13.5.6. Interface Method Declarations",page:"428",url:"",level:"3",children:[]},{caption:"13.5.7. Evolution of Annotation Types",page:"429",url:"",level:"3",children:[]}]}]},{caption:"14. Blocks and Statements",page:"431",url:"",level:"1",children:[{caption:"14.1. Normal and Abrupt Completion of Statements",page:"431",url:"",level:"2",children:[]},{caption:"14.2. Blocks",page:"433",url:"",level:"2",children:[]},{caption:"14.3. Local Class Declarations",page:"433",url:"",level:"2",children:[]},{caption:"14.4. Local Variable Declaration Statements",page:"434",url:"",level:"2",children:[{caption:"14.4.1. Local Variable Declarators and Types",page:"435",url:"",level:"3",children:[]},{caption:"14.4.2. Execution of Local Variable Declarations",page:"436",url:"",level:"3",children:[]}]},{caption:"14.5. Statements",page:"436",url:"",level:"2",children:[]},{caption:"14.6. The Empty Statement",page:"438",url:"",level:"2",children:[]},{caption:"14.7. Labeled Statements",page:"439",url:"",level:"2",children:[]},{caption:"14.8. Expression Statements",page:"440",url:"",level:"2",children:[]},{caption:"14.9. The if Statement",page:"441",url:"",level:"2",children:[{caption:"14.9.1. The if-then Statement",page:"442",url:"",level:"3",children:[]},{caption:"14.9.2. The if-then-else Statement",page:"442",url:"",level:"3",children:[]}]},{caption:"14.10. The assert Statement",page:"442",url:"",level:"2",children:[]},{caption:"14.11. The switch Statement",page:"445",url:"",level:"2",children:[]},{caption:"14.12. The while Statement",page:"449",url:"",level:"2",children:[{caption:"14.12.1. Abrupt Completion of while Statement",page:"450",url:"",level:"3",children:[]}]},{caption:"14.13. The do Statement",page:"451",url:"",level:"2",children:[{caption:"14.13.1. Abrupt Completion of do Statement",page:"451",url:"",level:"3",children:[]}]},{caption:"14.14. The for Statement",page:"453",url:"",level:"2",children:[{caption:"14.14.1. The basic for Statement",page:"453",url:"",level:"3",children:[{caption:"14.14.1.1. Initialization of for Statement",page:"454",url:"",level:"4",children:[]},{caption:"14.14.1.2. Iteration of for Statement",page:"454",url:"",level:"4",children:[]},{caption:"14.14.1.3. Abrupt Completion of for Statement",page:"455",url:"",level:"4",children:[]}]},{caption:"14.14.2. The enhanced for statement",page:"456",url:"",level:"3",children:[]}]},{caption:"14.15. The break Statement",page:"458",url:"",level:"2",children:[]},{caption:"14.16. The continue Statement",page:"460",url:"",level:"2",children:[]},{caption:"14.17. The return Statement",page:"462",url:"",level:"2",children:[]},{caption:"14.18. The throw Statement",page:"464",url:"",level:"2",children:[]},{caption:"14.19. The synchronized Statement",page:"466",url:"",level:"2",children:[]},{caption:"14.20. The try statement",page:"467",url:"",level:"2",children:[{caption:"14.20.1. Execution of try-catch",page:"470",url:"",level:"3",children:[]},{caption:"14.20.2. Execution of try-finally and try-catch-finally",page:"472",url:"",level:"3",children:[]},{caption:"14.20.3. try-with-resources",page:"474",url:"",level:"3",children:[{caption:"14.20.3.1. Basic try-with-resources",page:"475",url:"",level:"4",children:[]},{caption:"14.20.3.2. Extended try-with-resources",page:"478",url:"",level:"4",children:[]}]}]},{caption:"14.21. Unreachable Statements",page:"478",url:"",level:"2",children:[]}]},{caption:"15. Expressions",page:"485",url:"",level:"1",children:[{caption:"15.1. Evaluation, Denotation, and Result",page:"485",url:"",level:"2",children:[]},{caption:"15.2. Forms of Expressions",page:"486",url:"",level:"2",children:[]},{caption:"15.3. Type of an Expression",page:"487",url:"",level:"2",children:[]},{caption:"15.4. FP-strict Expressions",page:"488",url:"",level:"2",children:[]},{caption:"15.5. Expressions and Run-Time Checks",page:"488",url:"",level:"2",children:[]},{caption:"15.6. Normal and Abrupt Completion of Evaluation",page:"490",url:"",level:"2",children:[]},{caption:"15.7. Evaluation Order",page:"492",url:"",level:"2",children:[{caption:"15.7.1. Evaluate Left-Hand Operand First",page:"492",url:"",level:"3",children:[]},{caption:"15.7.2. Evaluate Operands before Operation",page:"494",url:"",level:"3",children:[]},{caption:"15.7.3. Evaluation Respects Parentheses and Precedence",page:"495",url:"",level:"3",children:[]},{caption:"15.7.4. Argument Lists are Evaluated Left-to-Right",page:"496",url:"",level:"3",children:[]},{caption:"15.7.5. Evaluation Order for Other Expressions",page:"497",url:"",level:"3",children:[]}]},{caption:"15.8. Primary Expressions",page:"497",url:"",level:"2",children:[{caption:"15.8.1. Lexical Literals",page:"498",url:"",level:"3",children:[]},{caption:"15.8.2. Class Literals",page:"499",url:"",level:"3",children:[]},{caption:"15.8.3. this",page:"500",url:"",level:"3",children:[]},{caption:"15.8.4. Qualified this",page:"501",url:"",level:"3",children:[]},{caption:"15.8.5. Parenthesized Expressions",page:"501",url:"",level:"3",children:[]}]},{caption:"15.9. Class Instance Creation Expressions",page:"502",url:"",level:"2",children:[{caption:"15.9.1. Determining the Class being Instantiated",page:"504",url:"",level:"3",children:[]},{caption:"15.9.2. Determining Enclosing Instances",page:"506",url:"",level:"3",children:[]},{caption:"15.9.3. Choosing the Constructor and its Arguments",page:"507",url:"",level:"3",children:[]},{caption:"15.9.4. Run-Time Evaluation of Class Instance Creation Expressions",page:"510",url:"",level:"3",children:[]},{caption:"15.9.5. Anonymous Class Declarations",page:"511",url:"",level:"3",children:[{caption:"15.9.5.1. Anonymous Constructors",page:"511",url:"",level:"4",children:[]}]}]},{caption:"15.10. Array Creation and Access Expressions",page:"513",url:"",level:"2",children:[{caption:"15.10.1. Array Creation Expressions",page:"513",url:"",level:"3",children:[]},{caption:"15.10.2. Run-Time Evaluation of Array Creation Expressions",page:"514",url:"",level:"3",children:[]},{caption:"15.10.3. Array Access Expressions",page:"517",url:"",level:"3",children:[]},{caption:"15.10.4. Run-Time Evaluation of Array Access Expressions",page:"518",url:"",level:"3",children:[]}]},{caption:"15.11. Field Access Expressions",page:"520",url:"",level:"2",children:[{caption:"15.11.1. Field Access Using a Primary",page:"520",url:"",level:"3",children:[]},{caption:"15.11.2. Accessing Superclass Members using super",page:"523",url:"",level:"3",children:[]}]},{caption:"15.12. Method Invocation Expressions",page:"525",url:"",level:"2",children:[{caption:"15.12.1. Compile-Time Step 1: Determine Class or Interface to Search",page:"526",url:"",level:"3",children:[]},{caption:"15.12.2. Compile-Time Step 2: Determine Method Signature",page:"529",url:"",level:"3",children:[{caption:"15.12.2.1. Identify Potentially Applicable Methods",page:"535",url:"",level:"4",children:[]},{caption:"15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation",page:"537",url:"",level:"4",children:[]},{caption:"15.12.2.3. Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation",page:"539",url:"",level:"4",children:[]},{caption:"15.12.2.4. Phase 3: Identify Methods Applicable by Variable Arity Invocation",page:"539",url:"",level:"4",children:[]},{caption:"15.12.2.5. Choosing the Most Specific Method",page:"540",url:"",level:"4",children:[]},{caption:"15.12.2.6. Method Invocation Type",page:"543",url:"",level:"4",children:[]}]},{caption:"15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?",page:"543",url:"",level:"3",children:[]},{caption:"15.12.4. Run-Time Evaluation of Method Invocation",page:"546",url:"",level:"3",children:[{caption:"15.12.4.1. Compute Target Reference (If Necessary)",page:"547",url:"",level:"4",children:[]},{caption:"15.12.4.2. Evaluate Arguments",page:"548",url:"",level:"4",children:[]},{caption:"15.12.4.3. Check Accessibility of Type and Method",page:"549",url:"",level:"4",children:[]},{caption:"15.12.4.4. Locate Method to Invoke",page:"550",url:"",level:"4",children:[]},{caption:"15.12.4.5. Create Frame, Synchronize, Transfer Control",page:"554",url:"",level:"4",children:[]}]}]},{caption:"15.13. Method Reference Expressions",page:"556",url:"",level:"2",children:[{caption:"15.13.1. Compile-Time Declaration of a Method Reference",page:"559",url:"",level:"3",children:[]},{caption:"15.13.2. Type of a Method Reference",page:"564",url:"",level:"3",children:[]},{caption:"15.13.3. Run-Time Evaluation of Method References",page:"566",url:"",level:"3",children:[]}]},{caption:"15.14. Postfix Expressions",page:"569",url:"",level:"2",children:[{caption:"15.14.1. Expression Names",page:"570",url:"",level:"3",children:[]},{caption:"15.14.2. Postfix Increment Operator ++",page:"570",url:"",level:"3",children:[]},{caption:"15.14.3. Postfix Decrement Operator --",page:"571",url:"",level:"3",children:[]}]},{caption:"15.15. Unary Operators",page:"571",url:"",level:"2",children:[{caption:"15.15.1. Prefix Increment Operator ++",page:"573",url:"",level:"3",children:[]},{caption:"15.15.2. Prefix Decrement Operator --",page:"573",url:"",level:"3",children:[]},{caption:"15.15.3. Unary Plus Operator +",page:"574",url:"",level:"3",children:[]},{caption:"15.15.4. Unary Minus Operator -",page:"574",url:"",level:"3",children:[]},{caption:"15.15.5. Bitwise Complement Operator ~",page:"575",url:"",level:"3",children:[]},{caption:"15.15.6. Logical Complement Operator !",page:"575",url:"",level:"3",children:[]}]},{caption:"15.16. Cast Expressions",page:"576",url:"",level:"2",children:[]},{caption:"15.17. Multiplicative Operators",page:"577",url:"",level:"2",children:[{caption:"15.17.1. Multiplication Operator *",page:"578",url:"",level:"3",children:[]},{caption:"15.17.2. Division Operator /",page:"579",url:"",level:"3",children:[]},{caption:"15.17.3. Remainder Operator %",page:"581",url:"",level:"3",children:[]}]},{caption:"15.18. Additive Operators",page:"583",url:"",level:"2",children:[{caption:"15.18.1. String Concatenation Operator +",page:"584",url:"",level:"3",children:[]},{caption:"15.18.2. Additive Operators (+ and -) for Numeric Types",page:"586",url:"",level:"3",children:[]}]},{caption:"15.19. Shift Operators",page:"588",url:"",level:"2",children:[]},{caption:"15.20. Relational Operators",page:"589",url:"",level:"2",children:[{caption:"15.20.1. Numerical Comparison Operators <, <=, >, and >=",page:"590",url:"",level:"3",children:[]},{caption:"15.20.2. Type Comparison Operator instanceof",page:"591",url:"",level:"3",children:[]}]},{caption:"15.21. Equality Operators",page:"592",url:"",level:"2",children:[{caption:"15.21.1. Numerical Equality Operators == and !=",page:"593",url:"",level:"3",children:[]},{caption:"15.21.2. Boolean Equality Operators == and !=",page:"594",url:"",level:"3",children:[]},{caption:"15.21.3. Reference Equality Operators == and !=",page:"594",url:"",level:"3",children:[]}]},{caption:"15.22. Bitwise and Logical Operators",page:"595",url:"",level:"2",children:[{caption:"15.22.1. Integer Bitwise Operators &, ^, and |",page:"595",url:"",level:"3",children:[]},{caption:"15.22.2. Boolean Logical Operators &, ^, and |",page:"596",url:"",level:"3",children:[]}]},{caption:"15.23. Conditional-And Operator &&",page:"597",url:"",level:"2",children:[]},{caption:"15.24. Conditional-Or Operator  ",page:"597",url:"",level:"2",children:[]},{caption:"15.25. Conditional Operator ? :",page:"598",url:"",level:"2",children:[{caption:"15.25.1. Boolean Conditional Expressions",page:"606",url:"",level:"3",children:[]},{caption:"15.25.2. Numeric Conditional Expressions",page:"606",url:"",level:"3",children:[]},{caption:"15.25.3. Reference Conditional Expressions",page:"607",url:"",level:"3",children:[]}]},{caption:"15.26. Assignment Operators",page:"608",url:"",level:"2",children:[{caption:"15.26.1. Simple Assignment Operator =",page:"609",url:"",level:"3",children:[]},{caption:"15.26.2. Compound Assignment Operators",page:"615",url:"",level:"3",children:[]}]},{caption:"15.27. Lambda Expressions",page:"621",url:"",level:"2",children:[{caption:"15.27.1. Lambda Parameters",page:"623",url:"",level:"3",children:[]},{caption:"15.27.2. Lambda Body",page:"626",url:"",level:"3",children:[]},{caption:"15.27.3. Type of a Lambda Expression",page:"629",url:"",level:"3",children:[]},{caption:"15.27.4. Run-Time Evaluation of Lambda Expressions",page:"631",url:"",level:"3",children:[]}]},{caption:"15.28. Constant Expressions",page:"632",url:"",level:"2",children:[]}]},{caption:"16. Definite Assignment",page:"635",url:"",level:"1",children:[{caption:"16.1. Definite Assignment and Expressions",page:"641",url:"",level:"2",children:[{caption:"16.1.1. Boolean Constant Expressions",page:"641",url:"",level:"3",children:[]},{caption:"16.1.2. Conditional-And Operator &&",page:"641",url:"",level:"3",children:[]},{caption:"16.1.3. Conditional-Or Operator  ",page:"642",url:"",level:"3",children:[]},{caption:"16.1.4. Logical Complement Operator !",page:"642",url:"",level:"3",children:[]},{caption:"16.1.5. Conditional Operator ? :",page:"642",url:"",level:"3",children:[]},{caption:"16.1.6. Conditional Operator ? :",page:"643",url:"",level:"3",children:[]},{caption:"16.1.7. Other Expressions of Type boolean",page:"643",url:"",level:"3",children:[]},{caption:"16.1.8. Assignment Expressions",page:"643",url:"",level:"3",children:[]},{caption:"16.1.9. Operators ++ and --",page:"644",url:"",level:"3",children:[]},{caption:"16.1.10. Other Expressions",page:"644",url:"",level:"3",children:[]}]},{caption:"16.2. Definite Assignment and Statements",page:"645",url:"",level:"2",children:[{caption:"16.2.1. Empty Statements",page:"645",url:"",level:"3",children:[]},{caption:"16.2.2. Blocks",page:"645",url:"",level:"3",children:[]},{caption:"16.2.3. Local Class Declaration Statements",page:"647",url:"",level:"3",children:[]},{caption:"16.2.4. Local Variable Declaration Statements",page:"647",url:"",level:"3",children:[]},{caption:"16.2.5. Labeled Statements",page:"647",url:"",level:"3",children:[]},{caption:"16.2.6. Expression Statements",page:"648",url:"",level:"3",children:[]},{caption:"16.2.7. if Statements",page:"648",url:"",level:"3",children:[]},{caption:"16.2.8. assert Statements",page:"648",url:"",level:"3",children:[]},{caption:"16.2.9. switch Statements",page:"649",url:"",level:"3",children:[]},{caption:"16.2.10. while Statements",page:"649",url:"",level:"3",children:[]},{caption:"16.2.11. do Statements",page:"650",url:"",level:"3",children:[]},{caption:"16.2.12. for Statements",page:"650",url:"",level:"3",children:[{caption:"16.2.12.1. Initialization Part of for Statement",page:"651",url:"",level:"4",children:[]},{caption:"16.2.12.2. Incrementation Part of for Statement",page:"651",url:"",level:"4",children:[]}]},{caption:"16.2.13. break, continue, return, and throw Statements",page:"652",url:"",level:"3",children:[]},{caption:"16.2.14. synchronized Statements",page:"652",url:"",level:"3",children:[]},{caption:"16.2.15. try Statements",page:"652",url:"",level:"3",children:[]}]},{caption:"16.3. Definite Assignment and Parameters",page:"654",url:"",level:"2",children:[]},{caption:"16.4. Definite Assignment and Array Initializers",page:"654",url:"",level:"2",children:[]},{caption:"16.5. Definite Assignment and Enum Constants",page:"654",url:"",level:"2",children:[]},{caption:"16.6. Definite Assignment and Anonymous Classes",page:"655",url:"",level:"2",children:[]},{caption:"16.7. Definite Assignment and Member Types",page:"655",url:"",level:"2",children:[]},{caption:"16.8. Definite Assignment and Static Initializers",page:"656",url:"",level:"2",children:[]},{caption:"16.9. Definite Assignment, Constructors, and Instance Initializers",page:"656",url:"",level:"2",children:[]}]},{caption:"17. Threads and Locks",page:"659",url:"",level:"1",children:[{caption:"17.1. Synchronization",page:"660",url:"",level:"2",children:[]},{caption:"17.2. Wait Sets and Notification",page:"660",url:"",level:"2",children:[{caption:"17.2.1. Wait",page:"661",url:"",level:"3",children:[]},{caption:"17.2.2. Notification",page:"662",url:"",level:"3",children:[]},{caption:"17.2.3. Interruptions",page:"663",url:"",level:"3",children:[]},{caption:"17.2.4. Interactions of Waits, Notification, and Interruption",page:"663",url:"",level:"3",children:[]}]},{caption:"17.3. Sleep and Yield",page:"664",url:"",level:"2",children:[]},{caption:"17.4. Memory Model",page:"665",url:"",level:"2",children:[{caption:"17.4.1. Shared Variables",page:"668",url:"",level:"3",children:[]},{caption:"17.4.2. Actions",page:"668",url:"",level:"3",children:[]},{caption:"17.4.3. Programs and Program Order",page:"669",url:"",level:"3",children:[]},{caption:"17.4.4. Synchronization Order",page:"670",url:"",level:"3",children:[]},{caption:"17.4.5. Happens-before Order",page:"671",url:"",level:"3",children:[]},{caption:"17.4.6. Executions",page:"674",url:"",level:"3",children:[]},{caption:"17.4.7. Well-Formed Executions",page:"675",url:"",level:"3",children:[]},{caption:"17.4.8. Executions and Causality Requirements",page:"675",url:"",level:"3",children:[]},{caption:"17.4.9. Observable Behavior and Nonterminating Executions",page:"678",url:"",level:"3",children:[]}]},{caption:"17.5. final Field Semantics",page:"680",url:"",level:"2",children:[{caption:"17.5.1. Semantics of final Fields",page:"682",url:"",level:"3",children:[]},{caption:"17.5.2. Reading final Fields During Construction",page:"682",url:"",level:"3",children:[]},{caption:"17.5.3. Subsequent Modification of final Fields",page:"683",url:"",level:"3",children:[]},{caption:"17.5.4. Write-Protected Fields",page:"684",url:"",level:"3",children:[]}]},{caption:"17.6. Word Tearing",page:"685",url:"",level:"2",children:[]},{caption:"17.7. Non-Atomic Treatment of double and long",page:"686",url:"",level:"2",children:[]}]},{caption:"18. Type Inference",page:"687",url:"",level:"1",children:[{caption:"18.1. Concepts and Notation",page:"688",url:"",level:"2",children:[{caption:"18.1.1. Inference Variables",page:"688",url:"",level:"3",children:[]},{caption:"18.1.2. Constraint Formulas",page:"689",url:"",level:"3",children:[]},{caption:"18.1.3. Bounds",page:"689",url:"",level:"3",children:[]}]},{caption:"18.2. Reduction",page:"691",url:"",level:"2",children:[{caption:"18.2.1. Expression Compatibility Constraints",page:"691",url:"",level:"3",children:[]},{caption:"18.2.2. Type Compatibility Constraints",page:"696",url:"",level:"3",children:[]},{caption:"18.2.3. Subtyping Constraints",page:"697",url:"",level:"3",children:[]},{caption:"18.2.4. Type Equality Constraints",page:"698",url:"",level:"3",children:[]},{caption:"18.2.5. Checked Exception Constraints",page:"699",url:"",level:"3",children:[]}]},{caption:"18.3. Incorporation",page:"701",url:"",level:"2",children:[{caption:"18.3.1. Complementary Pairs of Bounds",page:"702",url:"",level:"3",children:[]},{caption:"18.3.2. Bounds Involving Capture Conversion",page:"703",url:"",level:"3",children:[]}]},{caption:"18.4. Resolution",page:"704",url:"",level:"2",children:[]},{caption:"18.5. Uses of Inference",page:"706",url:"",level:"2",children:[{caption:"18.5.1. Invocation Applicability Inference",page:"706",url:"",level:"3",children:[]},{caption:"18.5.2. Invocation Type Inference",page:"708",url:"",level:"3",children:[]},{caption:"18.5.3. Functional Interface Parameterization Inference",page:"714",url:"",level:"3",children:[]},{caption:"18.5.4. More Specific Method Inference",page:"715",url:"",level:"3",children:[]}]}]},{caption:"19. Syntax",page:"719",url:"",level:"1",children:[]},{caption:"Index",page:"745",url:"",level:"1",children:[]},{caption:"A. Limited License Grant",page:"785",url:"",level:"1",children:[]}];